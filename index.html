<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"mvilplss.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="一行知,二行理,三行本">
<meta property="og:type" content="website">
<meta property="og:title" content="三行">
<meta property="og:url" content="http://mvilplss.github.io/index.html">
<meta property="og:site_name" content="三行">
<meta property="og:description" content="一行知,二行理,三行本">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="三行">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://mvilplss.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>三行</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">三行</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">一行知,二行理,三行本</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">三行</p>
  <div class="site-description" itemprop="description">一行知,二行理,三行本</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2021/04/17/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%B8%80%E7%99%BE%E9%97%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/17/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%B8%80%E7%99%BE%E9%97%AE/" class="post-title-link" itemprop="url">Java之并发一百问</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-17 00:00:00" itemprop="dateCreated datePublished" datetime="2021-04-17T00:00:00+08:00">2021-04-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:03" itemprop="dateModified" datetime="2022-07-05T22:46:03+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">开发技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java之并发一百问"><a href="#Java之并发一百问" class="headerlink" title="Java之并发一百问"></a>Java之并发一百问</h1><h2 id="Q1：线程越多程序是否就运行得越快？"><a href="#Q1：线程越多程序是否就运行得越快？" class="headerlink" title="Q1：线程越多程序是否就运行得越快？"></a>Q1：线程越多程序是否就运行得越快？</h2><p>答：并发编程的目的是为了让程序运行得更快，但是并不是启动得线程越多就能让程序最大限度地并发执行。在并发编程时，如果希望通过多线程执行任务让程序运行得更快会面临很多挑战，比如上下文切换的问题、死锁的问题，以及受限于硬件和软件的资源限制问题。</p>
<h2 id="Q2：多线程并发是怎么实现的，必须要用多核处理器实现吗？"><a href="#Q2：多线程并发是怎么实现的，必须要用多核处理器实现吗？" class="headerlink" title="Q2：多线程并发是怎么实现的，必须要用多核处理器实现吗？"></a>Q2：多线程并发是怎么实现的，必须要用多核处理器实现吗？</h2><p>答：即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短（一般是几十毫秒），所以CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的。- Q3：什么是上下文切换？答:CPU是通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是在切换前会保存上一个任务的状态，以便下次再切换回这个任务时可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p>
<h2 id="Q4：如何减少上下文切换？"><a href="#Q4：如何减少上下文切换？" class="headerlink" title="Q4：如何减少上下文切换？"></a>Q4：如何减少上下文切换？</h2><p>答：①无锁并发编程：多线程竞争锁时会引起上下文切换，所以多线程处理数据时，可以通过一些方法来避免使用锁，例如将数据的id按照hash算法取模分段，不同的线程处理不同数据段的数据。②CAS算法：Java的atomic包使用CAS算法来更新数据而不需要加锁。③使用最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。④协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</p>
<h2 id="Q5：多线程避免死锁的方法？"><a href="#Q5：多线程避免死锁的方法？" class="headerlink" title="Q5：多线程避免死锁的方法？"></a>Q5：多线程避免死锁的方法？</h2><p>答：①避免一个线程同时获得多个锁。②避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。③尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制。④对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的问题。</p>
<h2 id="Q6：volatile关键字的作用？"><a href="#Q6：volatile关键字的作用？" class="headerlink" title="Q6：volatile关键字的作用？"></a>Q6：volatile关键字的作用？</h2><p>答：①volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的可见性。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。②如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。③如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一样的。</p>
<h2 id="Q7：volatile的底层是如何实现的？"><a href="#Q7：volatile的底层是如何实现的？" class="headerlink" title="Q7：volatile的底层是如何实现的？"></a>Q7：volatile的底层是如何实现的？</h2><p>答：有volatile修饰的共享变量在进行写操作时的汇编代码是具有lock前缀的指令，lock前缀的指令在多核处理器下会引发两件事：①将当前处理器缓存行的数据写回到系统内存。②处理器将缓存回写到内存的操作会使在其他CPU里缓存了该内存地址的数据无效。为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存后再进行操作，但操作完不知道何时会写回内存。如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条lock前缀的指令，将这个变量在缓存行的数据写回到系统内存。但是就算写回内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题（ABA问题）。所以在多处理器下，为了保证各个处理器的缓存是一致的就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p>
<h2 id="Q8：volatile如何优化性能？"><a href="#Q8：volatile如何优化性能？" class="headerlink" title="Q8：volatile如何优化性能？"></a>Q8：volatile如何优化性能？</h2><p>答：可以通过追加字节的方式优化性能，例如JDK7中的队列集合类LinkedTransferQueue就是使用了追加字节的方式来优化队列出队和入队的性能。由于一些处理器的高速缓存行是64个字节宽，不支持部分填充缓存行，如果队列的头节点和尾节点都不足64字节，当一个处理器试图修改头节点时就会将整个缓存行锁定，那么在缓存一致性的作用下会导致其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队又会频繁修改头节点和尾节点，因此多处理器情况下会严重影响队列的入队和出队效率。追加到64字节后就可以填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使它们的操作不会互相锁定。但以下两种场景不应该使用这种方式：①缓存行非64字节宽的处理器。②共享变量不会被频繁地写，因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定性能消耗。如果共享变量不被频繁写，锁的几率很小没有必要避免互相锁定。不过这种追加字节的方式在Java7可能不生效，因为Java7可以淘汰或重新排列无用字段，需要使用其他追加字节的方式。</p>
<h2 id="Q9：synchronized锁的形式有哪些？"><a href="#Q9：synchronized锁的形式有哪些？" class="headerlink" title="Q9：synchronized锁的形式有哪些？"></a>Q9：synchronized锁的形式有哪些？</h2><p>答：①对于同步普通方法，锁是当前实例对象。②对于静态同步方法，锁是当前类的Class对象。③对于同步方法块，锁是synchronized括号里配置的对象。</p>
<h2 id="Q10：synchronized的底层是怎么实现的？"><a href="#Q10：synchronized的底层是怎么实现的？" class="headerlink" title="Q10：synchronized的底层是怎么实现的？"></a>Q10：synchronized的底层是怎么实现的？</h2><p>答：JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步是使用另一种方式实现的，细节并未在JVM规范中详细说明，但是方法的同步也可以使用这两个指令来实现。monitorenter指令是编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有monitorexit与之配对。任何对象都有一个monitor与之关联，当一个monitor被持有后它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。</p>
<h2 id="Q11：什么是锁升级（锁优化）？"><a href="#Q11：什么是锁升级（锁优化）？" class="headerlink" title="Q11：什么是锁升级（锁优化）？"></a>Q11：什么是锁升级（锁优化）？</h2><p>答：JDK1.6为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁，在JDK1.6中，锁一共有4个状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，如果偏向锁升级成轻量级锁后就不能降级成偏向锁，这种只能升级不能降级的锁策略是为了提高获得锁和释放锁的效率。</p>
<h2 id="Q12：偏向锁的获得原理是什么？"><a href="#Q12：偏向锁的获得原理是什么？" class="headerlink" title="Q12：偏向锁的获得原理是什么？"></a>Q12：偏向锁的获得原理是什么？</h2><p>答：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步代码块并获取锁时，会在对象头和帧栈中的锁记录里存储锁偏向的线程ID，以后该线程再进入和退出同步代码块不需要进行CAS操作来加锁和解锁，只需要简单地测试一下对象头（synchronized用的锁存在Java的对象头里）的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功表示线程已经获得了锁，如果测试失败则需要再测试一下Mark Word（主要存储锁状态、对象的hashCode、对象的分代年龄、是否是偏向锁、锁标志位）中偏向锁的标识是否设置成了1（表示当前是偏向锁），如果设置了就尝试使用CAS将对象头的偏向锁指向当前线程，否则使用CAS竞争锁。</p>
<h2 id="Q13：偏向锁的撤销原理是什么？"><a href="#Q13：偏向锁的撤销原理是什么？" class="headerlink" title="Q13：偏向锁的撤销原理是什么？"></a>Q13：偏向锁的撤销原理是什么？</h2><p>答：偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（该时间点上没有正在执行的字节码），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态则将对象头设为无锁状态；如果线程还活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。</p>
<h2 id="Q14：偏向锁的打开和关闭是怎么实现的？"><a href="#Q14：偏向锁的打开和关闭是怎么实现的？" class="headerlink" title="Q14：偏向锁的打开和关闭是怎么实现的？"></a>Q14：偏向锁的打开和关闭是怎么实现的？</h2><p>答：偏向锁在Java6和Java7中默认是开启的，但是它在应用程序启动几秒后才激活，如果有必要可以使用JVM参数来关闭延迟：-XX：BiasedLockingStartupDelay=0。如果你确定应用程序里所有的锁通常情况处于竞争状态，可以通过JVM参数来关闭偏向锁：-XX：UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。</p>
<h2 id="Q15：轻量级锁的加锁原理是什么？"><a href="#Q15：轻量级锁的加锁原理是什么？" class="headerlink" title="Q15：轻量级锁的加锁原理是什么？"></a>Q15：轻量级锁的加锁原理是什么？</h2><p>答:线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针，如果成功那么当前线程获得锁，如果失败表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>
<h2 id="Q16：轻量级锁的解锁原理是什么？"><a href="#Q16：轻量级锁的解锁原理是什么？" class="headerlink" title="Q16：轻量级锁的解锁原理是什么？"></a>Q16：轻量级锁的解锁原理是什么？</h2><p>答：轻量级锁解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功则表示没有竞争发生。如果失败则表示当前存在锁竞争，锁就会膨胀为重量级锁。因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞了），一旦锁升级为重量级锁，就不会再恢复到轻量级锁的状态。在这种情况下，其他线程视图获取锁时都会被阻塞，当持有锁的线程释放锁后才会唤醒这些线程，被唤醒的线程就会对锁资源进行新一轮的争夺。</p>
<h2 id="Q17：偏向锁、轻量级锁和重量级锁的区别？"><a href="#Q17：偏向锁、轻量级锁和重量级锁的区别？" class="headerlink" title="Q17：偏向锁、轻量级锁和重量级锁的区别？"></a>Q17：偏向锁、轻量级锁和重量级锁的区别？</h2><p>答：①偏向锁的优点是加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距，缺点是如果线程间存在锁竞争会带来额外锁撤销的消耗，适用于只有一个线程访问同步代码块的场景。②轻量级锁的优点是竞争的线程不会阻塞，提高了程序的响应速度，缺点是如果线程始终得不到锁会自旋消耗CPU，适用于追求响应时间和同步代码块执行非常快的场景。③重量级锁的优点是线程竞争不使用自旋不会消耗CPU，缺点是线程会被阻塞，响应时间很慢，适应于追求吞吐量，同步代码块执行较慢的场景。</p>
<h2 id="Q18：原子操作是什么，处理器是怎么实现原子操作的？"><a href="#Q18：原子操作是什么，处理器是怎么实现原子操作的？" class="headerlink" title="Q18：原子操作是什么，处理器是怎么实现原子操作的？"></a>Q18：原子操作是什么，处理器是怎么实现原子操作的？</h2><p>答:原子操作即不可被中断的一个或一系列操作，处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。①通过总线锁定保证原子性：如果多个处理器同时对共享变量进行读改写操作（例如i++），那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子性的，操作完之后共享变量的值会和期望的不一样。例如i=1，进行两次i++操作，但是结果可能为2。这是因为多个处理器同时从各自的缓存读取变量i，分别进行加1操作，然后分别写入系统内存中。如果想要保证读改写操作的原子性，就必须保证CPU1读改写共享变量时CPU2不能操作缓存了该共享变量内存地址的缓存。处理器使用总线锁来解决这个问题，总线锁就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞，该处理器就可以独占共享内存。②通过缓存锁定来保证原子性：同一时刻只需要保存对某个内存地址的访问是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间其他处理器不能操作其他内存地址的数据，开销比较大，目前的处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。频繁使用的内存会缓存在处理器的高速缓存里，原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁。缓存锁定是指内存区域如果被缓存在处理器的缓存行中并且在Lock操作期间被锁定，那么当它执行锁操作回写内存时，处理器不在总线上声言LOCK#信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作原子性，因为缓存一致性会阻止同时修改由两个以上处理器缓存的内存区域，当其他处理器回写已被锁定的缓存行数据时会使缓存行无效。</p>
<h2 id="Q19：不会使用缓存锁定的情况有哪些？"><a href="#Q19：不会使用缓存锁定的情况有哪些？" class="headerlink" title="Q19：不会使用缓存锁定的情况有哪些？"></a>Q19：不会使用缓存锁定的情况有哪些？</h2><p>答：①当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，处理器会调用总线锁定。②有些处理器不支持缓存锁定，例如Intel486和Pentium处理器，即使锁定的内存区域在处理器的缓存行中也会调用总线锁定。</p>
<h2 id="Q20：缓存行和CAS是什么？"><a href="#Q20：缓存行和CAS是什么？" class="headerlink" title="Q20：缓存行和CAS是什么？"></a>Q20：缓存行和CAS是什么？</h2><p>答：①缓存行：缓存的最小操作单位。②CAS：Compare and Swap，比较并交换，CAS需要两个数值，一个是旧值（期望操作前的值）和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化才交换成新值，发生了变化则不交换。</p>
<h2 id="Q21：Java中如何实现原子操作？"><a href="#Q21：Java中如何实现原子操作？" class="headerlink" title="Q21：Java中如何实现原子操作？"></a>Q21：Java中如何实现原子操作？</h2><p>答：Java中可以通过锁和循环CAS的方式来实现原子操作。锁机制保证了只有获得锁的线程才能操作锁定的内存区域，JVM内部实现了很多锁，除了偏向锁JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步代码块时使用循环CAS方式获取锁，退出时使用循环CAS释放锁。JVM中的CAS操作利用了处理器提供的交换指令CMPXCHG实现，自旋CAS的基本思路就是循环进行CAS操作直到成功为止。从Java1.5开始JDK的并发包里提供了一些类来支持原子操作，例如AtomicBoolean（用原子方式更新的boolean值），AtomicInteger（用原子方式更新的int值）和AtomicLong（用原子方式更新的long值），这些原子包装类还提供了有用的工具方法，比如以原子的方式将当前值自增1和自减1。</p>
<h2 id="Q22：CAS实现原子操作有什么问题？"><a href="#Q22：CAS实现原子操作有什么问题？" class="headerlink" title="Q22：CAS实现原子操作有什么问题？"></a>Q22：CAS实现原子操作有什么问题？</h2><p>答：①ABA问题：因为CAS需要在操作值的时候检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成B，又变成了A，那么使用CAS检查时会发现它的值并未发生变化。ABA问题的解决思路就是使用版本号，在变量前面追加版本号，每次更新时把版本号加1，那么A-&gt;B-&gt;A就会i变成1A-&gt;2B-&gt;3A。从Java1.5开始，JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题，这个类的compareAndSet方法首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和标志的值设置为给定的更新值。②循环时间长，开销大：自旋CAS如果长时间不成功会给CPU带来非常大的执行开销。如果JVM支持处理器提供的pause指令，就可以提升效率，因为pause指令可以延迟流水线执行指令，使CPU不会消耗过多的执行资源，延迟的时间取决于具体版本；避免在退出循环时因为内存顺序冲突而引起CPU流水线被清空，从而提高CPU的执行效率。③只能保证一个共享变量的原子操作：循环CAS不能保证多个共享变量操作的原子性，可以使用锁或把多个共享变量合成为一个，放在一个对象里进行CAS操作。</p>
<h2 id="Q23：Java中线程是如何通信和同步的？"><a href="#Q23：Java中线程是如何通信和同步的？" class="headerlink" title="Q23：Java中线程是如何通信和同步的？"></a>Q23：Java中线程是如何通信和同步的？</h2><p>答：通信是指线程之间以何种机制来交换信息，在命令式编程中线程之间的通信机制有两种，共享内存和消息传递。在共享内存的并发模型里线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。在消息传递的并发模型里线程之间没有公共状态，线程之间必须通过发送消息来显示通信。同步是指程序中用于控制不同线程间操作发生相对顺序的机制，在共享内存的并发模型里同步是显示进行的，程序员必须显示指定某个方法或代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在接受之前，同步是隐式进行的。Java并发采用共享内存模型，线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p>
<h2 id="Q24：哪些数据会存在内存可见性问题？"><a href="#Q24：哪些数据会存在内存可见性问题？" class="headerlink" title="Q24：哪些数据会存在内存可见性问题？"></a>Q24：哪些数据会存在内存可见性问题？</h2><p>答：在Java中，所有实例域、静态域和数组元素都存储在堆中，堆内存在线程之间共享，因此这些共享变量存在内存可见性问题。局部变量、方法定义参数和异常处理器参数等不会在线程之间共享，不会存在内存可见性问题，也不受内存模型的影响。</p>
<h2 id="Q25：JMM是什么？"><a href="#Q25：JMM是什么？" class="headerlink" title="Q25：JMM是什么？"></a>Q25：JMM是什么？</h2><p>答：JMM（Java Memory Model）是Java内存模型，Java线程之间的通信由JMM控制，JMM决定了一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。    两个线程之间的通信必须经过主内存，JMM通过控制主内存与每个线程的本地内存之间的交互来为Java程序员提供内存可见性保证。</p>
<h2 id="Q26：指令重排序是什么？"><a href="#Q26：指令重排序是什么？" class="headerlink" title="Q26：指令重排序是什么？"></a>Q26：指令重排序是什么？</h2><p>答：重排序指从源代码到指令序列的重排序，在执行程序时为了提高性能，编译器和处理器通常会对指令进行重排序，重排序分为三种类型。①编译器优化的重排序：编译器在不改变单线程程序语义的前提下可以重新安排语句的执行顺序。②指令级并行的重排序：现代处理器才以来指令级并行技术ILP来将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。③内存系统的重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作操作看上去可能是乱序执行。</p>
<h2 id="Q27：指令重排序的问题及解决？"><a href="#Q27：指令重排序的问题及解决？" class="headerlink" title="Q27：指令重排序的问题及解决？"></a>Q27：指令重排序的问题及解决？</h2><p>答：从Java源代码到最终实际执行的指令序列，会分别经历编译器优化重排序、指令级并行重排序和内存系统重排序。这些重排序可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令（一组用于实现对内存操作顺序限制的处理器指令），通过内存屏障指令来禁止特定类型的处理器重排序。JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的可见性内存保证。</p>
<h2 id="Q28：JMM内存屏障指令的分类有哪些？"><a href="#Q28：JMM内存屏障指令的分类有哪些？" class="headerlink" title="Q28：JMM内存屏障指令的分类有哪些？"></a>Q28：JMM内存屏障指令的分类有哪些？</h2><p>答：①Load Load，确保Load1的数据装载先于Load2及所有后续装载指令的装载。②Store Store，确保Store1数据对其他处理器可见（刷新到内存）先于Store2及所有后续存储指令的存储。③Load Store，确保Load1数据装载先于Store2及所有后续存储指令刷新到内存。④Store Load，确保Store1数据对其他处理器变得可见（刷新到内存）先于Load2及所有后续装载指令的装载。Store Load会使该屏障之间的所有内存访问指令（存储和装载指令）完成之后才执行该屏障之后的内存访问指令。该指令是一个“全能型”屏障，同时具备其他三个屏障的效果，现代的多处理器大多支持该屏障，执行该屏障的开销很昂贵，因为当前处理器通常要把写缓冲区的数据全部刷新到内存中。</p>
<h2 id="Q29：happens-before是什么？"><a href="#Q29：happens-before是什么？" class="headerlink" title="Q29：happens-before是什么？"></a>Q29：happens-before是什么？</h2><p>答：从JDK5开始，Java使用新的JSR-133内存模型，JSR-133使用happens-before的概念来阐述操作之间的内存可见性。在JMM中如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系，这两个操作既可以是在一个线程之内，也可以是不同线程之内。与程序员密切相关的happens-before规则如下：①程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。②监视器锁规则：对一个锁的解锁，happens-before于随后这个锁的加锁。③volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。④传递性，如果A happens-before B，且B happens-before C，那么A happens-before C。⑤start()规则，如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。⑥join()规则，如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。注意：两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行。happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。</p>
<h2 id="Q30：什么是数据依赖性？"><a href="#Q30：什么是数据依赖性？" class="headerlink" title="Q30：什么是数据依赖性？"></a>Q30：什么是数据依赖性？</h2><p>答：如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时两个操作之间就存在数据依赖性。数据以来分为以下三种类型：①写后读，写一个变量之后再读这个位置。②读后写，读一个变了之后再写这个变量。③写后写，写一个变量之后再写这个变量。上述三种情况只要重排序两个操作的执行顺序，程序的执行结果就会被改变。编译器和处理器为了性能优化可能会对操作重排序，在重排序时会遵守数据依赖性，不会改变存在数据依赖关系的两个操作的执行顺序。这里说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p>
<h2 id="Q31：as-if-serial语义是什么？"><a href="#Q31：as-if-serial语义是什么？" class="headerlink" title="Q31：as-if-serial语义是什么？"></a>Q31：as-if-serial语义是什么？</h2><p>答：as-if-serial指不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵循该语义。为了遵循该语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但如果操作之间不存在数据依赖关系，这些操作就可能被重排序。as-if-serial语义将单线程保护了起来，遵循as-if-serial语义的编译器、runtime和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按照程序的顺序执行的。as-if-serial使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。as-if-serial实例：例如计算一个圆的面积，A操作给半径赋值，B操作给圆周率赋值，C操作计算圆的面积。由于C依赖于A和B因此不会被重排到A和B的前面，但A和B之间没有数据依赖关系，所以程序的执行顺序可以是ABC或BAC，结果是一样的。</p>
<h2 id="Q32：控制依赖关系对指令重排序的影响？"><a href="#Q32：控制依赖关系对指令重排序的影响？" class="headerlink" title="Q32：控制依赖关系对指令重排序的影响？"></a>Q32：控制依赖关系对指令重排序的影响？</h2><p>答：当代码中存在控制依赖性时（例如A操作判断某标志位，B操作根据A的结果执行对应逻辑），会影响指令序列执行的并行度。为此编译器和处理会采用猜测执行来克服控制相关性对并行度的影响，可以提前计算出值保存到名为重排序缓冲的硬件缓存中，如果之前的控制条件满足就执行对应操作。在单线程程序中，对存在控制依赖的操作重排序并不会改变程序的执行结果（这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因）。但在多线程程序中，对存在控制依赖的操作从排序可能会改变程序的执行结果。</p>
<h2 id="Q33：数据竞争和顺序一致性是什么？"><a href="#Q33：数据竞争和顺序一致性是什么？" class="headerlink" title="Q33：数据竞争和顺序一致性是什么？"></a>Q33：数据竞争和顺序一致性是什么？</h2><p>答：当程序未正确同步时就可能存在数据竞争。JMM规范对数据竞争的定义如下：在一个线程中写一个变量，在另一个线程中读同一个变量，而且写和读没有通过同步来排序。当代码中包含数据竞争时程序的执行往往产生违反直觉的结果，如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序。JMM对正确同步的多线程程序的内存一致性做了如下保证：如果程序是正确同步的，程序的执行将具有顺序一致性，即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。这里的同步是指广义上的同步，包括对常用同步用语（synchronized、volatile和final）的正确使用。</p>
<h2 id="Q34：顺序一致性内存模型的特点？"><a href="#Q34：顺序一致性内存模型的特点？" class="headerlink" title="Q34：顺序一致性内存模型的特点？"></a>Q34：顺序一致性内存模型的特点？</h2><p>答：顺序一致性内存模型是一个理想化的理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：①一个线程中的所有操作必须按照程序的顺序来执行。②不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序，在顺序一致性的内存模型中，每个操作都必须原子执行并且立即对所有线程可见。在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程，同时每一个线程必须按照程序的顺序来执行内存读/写操作。在任意时间点最多只能有一个线程可以连接到内存，当多个线程并发执行时，开关装置能把线程的所有内存读/写操作串行化（即在顺序一致性模型中所有操作之间具有全序关系）。</p>
<h2 id="Q35：未同步程序在JMM中的问题？"><a href="#Q35：未同步程序在JMM中的问题？" class="headerlink" title="Q35：未同步程序在JMM中的问题？"></a>Q35：未同步程序在JMM中的问题？</h2><p>答：未同步程序在顺序一致性模型中虽然整体执行顺序无序但是所有线程都能看到一个一致的整体执行顺序。之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。JMM中没有这个保证，未同步程序在JMM中不但整体的执行顺序无序，并且所有线程看到的操作执行顺序也可能不一致。比如当前线程把写过的数据缓存到本地内存，在没有刷新到主内存前，这个写操作仅对当前线程可见。从其他线程的角度会认为这个写操作并没有执行，只有当前线程把本地内存中写过的数据刷新回主内存之后这个写操作才对其他线程可见，这种情况下当前线程和其他线程看到的操作执行顺序不一致。</p>
<h2 id="Q36：未同步程序的执行特性？"><a href="#Q36：未同步程序的执行特性？" class="headerlink" title="Q36：未同步程序的执行特性？"></a>Q36：未同步程序的执行特性？</h2><p>答：对于未同步或未正确同步的多线程程序，JMM只提供最小安全性：线程执行时读取到的值要么是之前某个线程写入的值，要么是默认值，JMM保证线程读操作读取到的值不会无中生有。为了实现最小安全性，JVM在堆上分配对象时首先会对内存空间进行清零，然后才会在上面分配对象（JVM内部同步这两个操作）。因此在已清零的内存空间分配对象时，域的默认初始化已经完成了。JMM不保证未同步程序的执行结果与该程序在顺序一致性模型的执行结果一致，因为如果想要保证一致需要禁止大量的处理器和编译器优化，这对程序执行性能会有很大影响。而且未同步程序在顺序一致性模型中执行时整体是无序的，结果无法预知，因此保证未同步执行程序在两个模型的执行结果一致没什么意义。</p>
<h2 id="Q37：未同步程序在JMM和顺序一致性模型的执行区别？"><a href="#Q37：未同步程序在JMM和顺序一致性模型的执行区别？" class="headerlink" title="Q37：未同步程序在JMM和顺序一致性模型的执行区别？"></a>Q37：未同步程序在JMM和顺序一致性模型的执行区别？</h2><p>答：①顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行。②顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。③JMM不保证对64位的long类型和double类型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。</p>
<h2 id="Q38：总线的工作机制是什么？"><a href="#Q38：总线的工作机制是什么？" class="headerlink" title="Q38：总线的工作机制是什么？"></a>Q38：总线的工作机制是什么？</h2><p>答：在计算机中，数据通过总线在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤称为总线事务。总线事务包括读事务和写事务。读事务从内存中传输数据到处理器，写事务从处理器传送数据到内存，每个事务会读/写内存中的一个或多个物理上连续的字，总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其他的处理器和IO设备执行内存的读/写。</p>
<h2 id="Q39：总线工作机制的好处？"><a href="#Q39：总线工作机制的好处？" class="headerlink" title="Q39：总线工作机制的好处？"></a>Q39：总线工作机制的好处？</h2><p>答：总线的工作机制可以把所有处理器对内存的访问以串行化的方式来执行，在任意时间点最多只能有一个处理器访问内存，这个特性确保了单个总线事务之中的内存读/写操作具有原子性。</p>
<h2 id="Q40：long和double变量的原子性问题？"><a href="#Q40：long和double变量的原子性问题？" class="headerlink" title="Q40：long和double变量的原子性问题？"></a>Q40：long和double变量的原子性问题？</h2><p>答：在一些32位的处理器上如果要求对64位数据的写操作具有原子性，会有比较大的开销。为了照顾这种处理器，Java语义规范鼓励但不强求JVM对64位的long和double类型变量的写操作具有原子性，当JVM在这种处理器上运行时可能会把一个64位的long/double变量写操作拆分为两个32位的写操作执行，这两个32位的写操作可能会被分配到不同的总线事务中执行，此时对这个64位的写操作不具有原子性。在JSR-133之前的旧内存模型允许把一个64位的double/long变量的读/写操作拆分位两个64位的读/写操作执行。从JSR-133内存模型（JDK5）开始，仅仅只允许把一个64位的long/double类型变量写操作拆分为两个32位的写操作来执行，任意的读操作在JSR-133中必须具有原子性（即任意读操作必须要在单个读事务中执行）。</p>
<h2 id="Q41：volatile变量的特性？"><a href="#Q41：volatile变量的特性？" class="headerlink" title="Q41：volatile变量的特性？"></a>Q41：volatile变量的特性？</h2><p>答：①可见性：对任意一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。②原子性：对任意单个volatile变量的读/写具有原子性，但类似于i++这种复合操作不具有原子性。</p>
<h2 id="Q42：volatile变量的内存语义？"><a href="#Q42：volatile变量的内存语义？" class="headerlink" title="Q42：volatile变量的内存语义？"></a>Q42：volatile变量的内存语义？</h2><p>答：从JSR-133开始，volatile变量的写-读可以实现线程之间的通信。从内存语义的角度来说，volatile的写-读与锁的释放-获取具有相同的内存效果。volatile写的内存语义如下：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。volatile读的内存语义如下：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。线程A写一个volatile变量，实质上是线程A向接下来要读这个volatile变量的某个线程发出了（其对共享变量所修改的）消息。线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息。线程A写一个volatile变量，线程B读一个volatile变量，实质上是线程A通过主内存向线程B发送消息。</p>
<h2 id="Q43：volatile指令重排序的特点？"><a href="#Q43：volatile指令重排序的特点？" class="headerlink" title="Q43：volatile指令重排序的特点？"></a>Q43：volatile指令重排序的特点？</h2><p>答：①当第二个操作是volatile写时，不管第一个操作是什么都不能重排序，这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。②当第一个操作是volatile读时，不管第二个操作是什么都不能重排序，这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。③当第一个操作是volatile写，第二个操作是volatile读时不能重排序。</p>
<h2 id="Q44：volatile内存语义是怎么实现的？"><a href="#Q44：volatile内存语义是怎么实现的？" class="headerlink" title="Q44：volatile内存语义是怎么实现的？"></a>Q44：volatile内存语义是怎么实现的？</h2><p>答：JMM通过分别限制编译器重排序和处理器重排序来实现volatile的内存语义。编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此JMM采取保守策略。</p>
<h2 id="Q45：JMM内存屏障插入策略有哪些？"><a href="#Q45：JMM内存屏障插入策略有哪些？" class="headerlink" title="Q45：JMM内存屏障插入策略有哪些？"></a>Q45：JMM内存屏障插入策略有哪些？</h2><p>答：①在每个volatile写操作之前插入一个Store Store屏障,禁止之前的普通写和之后的volatile写重排序。②在每个volatile写操作之后插入一个Store Load屏障，防止之前的volatile写与之后可能有的volatile读/写重排序，也可以在每个volatile变量读之前插入该屏障，考虑到一般是读多于写所以选择用这种方式提升执行效率，也可以看出JMM在实现上的一个特点：首先确保正确性，然后再去追求效率。③在每个volatile读操作之后插入一个Load Load屏障，禁止之后的普通读操作和之前的volatile读重排序。④在每个volatile读操作之后插入一个Load Store屏障，禁止之后的普通写操作和之前的volatile读重排序。</p>
<h2 id="Q46：JSR-133增强volatile内存语义的原因？"><a href="#Q46：JSR-133增强volatile内存语义的原因？" class="headerlink" title="Q46：JSR-133增强volatile内存语义的原因？"></a>Q46：JSR-133增强volatile内存语义的原因？</h2><p>答：在旧的内存模型中，虽然不允许volatile变量之间重排序，但允许volatile变量与普通变量重排序，可能导致内存不可见问题。在旧的内存模型中volatile的写-读没有锁的释放-获取所具有的内存语义，为了提供一种比锁更轻量级的线程通信机制，严格限制了编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和锁的释放-获取具有相同的内存语义。只要volatile变量与普通变量之间的重排序可能会破坏volatile的内存语义这种重排序就会被编译器重排序规则和处理器内存屏障插入策略禁止。</p>
<h2 id="Q47：锁的内存语义？"><a href="#Q47：锁的内存语义？" class="headerlink" title="Q47：锁的内存语义？"></a>Q47：锁的内存语义？</h2><p>答：当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。当线程获取锁时，JMM会把线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。锁的释放与volatile写具有相同的内存语义，锁获取与volatile读具有相同的内存语义。线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。线程A释放这个锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。</p>
<h2 id="Q48：锁的内存语义是怎么实现的？"><a href="#Q48：锁的内存语义是怎么实现的？" class="headerlink" title="Q48：锁的内存语义是怎么实现的？"></a>Q48：锁的内存语义是怎么实现的？</h2><p>答：公平锁和非公平锁释放时，最后都要写一个volatile变量state。公平锁获取锁时，首先会去读volatile变量，非公平锁获取锁时，首先会用CAS更新volatile变量的值，这个操作同时具有volatile读和volatile写的内存语义。因此锁的释放-获取内存语义的实现方式为：①利用volatile变量的写-读具有的内存语义。②利用CAS所附带的volatile读和volatile写的内存语义。</p>
<h2 id="Q49：Java中concurrent包的原子性是如何保证的？"><a href="#Q49：Java中concurrent包的原子性是如何保证的？" class="headerlink" title="Q49：Java中concurrent包的原子性是如何保证的？"></a>Q49：Java中concurrent包的原子性是如何保证的？</h2><p>答：由于Java的CAS同时具有volatile读和volatile写的内存语义，因此Java线程通信有以下四种方式：①A线程写volatile变量，随后B线程读这个volatile变量。②A线程写volatile变量，随后B线程用CAS更新该变量。③A线程用CAS更新一个volatile变量，随后B线程用CAS更新该变量。④A线程用CAS更新一个volatile变量，随后B线程读这个变量。Java的CAS会使用现代处理器上提供的高效机器级别的原子指令，这些原子指令以原子方式对内存进行读-改-写操作。同时volatile变量的读/写和CAS可以实现线程之间的通信，这些特性就是concurrent包的基石。concurrent包有一个通用的实现模式：首先声明共享变量为volatile，然后使用CAS的原子条件更新来实现线程之间的同步，同时配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。包括AQS，非阻塞数据结构和原子变量类这些基础类都是通过这种模式来实现的，而concurrent包中的高层类又是依赖这些基础类来实现的。</p>
<h2 id="Q50：final域的重排序规则？"><a href="#Q50：final域的重排序规则？" class="headerlink" title="Q50：final域的重排序规则？"></a>Q50：final域的重排序规则？</h2><p>答：对于final域，编译器和处理器要遵守两个重排序规则：①在构造方法内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。②初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</p>
<h2 id="Q51：写final域重排序的实现原理？"><a href="#Q51：写final域重排序的实现原理？" class="headerlink" title="Q51：写final域重排序的实现原理？"></a>Q51：写final域重排序的实现原理？</h2><p>答：写final域的重排序规则禁止把final域的写重排序到构造方法之外，这个规则的实现包含以下两方面：①JMM禁止编译器把final域的写重排序到构造方法之外。②编译器会在final域的写之后，构造方法的return之前，插入一个Store Store屏障，这个屏障禁止把final域的写重排序到构造方法之外。写final域的重排序可以确保在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。</p>
<h2 id="Q52：读final域重排序的实现原理？"><a href="#Q52：读final域重排序的实现原理？" class="headerlink" title="Q52：读final域重排序的实现原理？"></a>Q52：读final域重排序的实现原理？</h2><p>答：读final域的重排序规则是，在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（仅针对处理器）。编译器会在读final域操作的前面插入一个Load Load屏障。初次读对象引用与初次读该对象包含的final域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（例如alpha处理器），因此该规则就是专门针对这种处理器的。读final域的重排序规则可以确保在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。</p>
<h2 id="Q53：final域为引用对象时重排序的特点？"><a href="#Q53：final域为引用对象时重排序的特点？" class="headerlink" title="Q53：final域为引用对象时重排序的特点？"></a>Q53：final域为引用对象时重排序的特点？</h2><p>答：对于引用类型，写final域的重排序规则对编译器和处理器增加了如下约束：在构造方法内对一个final引用的对象的成员域的写入，与随后在构造方法外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p>
<h2 id="Q54：final引用的可见性问题？"><a href="#Q54：final引用的可见性问题？" class="headerlink" title="Q54：final引用的可见性问题？"></a>Q54：final引用的可见性问题？</h2><p>答：写final域的排序规则可以确保在对象引用为任意线程可见之前，该引用变量指向对象的final域已经在构造方法中被正确初始化过了。其实要实现这个保证还需要在构造方法内部，不能让这个被构造对象的引用为其他线程所见，也就是对象引用不能在构造方法中逸出。在构造方法返回前，被构造对象的引用不能为其他线程所见，因为此时的final域可能还没有被正确地初始化。在构造方法返回后，任意线程都将保证能看到final域正确初始化后地值。</p>
<h2 id="Q55：final语义在X86处理器的实现原理是什么？"><a href="#Q55：final语义在X86处理器的实现原理是什么？" class="headerlink" title="Q55：final语义在X86处理器的实现原理是什么？"></a>Q55：final语义在X86处理器的实现原理是什么？</h2><p>答：写final域的重排序规则是要求编译器在final域的写之后，构造方法return之前插入一个Store Store屏障，读final域的重排序规则是要求编译器在读final域的操作前插入一个Load Load屏障。由于X86处理器不会对写-写操作重排序，所以写final域需要的Store Store屏障会被省略。同样，由于X86处理器不会对存在间接依赖关系的操作做重排序，所以在X86处理器中读final域需要的Load Load屏障也会被省略掉。也就是说，X86处理器不会对final域的读/写插入任何内存屏障。</p>
<h2 id="Q56：JSR-133增强final语义的原因？"><a href="#Q56：JSR-133增强final语义的原因？" class="headerlink" title="Q56：JSR-133增强final语义的原因？"></a>Q56：JSR-133增强final语义的原因？</h2><p>答：在旧的Java内存模型中，一个最严重的缺陷就是线程可能看到final域的值会改变。比如一个线程看到一个int类型final域的值为0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个final域的值会发现值变为1（被某个线程初始化之后的值）。最常见的例子就是旧的Java内存模型中String的值可能会改变。为了修复该漏洞，JSR-133通过为final域增加写和读重排序规则，可以为Java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造方法中没有逸出），那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程都能看到这个final域在构造方法中被初始化之后的值。</p>
<h2 id="Q57：happens-before的重排序策略？"><a href="#Q57：happens-before的重排序策略？" class="headerlink" title="Q57：happens-before的重排序策略？"></a>Q57：happens-before的重排序策略？</h2><p>答：JMM将happens-before要求禁止的重排序分为了下面两类：会改变程序执行结果的重排序和不会改变程序执行结果的重排序。JMM对这两种不同性质的重排序采取了不同的策略，对于会改变程序执行结果的重排序JMM要求编译器和处理器必须禁止这种重排序；对于不会改变程序执行结果的重排序，JMM对编译器和处理器不做要求（JMM允许这种重排序）。JMM向程序员提供happens-before规则能满足程序员的需求，其规则不但简单易懂而且也向程序员提供了足够强的内存可见性保证（有些内存保证性不一定真实存在，例如不改变执行结果的指令重排序对程序员是透明的）。JMM对编译器和处理器的束缚已经尽可能地少，JMM遵循一个基本原则：只要不改变程序执行结果，编译器和处理器怎么优化都行。例如编译器分析某个锁只会单线程访问就消除该锁，某个volatile变量只会单线程访问就把它当作普通变量。</p>
<h2 id="Q58：happens-before的具体定义是什么？"><a href="#Q58：happens-before的具体定义是什么？" class="headerlink" title="Q58：happens-before的具体定义是什么？"></a>Q58：happens-before的具体定义是什么？</h2><p>答：①如果一个操作happens-before另一个操作，那么第一个操作的执行结果对第二个操作可见，并且第一个操作的执行顺序排在第二个操作之前。这是JMM对程序员的承诺。②两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序执行，如果重排序之后的执行结果与按照happens-before关系的执行结果一致，那么这种重排序是可以允许的。这是JMM对编译器和处理器的约束规则，JMM遵循一个基本原则：只要不改变程序执行结果，编译器和处理器怎么优化都行。JMM这么做的原因是程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行的语义不能被改变（即执行结果不能被改变）。因此happens-before关系的本质和as-if-serial一样。</p>
<h2 id="Q59：happens-before和as-if-serial的区别？"><a href="#Q59：happens-before和as-if-serial的区别？" class="headerlink" title="Q59：happens-before和as-if-serial的区别？"></a>Q59：happens-before和as-if-serial的区别？</h2><p>答：as-if-serial语义保证单线程程序的执行结果不被改变，happens-before保证正确同步的多线程程序的执行结果不被改变。as-if-serial语义给编写单线程程序的程序员创造了一种单线程程序是顺序执行的幻觉，happens-before关系给编写正确同步的多线程程序员创造了一种多线程程序是按照happens-before指定顺序执行的幻觉。这两种语义的目的都是为了在不改变程序执行结果的前提下尽可能提高程序执行的并行度。</p>
<h2 id="Q60：happens-before规则的相关实现原理？"><a href="#Q60：happens-before规则的相关实现原理？" class="headerlink" title="Q60：happens-before规则的相关实现原理？"></a>Q60：happens-before规则的相关实现原理？</h2><p>答：①程序顺序规则：编译器和处理器都要遵守as-if-serial语义，as-if-serial语义保证了程序顺序执行规则。②volatile规则：对一个volatile变量的读总是能看到（任意线程）之前对这个volatile变量最后的写入，因此volatile的这个特性可以保证实现volatile规则。③传递性规则：由volatile的内存屏障插入策略和volatile的编译器重排序规则共同保证。</p>
<h2 id="Q61：处理器内存模型的分类？"><a href="#Q61：处理器内存模型的分类？" class="headerlink" title="Q61：处理器内存模型的分类？"></a>Q61：处理器内存模型的分类？</h2><p>答：①放松程序中写-读操作的顺序，由此产生了TSO内存模型。②在TSO的基础上继续放松程序中写-写操作的顺序，由此产生了PSO内存模型。③在TSO和PSO的基础上，继续放松程序中读-写（以两个操作之间不存在数据依赖性为前提）和读-读操作的顺序，由此产生了RMO和PowerPC内存模型。</p>
<h2 id="Q62：JMM对不同处理器模型的处理？"><a href="#Q62：JMM对不同处理器模型的处理？" class="headerlink" title="Q62：JMM对不同处理器模型的处理？"></a>Q62：JMM对不同处理器模型的处理？</h2><p>答：不同的处理器模型，性能越好，内存模型的设计越弱，因为处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。由于常见的处理器内存模型比JMM要弱，Java编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时由于各种处理器内存模型的强弱不同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM在不同的处理器中需要插入的内存屏障的数量和种类也不同。JMM屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为Java程序员呈现了一个一致的内存模型。</p>
<h2 id="Q63-Java程序内存可见性保证的分类？"><a href="#Q63-Java程序内存可见性保证的分类？" class="headerlink" title="Q63:Java程序内存可见性保证的分类？"></a>Q63:Java程序内存可见性保证的分类？</h2><p>答：①单线程程序：单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在一致性模型中的执行结果相同。②正确同步的多线程程序：正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在一致性模型中的执行结果相同）。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。③未同步/未正确同步的多线程程序：JMM为它们提供了最小安全性保证，线程执行读取到的值要么是之前某个线程写入的值，要么是默认值，但不保证该值是正确的。</p>
<h2 id="Q64：JSR-133对旧内存模型的修补有什么？"><a href="#Q64：JSR-133对旧内存模型的修补有什么？" class="headerlink" title="Q64：JSR-133对旧内存模型的修补有什么？"></a>Q64：JSR-133对旧内存模型的修补有什么？</h2><p>答：①增强volatile的内存语义，旧内存模型允许volatile变量与普通变量重排序。JSR-133严格限制volatile变量与普通变量的重排序，使volatile的写-读和锁的释放-获取具有相同的内存语义。②增强final的内存语义，旧内存模型中多次读取同一个final变量的值可能会不相同，为此JSR-133为final增加了两个重排序规则。在保证final引用不会从构造方法逸出的情况下，final具有了初始化安全性。</p>
<h2 id="Q64：什么是线程？"><a href="#Q64：什么是线程？" class="headerlink" title="Q64：什么是线程？"></a>Q64：什么是线程？</h2><p>答：现代操作系统在运行一个程序时会为其创建一个进程，而操作系统调度的最小单位是线程，线程也叫轻量级进程。在一个进程中可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上告诉切换，让使用者感觉到这些线程在同时执行。</p>
<h2 id="Q65：为什么要使用多线程？"><a href="#Q65：为什么要使用多线程？" class="headerlink" title="Q65：为什么要使用多线程？"></a>Q65：为什么要使用多线程？</h2><p>答：①可以更好地利用多处理器核心。线程是大多数操作系统调度的基本单位，一个程序作为一个进程来运行，程序运行过程中能创建多个线程，而一个线程一个时刻只能运行在一个处理器核心上。单线程最多使用一个处理器核心，加入再多的处理器核心也无法提升程序的执行效率，多线程技术将计算逻辑分配到多个处理器核心，显著提升程序执行效率。②可以获得更快的响应时间。在一些复杂的业务逻辑中，可以使用多线程技术，将数据一致性不强的操作派发给其他线程处理，可以缩短响应时间，提升用户体验。③Java为程序员提供了良好的一致的编程模型，使开发者可以更加专注于问题的解决，而不是思考如何使其多线程化。</p>
<h2 id="Q66：什么是线程优先级？"><a href="#Q66：什么是线程优先级？" class="headerlink" title="Q66：什么是线程优先级？"></a>Q66：什么是线程优先级？</h2><p>答：现代操作系统基本采用时分形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待下次分配。线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。</p>
<h2 id="Q67：如何设置线程优先级？"><a href="#Q67：如何设置线程优先级？" class="headerlink" title="Q67：如何设置线程优先级？"></a>Q67：如何设置线程优先级？</h2><p>答：在Java中通过一个整形成员变量priority来控制线程优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5,优先级高的线程分配时间片的数量要多于优先级低的线程。设置线程优先级时，针对频繁阻塞（休眠或者IO操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。在不同的JVM以及操作系统上，线程规划会存在差异，有些操作系统甚至会忽略对线程优先级的设定。</p>
<h2 id="Q68：线程有哪些状态？"><a href="#Q68：线程有哪些状态？" class="headerlink" title="Q68：线程有哪些状态？"></a>Q68：线程有哪些状态？</h2><p>答：①NEW：初始状态，线程被构建，但还没有调用start()方法。②RUNNABLE：运行状态，Java线程将操作系统中的就绪和运行两种状态统称为运行中。③BLOCKED：阻塞状态，表示线程阻塞于锁。④WAITING：等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）。⑤TIME_WAITING：超时等待状态，该状态不同于WAITING，可以在指定时间内自行返回。⑥TERMINATED：终止状态，表示当前线程已经执行完毕。</p>
<h2 id="Q69：什么是daemon线程？"><a href="#Q69：什么是daemon线程？" class="headerlink" title="Q69：什么是daemon线程？"></a>Q69：什么是daemon线程？</h2><p>答：daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作，这意味着当一个Java虚拟机中不存在非daemon线程的时候，Java虚拟机将会退出，可以通过Thread.setDaemon(true)将线程设置为daemon线程（需要在线程启动之前设置）。daemon线程被用于完成支持性工作，但是在JVM退出时daemon线程中的finally块并不一定会被执行，因为当JVM中已经没有非daemon线程时JVM需要立即退出，所有daemon线程都需要立即终止。因此不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。</p>
<h2 id="Q70：线程的中断是什么？"><a href="#Q70：线程的中断是什么？" class="headerlink" title="Q70：线程的中断是什么？"></a>Q70：线程的中断是什么？</h2><p>答：中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。其他线程通过调用该线程的interrupt()方法对其进行中断操作。线程通过检查自身是否被中断来进行响应，线程通过方法isInterrupted()来判断是否被中断，也可以调用静态方法Thread.interrupted()对当前线程的中断标识位进行复位。如果该线程处于终结状态，即使该线程被中毒过，在调用该对象的isInterrupted()时依然返回false。许多声明抛出InterruptedException的方法（例如Thread.sleep(long mills))在抛出异常之前，JVM会将该线程的中断标识位清除，然后再抛出异常，此时调用isInterrupted()时将会返回false。</p>
<h2 id="Q71：为什么suspend、resume、stop方法被废弃了？"><a href="#Q71：为什么suspend、resume、stop方法被废弃了？" class="headerlink" title="Q71：为什么suspend、resume、stop方法被废弃了？"></a>Q71：为什么suspend、resume、stop方法被废弃了？</h2><p>答：以suspend方法为例，在调用后线程不会释放已经占有的资源（比如锁），而是占着资源进入睡眠状态，这样容易引发死锁问题。同样，stop方法在终结一个线程时不会保证线程的资源正常释放，通常是没有基于线程完成资源释放工作的机会，因此会导致程序可能运行在不确定状态下。因为这些方法的副作用因而被标注为不建议使用的废弃方法，而暂停/恢复机制可以用等待/唤醒机制代替。</p>
<h2 id="Q72：可见性问题的原因？"><a href="#Q72：可见性问题的原因？" class="headerlink" title="Q72：可见性问题的原因？"></a>Q72：可见性问题的原因？</h2><p>答：Java支持多线程同时访问一个对象或者对象的成员变量，由于每个线程可以拥有这个变量的拷贝（虽然对象以及成员变量分配的内存是在共享内存中的，但是每个执行的线程还是可以拥有一份拷贝，这样做的目的是加速程序的执行，这是现代多核处理器的一个显著特性），所以程序在执行过程中一个线程看到的变量并不一定是最新的。</p>
<h2 id="Q73：volatile和synchronized是如何解决可见性问题的？"><a href="#Q73：volatile和synchronized是如何解决可见性问题的？" class="headerlink" title="Q73：volatile和synchronized是如何解决可见性问题的？"></a>Q73：volatile和synchronized是如何解决可见性问题的？</h2><p>答：volatile可以用来修饰成员变量，就是告知程序任何对该变量的访问均需从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。synchronized可以修饰方法或者以同步代码块的形式进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法和同步代码块中，它保证了线程对变量访问的可见性和排他性。</p>
<h2 id="Q74：监视器是什么，有什么作用？"><a href="#Q74：监视器是什么，有什么作用？" class="headerlink" title="Q74：监视器是什么，有什么作用？"></a>Q74：监视器是什么，有什么作用？</h2><p>答：任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而没有获取到监视器（执行该方法）的线程就会被阻塞在同步块和同步方法的入口处，进入同步队列，线程状态变为BLOCKED状态，直到前一个获得了锁的线程释放了锁该阻塞线程才会被唤醒重新尝试获取监视器。</p>
<h2 id="Q75：wait-、notify-和notifyAll-的使用细节？"><a href="#Q75：wait-、notify-和notifyAll-的使用细节？" class="headerlink" title="Q75：wait()、notify()和notifyAll()的使用细节？"></a>Q75：wait()、notify()和notifyAll()的使用细节？</h2><p>答：①使用wait()、notify()和notifyAll()时需要先对调用对象加锁。②调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列。③notify()和notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()和notifyAll()的线程释放锁后，等待线程才有机会从wait()返回。④notify()方法将等待队列的一个等待线程从等待队列移到同步队列中，而notifyAll()方法将等待队列中的全部线程移到同步队列，被移动的线程状态由WAITING变为BLOCKED。⑤从wait()方法返回的前提是获得了调用对象的锁。</p>
<h2 id="Q76：管道IO流的作用？"><a href="#Q76：管道IO流的作用？" class="headerlink" title="Q76：管道IO流的作用？"></a>Q76：管道IO流的作用？</h2><p>答：管道IO流和普通IO流或网络IO流的不同之处在于它主要用于线程之间的数据传输，而传输的媒介为内存。管道IO流主要包括4种具体实现：PipedOutputStream、PipedInputStream、PipedWriter、PipedReader，前两种面向字节，后两种面向字符。</p>
<h2 id="Q77：join方法的作用？"><a href="#Q77：join方法的作用？" class="headerlink" title="Q77：join方法的作用？"></a>Q77：join方法的作用？</h2><p>答：join方法使当前线程必须等待调用join方法的线程执行完毕后才能继续执行，除了无参join方法外还有带超时参数的join方法，在指定时间内没有结束就会从该方法返回。底层是通过wait和notifyAll方法实现的，当调用join的线程终止时会调用自身notifyAll方法通知所有等待在该线程对象上的线程。</p>
<h2 id="Q78：ThreadLocal的作用？"><a href="#Q78：ThreadLocal的作用？" class="headerlink" title="Q78：ThreadLocal的作用？"></a>Q78：ThreadLocal的作用？</h2><p>答：ThreadLocal即线程变量，是一个以ThreadLocal对象为键，任意对象为值得存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。可以通过set方法设置一个值，在当线程下再通过get方法获取到原先设置的值。</p>
<h2 id="Q79：为什么要使用线程池？"><a href="#Q79：为什么要使用线程池？" class="headerlink" title="Q79：为什么要使用线程池？"></a>Q79：为什么要使用线程池？</h2><p>答：对于服务端的程序经常面对的是客户端传入的短小（执行时间短、工作内容较为单一）任务，需要服务端快速处理并返回结果。如果服务端每接收到一个任务就创建一个线程然后进行执行，这在原型阶段是个不错的选择但是面对成千上万的任务递交服务器时如果还是采用该方式那么将会创建数以万计的线程，使操作系统频繁进行线程上下文切换，无故增加系统负载，而线程的创建和消亡都是需要耗费系统资源的。线程池技术可以很好地解决该问题，它预先创建了若干数量的线程，并且不能由用户直接对线程的创建进行控制，在这个前提下重复使用固定或较为固定数目的线程来完成任务的执行。这样做一方面消除了频繁创建和消亡消除的系统资源开销，另一方面，面对过量任务的提交能够平缓地处理。</p>
<h2 id="Q80：Lock锁和synchronized的区别？"><a href="#Q80：Lock锁和synchronized的区别？" class="headerlink" title="Q80：Lock锁和synchronized的区别？"></a>Q80：Lock锁和synchronized的区别？</h2><p>答：在JDK1.5之后，并发包中新增了Lock接口以及相关实现类用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。虽然它缺少了隐式获取锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字不具备的同步特性。使用synchronized关键字将会隐式地获取锁，但是它将锁的获取和释放固化了，也就是先获取再释放，简化了同步的管理，但是扩展性没有显式锁好。</p>
<h2 id="Q81：Lock接口提供的synchronized关键字不具备的主要特性？"><a href="#Q81：Lock接口提供的synchronized关键字不具备的主要特性？" class="headerlink" title="Q81：Lock接口提供的synchronized关键字不具备的主要特性？"></a>Q81：Lock接口提供的synchronized关键字不具备的主要特性？</h2><p>答：①Lock可以尝试非阻塞地获取锁，当前线程尝试获取锁，如果这一时刻没有被其他线程获取到则成功获取并持有锁。②能被中断地获取锁，与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放。③超时获取锁，在指定的截至时间之前获取锁，如果截止时间到了仍旧无法获取锁则返回。</p>
<h2 id="Q82：AQS是什么？"><a href="#Q82：AQS是什么？" class="headerlink" title="Q82：AQS是什么？"></a>Q82：AQS是什么？</h2><p>答：AQS是抽象队列同步器Abstract Queued Synchronizer，是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作，并发包的作者期望它成为实现大部分同步需求的基础。</p>
<h2 id="Q83：AQS的主要实现方式是什么？"><a href="#Q83：AQS的主要实现方式是什么？" class="headerlink" title="Q83：AQS的主要实现方式是什么？"></a>Q83：AQS的主要实现方式是什么？</h2><p>答：同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3个方法（getState、setState和compareAndSetState）来进行操作，因为它们能够保证状态的改变是安全的。子类推荐被定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型地同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLacth等）。</p>
<h2 id="Q84：同步器和锁的联系？"><a href="#Q84：同步器和锁的联系？" class="headerlink" title="Q84：同步器和锁的联系？"></a>Q84：同步器和锁的联系？</h2><p>答：同步器是实现锁的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器面对的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所关注的领域。</p>
<h2 id="Q85：AQS的实现包括哪些方面？"><a href="#Q85：AQS的实现包括哪些方面？" class="headerlink" title="Q85：AQS的实现包括哪些方面？"></a>Q85：AQS的实现包括哪些方面？</h2><p>答：队列同步器的从实现角度分为多方面，主要包括同步队列、独占式同步状态的获取与释放、共享式同步状态的获取与释放，以及超时获取同步状态等同步器的核心数据与模板方法。</p>
<h2 id="Q86：同步队列的原理？"><a href="#Q86：同步队列的原理？" class="headerlink" title="Q86：同步队列的原理？"></a>Q86：同步队列的原理？</h2><p>答：同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等构造成一个节点并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。</p>
<h2 id="Q87：同步队列的节点保存哪些信息？"><a href="#Q87：同步队列的节点保存哪些信息？" class="headerlink" title="Q87：同步队列的节点保存哪些信息？"></a>Q87：同步队列的节点保存哪些信息？</h2><p>答：同步队列中的节点用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点。节点是构成同步队列的基础，同步器拥有首节点和尾节点，没有成功获取同步状态的线程将会成为节点加入该队列的尾部。</p>
<h2 id="Q88：同步队列节点的等待状态有哪些类型？"><a href="#Q88：同步队列节点的等待状态有哪些类型？" class="headerlink" title="Q88：同步队列节点的等待状态有哪些类型？"></a>Q88：同步队列节点的等待状态有哪些类型？</h2><p>答：①CANCELLED，值为1，由于在同步队列中等待的线程等待超时或者被中断需要从同步队列中取消等待，节点进入该状态将不会变化。②SIGNAL，值为-1，后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行。③CONDITION，值为-2，节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal方法后该节点将会从等待队列转移到同步队列中，加入到对同步状态的获取中。④PROPAGATE，值为-3，表示下一次共享式同步状态获取将会无条件地被传播下去。⑤INITIAL，值为0，初始状态。</p>
<h2 id="Q89：独占式同步状态的获取和释放流程？"><a href="#Q89：独占式同步状态的获取和释放流程？" class="headerlink" title="Q89：独占式同步状态的获取和释放流程？"></a>Q89：独占式同步状态的获取和释放流程？</h2><p>答：在获取同步状态时，同步器调用acquire方法，维护一个同步队列，使用tryAcquire方法安全地获取线程同步状态，获取状态失败的线程会构造同步节点并通过addWaiter方法被加入到同步队列的尾部，并在队列中进行自旋。之后会调用acquireQueued方法使得该节点以死循环的方式获取同步状态，如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞节点被中断实现，移出队列或停止自旋的条件是前驱节点是头结点并且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease方法释放同步状态，然后调用unparkSuccessor方法（该方法使用LockSupport唤醒处于等待状态的线程）唤醒头节点的后继节点，进而使后继节点重新尝试获取同步状态。</p>
<h2 id="Q90：为什么只有当前驱节点是头节点时才能够尝试获取同步状态？"><a href="#Q90：为什么只有当前驱节点是头节点时才能够尝试获取同步状态？" class="headerlink" title="Q90：为什么只有当前驱节点是头节点时才能够尝试获取同步状态？"></a>Q90：为什么只有当前驱节点是头节点时才能够尝试获取同步状态？</h2><p>答：①头节点是成功获取到同步状态的节点，而头节点的线程释放同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。②维护同步队列的FIFO原则，节点和节点在循环检查的过程中基本不相互通信，而是简单地判断自己的前驱是否为头节点，这样就使得节点的释放规则符合FIFO，并且也便于对过早通知的处理（过早通知是指前驱节点不是头结点的线程由于中断而被唤醒）。</p>
<h2 id="Q91：共享式同步状态的获取和释放流程？"><a href="#Q91：共享式同步状态的获取和释放流程？" class="headerlink" title="Q91：共享式同步状态的获取和释放流程？"></a>Q91：共享式同步状态的获取和释放流程？</h2><p>答：在获取同步状态时，同步器调用acquireShared方法，该方法调用tryAcquireShared方法尝试获取同步状态，返回值为int类型，当返回值大于等于0时，表示能够获取到同步状态。因此在共享式获取锁的自旋过程中，成功获取到同步状态并退出自旋的条件就是该方法的返回值大于等于0。释放同步状态时，调用releaseShared方法，释放同步状态之后将会唤醒后续处于等待状态的节点。对于能够支持多线程同时访问的并发组件，它和独占式的主要区别在于tryReleaseShared方法必须确保同步状态（或资源数）线程安全释放，一般通过循环和CAS来保证，因为释放同步状态的操作会同时来自多个线程。</p>
<h2 id="Q92：独占式超时获取同步状态的流程？"><a href="#Q92：独占式超时获取同步状态的流程？" class="headerlink" title="Q92：独占式超时获取同步状态的流程？"></a>Q92：独占式超时获取同步状态的流程？</h2><p>答：通过调用同步器的doAcquireNanos方法可以超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则返回false。该方法提供了传统Java同步操作（例如synchronized关键字）所不具备的特性。</p>
<h2 id="Q93：响应中断的同步状态获取过程？"><a href="#Q93：响应中断的同步状态获取过程？" class="headerlink" title="Q93：响应中断的同步状态获取过程？"></a>Q93：响应中断的同步状态获取过程？</h2><p>答：在JDK1.5之前当一个线程获取不到锁而被阻塞到synchronized之外时，对该线程进行中断操作，此时该线程的中断标志位会被修改，但线程依旧阻塞在synchronized上等待着获取锁。在JDK1.5中，同步器提供了acquireInterruptibly方法，这个方法在等待获取同步状态时，如果当前线程被中断，会立即返回并抛出InterruptedException。</p>
<h2 id="Q94：独占式超时获取同步状态的原理？"><a href="#Q94：独占式超时获取同步状态的原理？" class="headerlink" title="Q94：独占式超时获取同步状态的原理？"></a>Q94：独占式超时获取同步状态的原理？</h2><p>答：超时获取同步状态的过程可以被视为响应中断获取同步状态过程的“增强版”，doAcquireNanos方法在支持响应中断的基础上增加了超时获取的特性，针对超时获取，主要需要计算出需要睡眠的时间间隔nanosTimeout，为了防止过早通知，nanosTimeout的计算公式为nanosTimeout-=now-lastTime，其中now为当前唤醒时间，lastTime为上次唤醒时间，如果nanosTimeout大于0则表示超时时间未到，需要继续睡眠nanosTimeout纳秒，否则表示已经超时。</p>
<h2 id="Q95：独占式超时获取同步状态和独占式获取同步状态的区别？"><a href="#Q95：独占式超时获取同步状态和独占式获取同步状态的区别？" class="headerlink" title="Q95：独占式超时获取同步状态和独占式获取同步状态的区别？"></a>Q95：独占式超时获取同步状态和独占式获取同步状态的区别？</h2><p>答：在独占式超时获取同步状态的过程的doAcquireNanos中，当节点的前驱节点为头节点时尝试获取同步状态，如果获取成功则从该方法返回，这个过程和独占式同步获取的过程类似，但是在同步状态获取失败的处理上有所不同。如果当前线程获取同步状态失败，独占式超时获取同步状态中会判断是否超时，如果没有超时就重新计算超时间隔，然后使当前线程等待该间隔时间，如果在该时间内没有获取到同步状态就会从等待逻辑中自动返回。而独占式获取同步状态的过程中如果没有获取到同步状态就会使当前线程一直处于等待状态。</p>
<h2 id="Q96：超时时间过小时对超时等待有哪些影响？"><a href="#Q96：超时时间过小时对超时等待有哪些影响？" class="headerlink" title="Q96：超时时间过小时对超时等待有哪些影响？"></a>Q96：超时时间过小时对超时等待有哪些影响？</h2><p>答：nanosTimeout过小时（小于等于1000纳秒），将不会使线程进行超时等待，而是进入快速自旋过程。因为非常短的超市等待无法做到精确，如果这时再进行超时等待相反会让nanosTimeout的超时从整体上表现得反而不精确，因此在超市非常短的情况下同步器会进入无条件的快速自旋。</p>
<h2 id="Q97：什么是可重入锁？"><a href="#Q97：什么是可重入锁？" class="headerlink" title="Q97：什么是可重入锁？"></a>Q97：什么是可重入锁？</h2><p>答：重入锁就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁，除此之外该锁还支持获取锁的公平和非公平性选择。synchronized关键字隐式地支持重进入，ReentrantLock虽然不能像synchronized关键字一样支持隐式的重进入，但是在调用lock方法时已经获取到锁的线程能够再次调用lock方法获取锁而不被阻塞。</p>
<h2 id="Q98：什么是锁的公平性？"><a href="#Q98：什么是锁的公平性？" class="headerlink" title="Q98：什么是锁的公平性？"></a>Q98：什么是锁的公平性？</h2><p>答：如果在绝对时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平的，反正就是不公平的。公平的获取锁也就是等待时间最长的线程优先获取锁，也可以说锁的获取是顺序的，ReentrantLock的构造方法中可以通过设置参数控制锁的公平性。公平锁机制往往没有非公平锁的效率高，非公平锁地吞吐量更大，但是公平锁能够减少饥饿发生的概率，保证了锁地获取按照FIFO顺序，等待越久的请求越是能优先得到满足。</p>
<h2 id="Q99：什么是重进入？"><a href="#Q99：什么是重进入？" class="headerlink" title="Q99：什么是重进入？"></a>Q99：什么是重进入？</h2><p>答：重进入指的是任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的实现需要解决两个问题：①线程再次获取锁，锁需要去识别获取锁的线程是否为当前占有锁的线程，如果是则再次获取成功。②锁的最终释放，线程重复n次获取了锁，随后在第n次释放该锁后，其他现场能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而被锁释放时，技术自减，当计数为0时表示锁已经成功释放。</p>
<h2 id="Q100：ReentrantLock的可重入如何实现？"><a href="#Q100：ReentrantLock的可重入如何实现？" class="headerlink" title="Q100：ReentrantLock的可重入如何实现？"></a>Q100：ReentrantLock的可重入如何实现？</h2><p>答：以非公平锁为例，通过nonfairTryAcquire方法获取锁，该方法增加了再次获取同步状态的处理逻辑：通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求则将同步状态值进行增加并返回true，表示获取同步状态成功。成功获取锁的线程再次获取锁，只是增加了同步状态值，这就要求ReentrantLock在释放同步状态时减少同步状态值。如果该锁被获取了n次，那么前（n-1）次tryRelease方法必须都返回fasle，只有同步状态完全释放了才能返回true，可以看到该方法将同步状态是否为0作为最终释放的条件，当同步状态为0时，将占有线程设置为null，并返回true，表示释放成功。</p>
<h2 id="Q101：ReentrantLock的可重入的公平锁如何实现？"><a href="#Q101：ReentrantLock的可重入的公平锁如何实现？" class="headerlink" title="Q101：ReentrantLock的可重入的公平锁如何实现？"></a>Q101：ReentrantLock的可重入的公平锁如何实现？</h2><p>答：对于非公平锁只要CAS设置同步状态成功则表示当前线程获取了锁，而公平锁则不同。公平锁使用tryAcquire方法，该方法与nonfairTryAcquire的唯一区别就是判断条件中多了对同步队列中当前节点是否有前驱节点的判断，如果该方法返回true表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。</p>
<h2 id="Q102：什么是读写锁？"><a href="#Q102：什么是读写锁？" class="headerlink" title="Q102：什么是读写锁？"></a>Q102：什么是读写锁？</h2><p>答：像Mutex和ReentrantLock都是排他锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读写锁使得并发性相比一般的排他锁有了很大提升。</p>
<h2 id="Q103：读写锁的特点？"><a href="#Q103：读写锁的特点？" class="headerlink" title="Q103：读写锁的特点？"></a>Q103：读写锁的特点？</h2><p>答：除了保证写操作对读操作的可见性以及并发性的提升之外，读写锁能够简化读写交互场景的编程方式。只需要在读操作时获取读锁，写操作时获取写锁即可，当写锁被获取时后续（非当前写操作线程）的读写操作都会被阻塞，写锁释放之后所有操作继续执行，编程方式相对于使用等待/通知机制的实现方式而言变得简单明了。</p>
<h2 id="Q104：读写锁ReentrantReadWriteLock的特性？"><a href="#Q104：读写锁ReentrantReadWriteLock的特性？" class="headerlink" title="Q104：读写锁ReentrantReadWriteLock的特性？"></a>Q104：读写锁ReentrantReadWriteLock的特性？</h2><p>答：①公平性选择：支持非公平（默认）和公平的锁获取方式吞吐量还是非公平性优于公平。②重进入：该锁支持重进入，以读写线程为例：读线程在获取了读锁之后能够再次获得读锁。而写线程在获取了写锁之后能再次获得写锁，同时也可以获取读锁。③锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级为读锁。</p>
<h2 id="Q105：读写锁的状态是怎么设计的？"><a href="#Q105：读写锁的状态是怎么设计的？" class="headerlink" title="Q105：读写锁的状态是怎么设计的？"></a>Q105：读写锁的状态是怎么设计的？</h2><p>答：读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。读写锁的自定义同步器需要在同步状态（一个整形变量）上维护多个读线程和一个写线程的状态。如果在一个int型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写。假设同步状态值为S，写状态等于S&amp;0x0000FFFF（将高17位全部抹去），读状态等于S&gt;&gt;&gt;16（无符号右移16位），当写状态增加1时，等于S+1，当读状态增加1时，等于S+（1&lt;&lt;16）。根据状态的划分能得出一个推论：S不等于0时，当写状态等于0时，则读状态大于0，即读锁已被获取。</p>
<h2 id="Q106：写锁的获取和释放过程？"><a href="#Q106：写锁的获取和释放过程？" class="headerlink" title="Q106：写锁的获取和释放过程？"></a>Q106：写锁的获取和释放过程？</h2><p>答：写锁是一个支持重进入的排他锁，如果当前线程已经获得了写锁则增加写状态，如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获得写锁的线程则当前线程进入等待状态。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对后续读写线程可见。</p>
<h2 id="Q107：为什么存在读锁时写锁会阻塞？"><a href="#Q107：为什么存在读锁时写锁会阻塞？" class="headerlink" title="Q107：为什么存在读锁时写锁会阻塞？"></a>Q107：为什么存在读锁时写锁会阻塞？</h2><p>答：读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取则其他读写线程的后续访问均被阻塞。</p>
<h2 id="Q108：读锁的获取和释放过程？"><a href="#Q108：读锁的获取和释放过程？" class="headerlink" title="Q108：读锁的获取和释放过程？"></a>Q108：读锁的获取和释放过程？</h2><p>答：读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问（或者写线程为0）时，读锁总会被成功地获取，而所做的只是线程安全地增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取则进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放均会减少读状态，减少的值是（1&lt;&lt;16），读锁的每次释放是线程安全的，可能有多个读线程同时释放读锁。</p>
<h2 id="Q109：JDK1-6对读锁有什么改动？"><a href="#Q109：JDK1-6对读锁有什么改动？" class="headerlink" title="Q109：JDK1.6对读锁有什么改动？"></a>Q109：JDK1.6对读锁有什么改动？</h2><p>答：获取读锁的实现从JDK1.5到JDK1.6变得复杂许多，主要原因是新增了一些功能，例如getReadHoldCount方法，作用是返回当前线程获取读锁的次数。读状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在ThreadLocal中，由线程自身维护，这使获取读锁的实现变得复杂。</p>
<h2 id="Q110：锁降级是什么？"><a href="#Q110：锁降级是什么？" class="headerlink" title="Q110：锁降级是什么？"></a>Q110：锁降级是什么？</h2><p>答：锁降级指的是写锁降级成为读锁，如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级指的是把持住（当前拥有的）写锁，再获取到读锁，随后释放先前拥有的写锁的过程。</p>
<h2 id="Q111：锁降级中读锁的获取是否有必要？"><a href="#Q111：锁降级中读锁的获取是否有必要？" class="headerlink" title="Q111：锁降级中读锁的获取是否有必要？"></a>Q111：锁降级中读锁的获取是否有必要？</h2><p>答：是必要的，主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程A获取了写锁修改了数据，那么当前线程是无法感知线程A的数据更新的。如果当前线程获取读锁，即遵循锁降级的步骤，线程A将会被阻塞，直到当前线程使用数据并释放读锁之后，线程A才能获取写锁并进行数据更新。</p>
<h2 id="Q112：LockSupport是什么？"><a href="#Q112：LockSupport是什么？" class="headerlink" title="Q112：LockSupport是什么？"></a>Q112：LockSupport是什么？</h2><p>答：当需要阻塞或唤醒一个线程的时候，都会使用LockSupport工具类完成相应工作，LockSupport定义了一组公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能，而LockSupport也成为构建同步组件的基础工具。LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark方法来唤醒一个被阻塞的线程。在JDK1.6中，新增了3个含义阻塞对象的park方法，用以替代原有的park方法。</p>
<h2 id="Q113：Condition的作用？"><a href="#Q113：Condition的作用？" class="headerlink" title="Q113：Condition的作用？"></a>Q113：Condition的作用？</h2><p>答：Condition接口提供了类似Object监视器方法，与Lock配合可以实现等待/通知模式。Condition对象是由Lock对象创建出来的，因此Condition是依赖Lock对象的。一般会将Condition对象作为成员变量，当调用await方法后当前线程会释放锁并在此等待，而其他线程调用Condition对象的signal方法，通知当前线程后，当前线程才从await方法返回并且在返回前已经获取了锁。</p>
<h2 id="Q114：Condition是怎么实现的？"><a href="#Q114：Condition是怎么实现的？" class="headerlink" title="Q114：Condition是怎么实现的？"></a>Q114：Condition是怎么实现的？</h2><p>答：ConditionObject是同步器AQS的内部类，因为Condition的操作需要获取相关的锁，所以作为同步器的内部类也较为合理。每个Condition对象都包含着一个等待队列，该等待队列是Condition对象实现等待/通知功能的关键。Condition的实现主要包括了等待队列、等待和通知。</p>
<h2 id="Q115：等待队列的原理？"><a href="#Q115：等待队列的原理？" class="headerlink" title="Q115：等待队列的原理？"></a>Q115：等待队列的原理？</h2><p>答：等待队列是一个FIFO队列，在队列中的每个节点都包含了一个线程引用，该线程就是在ConditionObject对象上等待的线程，如果一个线程调用了await方法，那么该线程会释放锁、构造成节点加入等待队列并进入等待状态。事实上，节点的定义复用了同步其中节点的定义，也就是说同步队列和等待队列中的节点类型都是同步器的静态内部类Node。一个ConditionObject包含一个等待队列，ConditionObject拥有首节点和尾节点。Object拥有首尾节点的引用，而新增节点只需要将原有的尾节点nextWaiter指向它，并且更新尾节点即可。节点引用更新的过程并没有用CAS保证，因为调用await方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。</p>
<h2 id="Q116：await方法的原理？"><a href="#Q116：await方法的原理？" class="headerlink" title="Q116：await方法的原理？"></a>Q116：await方法的原理？</h2><p>答：如果从队列的角度看await方法，当调用await方法时相当于同步队列的首节点（获取了锁的节点）移动到Condition对象的等待队列中，首节点不会直接加入等待队列，而是通过addConditionWaiter方法把当前线程构造成一个新的节点并将其加入等待队列中。加入等待队列后，释放同步状态，唤醒同步队列中的后继节点然后进入等待状态。如果不是通过其他线程调用signal方法唤醒而是对await线程进行中断，会抛出InterruptedException。</p>
<h2 id="Q117：signal方法的原理？"><a href="#Q117：signal方法的原理？" class="headerlink" title="Q117：signal方法的原理？"></a>Q117：signal方法的原理？</h2><p>答：该方法会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将节点移到同步队列中。调用该方法的前置条件是当前线程必须获取了锁，signal方法进行了检查，判断当前线程是否是获取了锁的线程，接着获取等待队列的首节点，将其移动到同步队列并使用LockSupport唤醒节点中的线程。被唤醒后的线程将从await方法中的while循环退出，进而调用同步器的acquireQueued方法加入到获取同步状态的竞争中。成功获取同步状态（或者说锁）后，被唤醒的线程将从先前调用的await方法返回，此时该线程已成功获取了锁。signalAll方法相当于对等待队列中的每个节点执行一次signal方法，效果就是将等待队列中的节点全部移到到同步队列中并唤醒每个节点的线程。</p>
<h2 id="Q118：什么是阻塞队列？"><a href="#Q118：什么是阻塞队列？" class="headerlink" title="Q118：什么是阻塞队列？"></a>Q118：什么是阻塞队列？</h2><p>答：阻塞队列是一个支持两个附加操作的队列，这两个附加的操作支持阻塞的插入和移除方法。当队列满时，队列会阻塞插入元素的线程，直到队列不满。当队列为空时，获取元素的线程会等待队列变为非空。阻塞队列常用于生产者和消费者的场景，生产者向队列里添加元素，消费者从队列中获取元素，阻塞队列就是生产者用来存放元素，消费者用来获取元素的容器。</p>
<h2 id="Q119：Java中有哪些阻塞队列？"><a href="#Q119：Java中有哪些阻塞队列？" class="headerlink" title="Q119：Java中有哪些阻塞队列？"></a>Q119：Java中有哪些阻塞队列？</h2><p>答：①ArrayBlockingQueue，一个由数组结构组成的有界阻塞队列，按照FIFO的原则对元素排序，默认情况下不保证线程公平地访问队列，有可能先阻塞地线程最后才访问队列。②LinkedBlockingQueue，一个由链表结构组成的有界阻塞队列，队列的默认和最大长度为Integer的最大值，按照FIFO原则排序。③PriorityBlockingQueue，一个支持优先级排序的无界阻塞队列，默认情况下元素按照顺序升序排序。也可以自定义compareTo方法指定元素排序规则，或者初始化时指定构造方法的参数Comparator对元素排序，不能保证同优先级元素的顺序。④DelayQueue，一个支持延时获取元素的无界阻塞队列，使用优先级队列实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素，只有延时期满时才能从队列中获取元素。适用于以下场景：①缓存系统的设计，一旦能从延迟队列获取元素说明缓存有效期到了。②定时任务调度，保存当天将要执行的任务和执行时间，一旦获取到任务就立刻开始执行。⑤SynchronousQueue，一个不存储元素的阻塞队列，每一个put操作必须等待一个take操作，否则不能继续添加元素。默认使用非公平策略，也支持公平策略，适用于传递性场景，吞吐量高于ArrayBlockingQueue和LinkedBlockingQueue。⑥LinkedTransferQueue，一个由链表结构组成的无界阻塞队列，相对于其他阻塞队列多了tryTransfer和transfer方法。transfe方法：如果当前有消费者正在等待接收元素，transfer方法可以把生产者传入的元素立刻传输给消费者，如果没有，会将元素放在队列的尾节点等到该元素被消费者消费了才返回。tryTransfer方法：用来试探生产者传入的元素能否直接传给消费者，如果没有消费者等待接收元素返回false，和transfer的区别时无论消费者是否接受都会立即返回，transfer是等到消费者消费了才返回。⑦LinkedBlockingDeque，一个由链表结构组成的双向阻塞队列，可以从队列的两端插入和移除元素，多了一个操作队列的入口，在多线程同时入队时就少了一半竞争。</p>
<h2 id="Q120：阻塞队列的实现原理？"><a href="#Q120：阻塞队列的实现原理？" class="headerlink" title="Q120：阻塞队列的实现原理？"></a>Q120：阻塞队列的实现原理？</h2><p>答：使用通知模式实现，所谓通知模式就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。JDK中使用了Condition条件对象来实现。当往队列里插入一个元素，如果队列不可用，那么阻塞生产者主要通过LockSupport.park(this)实现。</p>
<h2 id="Q121：原子操作类是什么？"><a href="#Q121：原子操作类是什么？" class="headerlink" title="Q121：原子操作类是什么？"></a>Q121：原子操作类是什么？</h2><p>答：JDK1.5开始提供了atomic包，这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。主要包括4类，原子更新基本类型、原子更新数组、原子更新引用类型和原子更新属性。在原子更新属性类中有支持带有版本号的更新方法，可用于解决CAS操作时出现的ABA问题。</p>
<h2 id="Q122：CountDownLatch的作用？"><a href="#Q122：CountDownLatch的作用？" class="headerlink" title="Q122：CountDownLatch的作用？"></a>Q122：CountDownLatch的作用？</h2><p>答：允许一个或多个线程等待其他线程完成操作，构造方法接收一个int类型的参数作为计数器，如果要等待n个点就传入n。每次调用countDown方法时n就会减1，await方法会阻塞当前线程直到n变为0，由于countDown方法可用在任何地方，所以n个点既可以是n个线程也可以是1个线程里的n个执行步骤。用在多线程时，只需要把这个CountDownLatch的引用传递到线程里即可。</p>
<h2 id="Q123：CyclicBarrier的作用？"><a href="#Q123：CyclicBarrier的作用？" class="headerlink" title="Q123：CyclicBarrier的作用？"></a>Q123：CyclicBarrier的作用？</h2><p>答：CyclicBarrier是同步屏障，它的作用是让一组线程到达一个屏障（或同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被拦截的线程才会继续运行。构造方法中的参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier自己已到达屏障，然后当前线程被阻塞。还支持在构造方法中传入一个Runable类型的任务，当线程到达屏障时会优先执行该任务。适用于多线程计算数据，最后合并计算结果的应用场景。</p>
<h2 id="Q124：CountDownLacth和CyclicBarrier的区别？"><a href="#Q124：CountDownLacth和CyclicBarrier的区别？" class="headerlink" title="Q124：CountDownLacth和CyclicBarrier的区别？"></a>Q124：CountDownLacth和CyclicBarrier的区别？</h2><p>答：CountDownLacth的计数器只能用一次，而CyclicBarrier的计数器可使用reset方法重置，所以CyclicBarrier能处理更为复杂的业务场景，例如计算错误时可用重置计数器重新计算。CyclicBarrier还提供了其他有用的方法，例如getNumberWaiting可以获取CyclicBarrier阻塞的线程数量，isBroken方法用来了解阻塞的线程是否被中断。</p>
<h2 id="Q125：Semaphore的作用？"><a href="#Q125：Semaphore的作用？" class="headerlink" title="Q125：Semaphore的作用？"></a>Q125：Semaphore的作用？</h2><p>答：Semaphore是信号量，用来控制同时访问特定资源的线程数量，它通过协调各个线程以保证合理的使用公共资源。信号量可以用于流量控制，特别是公共资源有限的应用场景，比如数据库连接。Semaphore的构造方法参数接收一个int型数字，表示可用的许可证数量，即最大并发数。使用acquire获得一个许可证，使用release方法归还许可证，还可以用tryAcquire尝试获得许可证。</p>
<h2 id="Q126：Exchanger的作用？"><a href="#Q126：Exchanger的作用？" class="headerlink" title="Q126：Exchanger的作用？"></a>Q126：Exchanger的作用？</h2><p>答：Exchanger交换者是用于线程间协作的工具类，用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange方法它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时这两个线程就可以交换数据，将本线程生产出的数据传递给对方。应用场景包括遗传算法、校对工作等。</p>
<h2 id="Q127：线程池有哪些好处？"><a href="#Q127：线程池有哪些好处？" class="headerlink" title="Q127：线程池有哪些好处？"></a>Q127：线程池有哪些好处？</h2><p>答：①降低资源消耗，通过重复利用已创建的线程降低线程创建和消耗的开销。②提高响应速度，当任务到达时，任务可以不需要等到线程创建就可以立即执行。③提高线程的可管理性，线程是稀缺资源，如果无限制地创建不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</p>
<h2 id="Q128：线程池的处理流程？"><a href="#Q128：线程池的处理流程？" class="headerlink" title="Q128：线程池的处理流程？"></a>Q128：线程池的处理流程？</h2><p>答：①线程池判断核心线程池是否已满，如果不是则创建一个新的工作线程来执行任务（工作线程数&lt;corePoolSize，这一步需要获取全局锁）。②如何核心线程池已经满了，判断工作队列是否已满，如果没有就将任务存储在工作队列中（工作线程数&gt;=corePoolSize）。③如果工作队列满了，判断线程池是否已满，如果没有就还是创建一个新的工作线程来执行任务（工作线程数&lt;maximumPoolSize）。④如果线程池已满，就按照线程池的拒绝执行策略来处理无法执行的任务（工作线程数&gt;maximumPoolSize）。线程池采取这种设计思路是为了在执行execute方法时尽可能地避免获取全局锁，在线程池完成预热之后，即当前工作线程数&gt;=corePoolSzie时，几乎所有的execute方法都是执行步骤2，不需要获取全局锁。</p>
<h2 id="Q129：工作线程的任务是什么？"><a href="#Q129：工作线程的任务是什么？" class="headerlink" title="Q129：工作线程的任务是什么？"></a>Q129：工作线程的任务是什么？</h2><p>答：线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务之后，还会循环获取工作队列中的任务来执行。线程池中的线程执行任务分为两种情况：①在execute方法中创建一个线程时会让这个线程执行当前任务。②这个线程执行完任务之后，就会反复从阻塞工作队列中获取任务并执行。</p>
<h2 id="Q130：ThreadPoolExecutor创建有哪些参数，具体含义是什么？"><a href="#Q130：ThreadPoolExecutor创建有哪些参数，具体含义是什么？" class="headerlink" title="Q130：ThreadPoolExecutor创建有哪些参数，具体含义是什么？"></a>Q130：ThreadPoolExecutor创建有哪些参数，具体含义是什么？</h2><p>答：①corePoolSize：线程池的基本大小，当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池的基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有的基本线程。②workQueue：工作队列，用于保存等待执行任务的阻塞队列，可以选择以下的阻塞队列：ArrayBlockQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockQueue等。③maximumPoolSize：线程池允许的最大线程数，如果工作队列已满，并且创建的线程数小于最大线程数，则线程池还会创建新的线程执行任务，如果使用的时无界阻塞队列该参数是无意义的。④threadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。⑤handler：拒绝策略，当队列和线程池都满了说明线程池处于饱和状态，那么必须采取一种拒绝策略处理新提交的任务，默认情况下使用AbortPolicy直接抛出异常，CallerRunsPolicy表示重新尝试提交该任务，DiscardOldestPolicy表示抛弃队列里最近的一个任务并执行当前任务，DiscardPolicy表示直接抛弃当前任务不处理。也可以自定义该策略。⑥keepAliveTime：线程活动的保持时间，线程池工作线程空闲后保持存活的时间，所以如果任务很多，且每个任务的执行时间较短，可以调大时间提高线程的利用率。⑦unit：线程活动保持时间的单位，有天、小时、分钟、毫秒、微秒、纳秒。</p>
<h2 id="Q131：如何向线程池提交任务？"><a href="#Q131：如何向线程池提交任务？" class="headerlink" title="Q131：如何向线程池提交任务？"></a>Q131：如何向线程池提交任务？</h2><p>答：可以使用execute和submit方法向线程池提交任务。execute方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功了。submit方法用于提交需要返回值的任务，线程池会返回一个Future类型的对象，通过该对象可以判断任务是否执行成功，并且可以通过该对象的get方法获取返回值，get方法会阻塞当前线程直到任务完成，带超时参数的get方法会在指定时间内返回，这时任务可能还没有完成。</p>
<h2 id="Q132：关闭线程池的原理？"><a href="#Q132：关闭线程池的原理？" class="headerlink" title="Q132：关闭线程池的原理？"></a>Q132：关闭线程池的原理？</h2><p>答：可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池，它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。区别是shutdownNow首先将线程池的状态设为STOP，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设为SHUTDOWN，然后中断所有没有正在执行任务的线程。只要调用了这两个方法中的一个，isShutdown方法就会返回true，当所有任务都已关闭后才表示线程池关闭成功，这时调用isTerminated方法会返回true。通常调用shutdown方法来关闭线程池，如果任务不一定要执行完则可以调用shutdownNow方法。</p>
<h2 id="Q133：如何合理设置线程池？"><a href="#Q133：如何合理设置线程池？" class="headerlink" title="Q133：如何合理设置线程池？"></a>Q133：如何合理设置线程池？</h2><p>答：首先可以从以下角度分析：①任务的性质：CPU密集型任务、IO密集型任务和混合型任务。②任务的优先级：高、中和低。③任务的执行时间：长、中和短。④任务的依赖性：是否以来其他系统资源，如数据库连接。性质不同的任务可以用不同规模的线程池分开处理，CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。混合型任务如果可以拆分将其拆分为一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大那么分解后的吞吐量将高于串行执行的吞吐量，如果相差太大则没必要分解。优先级不同的任务可以使用优先级队列PriorityBlockingQueue处理。执行时间不同的任务可以交给不同规模的线程池处理，或者使用优先级队列。以来数据库连接池的任务，由于线程提交SQL后需要等待数据库返回的结果，等待的时间越长CPU空闲的时间就越长，因此线程数应该尽可能地设置大一些提高CPU的利用率。建议使用有界队列，能增加系统的稳定性和预警能力，可以根据需要设置的稍微大一些。</p>
<h2 id="Q134：线程池如何进行监控？"><a href="#Q134：线程池如何进行监控？" class="headerlink" title="Q134：线程池如何进行监控？"></a>Q134：线程池如何进行监控？</h2><p>答：①taskCount，线程池需要执行的任务数量。②completedTaskCount，线程池在运行过程中已经完成的任务数量，小于或等于taskCount。③largestPoolSize，线程池里曾经创建过的最大线程数量，通过这个数据可以知道线程池是否曾经满过，如果该数值等于线程池的最大大小表示线程池曾经满过。④getPoolSize，获取线程池的线程数量，如果线程池不销毁的化线程池里的线程不会自动销毁，所以这个数值只增不减。⑤getActiveCount，获取活动的线程数。通过扩展线程池进行监控，可以继承线程池来自定义，重写线程池的beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前来执行一些代码进行监控，例如监控任务的平均执行时间、最大执行时间和最小执行时间。</p>
<h2 id="Q135：Executor框架的调度模型是什么？"><a href="#Q135：Executor框架的调度模型是什么？" class="headerlink" title="Q135：Executor框架的调度模型是什么？"></a>Q135：Executor框架的调度模型是什么？</h2><p>答：在HotSpot VM的线程模型中，Java线程被一对一映射为本地操作系统线程，Java线程启动时会创建一个本地操作系统线程，当该Java线程终止时，这个操作系统线程也会被回收，操作系统会调度所有线程并将它们分配给可用的CPU。Executor框架的调度模型是一种两级调度模型。在上层，Java多线程程序通常把应用分解为若干任务，然后使用用户级的调度器即Executor框架将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。</p>
<h2 id="Q136：Executor框架的结构？"><a href="#Q136：Executor框架的结构？" class="headerlink" title="Q136：Executor框架的结构？"></a>Q136：Executor框架的结构？</h2><p>答：主要由以下三部分组成：①任务，包括被执行任务需要实现的接口，Runnable或Callable接口。②任务的执行，包括任务执行机制的核心接口Executor（Executor框架的基础，将任务的提交和执行分离开来），以及继承自Executor的ExecutorService接口（ThreadPoolExecutor和ScheduledThreadPoolExecutor）。③异步计算的结果，包括接口Future和实现Future接口的FutureTask类。当我们把Runnable接口或Callable接口的实现类提交（submit）给ThreadPoolExecutor或ScheduledThreadPoolExecutor时，ThreadPoolExecutor或ScheduledThreadPoolExecutor会向我们返回一个FutureTask对象。</p>
<h2 id="Q137：ThreadPoolExecutor是什么？"><a href="#Q137：ThreadPoolExecutor是什么？" class="headerlink" title="Q137：ThreadPoolExecutor是什么？"></a>Q137：ThreadPoolExecutor是什么？</h2><p>答：ThreadPoolExecutor是Executor框架最核心的类，是线程池的实现类，主要有三种。①FixedThreadPool，可重用固定线程数的线程池，corePoolSize和maximumPoolSize都被设置为创建时的指定参数nThreads，当线程池中的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待新任务的最长时间，超过这个时间后多余的线程将被终止，这里将其设置为0L表示多余空闲线程将被立即终止。该线程池使用的工作队列是无界阻塞队列LinkedBlockingQueue（队列容量为Integer的最大值）。适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，适用于负载比较重的服务器。②SingleThreadExecutor，使用单个线程的线程池，corePoolSize和maximumPoolSize都被设置为1，其他参数和FiexedThreadPool相同。适用于需要保证顺序执行各个任务，并且在任意时间点不会有多个线程是活动的的应用场景。③CachedThreadPool，一个根据需要创建线程的线程池，corePoolSize被设置为0，maximumPoolSize被设置为Integer的最大值，将keepAliveTime设为60L，意味着空闲线程等待时间最长为1分钟。该线程池使用的工作队列是没有容量的SynchronousQueue，但是maximumPoolSize设为Integer最大值，如果主线程提交任务的速度高于线程处理的速度，线程池会不断创建新线程，极端情况下会创建过多线程而耗尽CPU和内存资源。适用于执行很多短期异步任务的小程序，或者负载较轻的服务器。</p>
<h2 id="Q138：ScheduledThreadPoolExecutor是什么？"><a href="#Q138：ScheduledThreadPoolExecutor是什么？" class="headerlink" title="Q138：ScheduledThreadPoolExecutor是什么？"></a>Q138：ScheduledThreadPoolExecutor是什么？</h2><p>答：ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，主要用来在给定的延迟之后运行任务，或者定期执行任务。其功能与Timer类似，但是功能更加强大、更灵活。Timer对应的是单个后台线程，而ScheduledThreadPoolExecutor可以在构造方法中指定多个后台线程数。为了实现周期性的执行任务，使用DelayQueue作为工作队列，获取任务和执行周期任务后的处理都不同，主要有两种。①ScheduledThreadPool：包含若干线程的ScheduledThreadPoolExecutor，创建固定线程个数的线程池。适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程数量的应用场景。②SingleThreadScheduledExecutor：只包含一个线程的ScheduledThreadPoolExecutor，适用于单个后台线程执行周期任务，同时需要保证顺序执行各个任务的应用场景。</p>
<h2 id="Q139：ScheduledThreadPoolExecutor的原理？"><a href="#Q139：ScheduledThreadPoolExecutor的原理？" class="headerlink" title="Q139：ScheduledThreadPoolExecutor的原理？"></a>Q139：ScheduledThreadPoolExecutor的原理？</h2><p>答：将待调度任务放入一个DelayQueue中，调度任务主要有三个参数，long类型的time表示这个任务将要被执行的具体时间，long类型的sequenceNumber表示这个任务被添加到线程池的序号，long类型的period表示任务执行时间间隔。DelayQueue封装了一个PriorityQueue，队列按照time进行排序，如果time相同则比较sequenceNumber，越小的排在前面，即如果两个任务的执行时间相同，先提交的任务先被执行。</p>
<h2 id="Q140：Runnable接口和Callable接口的区别？"><a href="#Q140：Runnable接口和Callable接口的区别？" class="headerlink" title="Q140：Runnable接口和Callable接口的区别？"></a>Q140：Runnable接口和Callable接口的区别？</h2><p>答：两个接口的相同点是Runnable接口和Callable接口的实现类都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行，不同点是Runnable不会返回结果，Callable可以返回结构。除了可以自己创建Callable接口的对象外，还可以使用工厂类Executors将一个Runnable对象包装为一个Callable对象。</p>
<h2 id="Q141：使用无界阻塞队列对线程池的影响？"><a href="#Q141：使用无界阻塞队列对线程池的影响？" class="headerlink" title="Q141：使用无界阻塞队列对线程池的影响？"></a>Q141：使用无界阻塞队列对线程池的影响？</h2><p>答：①当线程池中的线程数达到corePoolSize之后新任务将在无界队列中等待，因此线程池中的数量不会超过corePoolSize。②因此使用无界队列时maximumPoolSize和keepAliveTime均是无效参数。③由于使用无界队列，线程池不会拒绝任务。</p>
<h2 id="Q142：FutureTask有哪些状态？"><a href="#Q142：FutureTask有哪些状态？" class="headerlink" title="Q142：FutureTask有哪些状态？"></a>Q142：FutureTask有哪些状态？</h2><p>答：FutureTask除了实现了Future接口之外，还实现了Runnable接口。因此FutureTask可以交给Executor执行，也可以由调用线程直接执行即调用FutureTask对象的run方法，根据run方法被执行的时机，FutureTask可以处于三种状态：①未启动，当FutureTask对象被创建，且没有执行run方法之前的状态。②已启动，当run方法处于被执行过程中，FutureTask对象处于已启动状态。③已完成，当run方法执行后正常完成或执行run方法中抛出异常或调用cancel方法取消时，FutureTask对象处于已完成状态。当处于未启动或已启动状态时，get方法将阻塞线程，当处于已完成状态时会立即返回结果或抛出异常。当处于未启动状态时，cancel方法会导致此任务永远不会执行，当处于已启动状态时，执行cancel(true)方法，将以中断执行此任务的方式来试图停止该任务，执行cancel(false)方法，将不会对正在执行此任务的线程产生应用，当处于已完成状态时，cancel方法返回false。</p>
<h2 id="Q143：FutureTask的实现原理？"><a href="#Q143：FutureTask的实现原理？" class="headerlink" title="Q143：FutureTask的实现原理？"></a>Q143：FutureTask的实现原理？</h2><p>答：FutureTask的实现基于AQS，基于合成复用的设计原则，FutureTask声明了一个内部私有的继承于AQS的子类Sync，对Future的所有公有方法的调用都会委托给这个内部的子类。AQS被作为模板方法模式的基础类提供给FutureTask的内部子类Sync，这个内部的子类只需要实现状态检查和更新的方法即可，这些方法将控制FutureTask的获取和释放操作。具体来说，Sync实现了AQS的tryAcquireShared和tryReleaseShared方法来检查和更新同步状态。</p>
<h2 id="Q144：基于AQS实现的同步器有什么共同点？"><a href="#Q144：基于AQS实现的同步器有什么共同点？" class="headerlink" title="Q144：基于AQS实现的同步器有什么共同点？"></a>Q144：基于AQS实现的同步器有什么共同点？</h2><p>答：①至少有一个acquire操作，这个操作阻塞调用线程，直到AQS的状态允许这个线程继续执行。FutureTask中的acquire操作为get方法调用。②至少有一个release操作，这个操作改变AQS的状态，改变后的状态可允许一个多多个阻塞线程解除阻塞。FutureTask中的release操作包括run方法和cancel方法。</p>
<h2 id="Q145：FutureTask的get方法原理？"><a href="#Q145：FutureTask的get方法原理？" class="headerlink" title="Q145：FutureTask的get方法原理？"></a>Q145：FutureTask的get方法原理？</h2><p>答：①调用AQS的acquireSharedInterruptibly方法，首先回调在子类Sync中实现的tryAcquireShared方法来判断acquire操作是否可以成功。acquire操作成功的条件为：state为执行完成状态或取消状态，且runner不为null。②如果成功get方法立即返回，如果失败则到线程等待队列中去等待其他线程执行release操作。③当其他线程执行release操作唤醒当前线程后，当前线程再次执行tryAcquireShared将返回1，当前线程将理课线程等待队列并唤醒它的后继线程。④返回最终结果或抛出异常。</p>
<h2 id="Q146：FutureTask的run方法原理？"><a href="#Q146：FutureTask的run方法原理？" class="headerlink" title="Q146：FutureTask的run方法原理？"></a>Q146：FutureTask的run方法原理？</h2><p>答：①执行在构造方法中的指定任务。②以原子方式更新同步状态，如果操作成功就设置代表计算结果的变量result的值为Callable的call方法的返回值，然后调用AQS的releaseShared方法。③AQS的releaseShared方法首先回调子类Sync中实现的tryReleaseShared来执行release操作（设置运行任务的线程runner为null，然后返回true），然后唤醒线程等待队列的第一个线程。④调用FutureTask的done方法。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/52616541/answer/1205244462">https://www.zhihu.com/question/52616541/answer/1205244462</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2021/04/05/Mac%E7%BB%BF%E8%89%B2%E5%AE%89%E8%A3%85redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/05/Mac%E7%BB%BF%E8%89%B2%E5%AE%89%E8%A3%85redis/" class="post-title-link" itemprop="url">Mac绿色安装redis</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-05 00:00:00" itemprop="dateCreated datePublished" datetime="2021-04-05T00:00:00+08:00">2021-04-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:03" itemprop="dateModified" datetime="2022-07-05T22:46:03+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/" itemprop="url" rel="index"><span itemprop="name">开发日常</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="centos7-4绿色安装redis"><a href="#centos7-4绿色安装redis" class="headerlink" title="centos7.4绿色安装redis"></a>centos7.4绿色安装redis</h1><h2 id="下载安装redis服务"><a href="#下载安装redis服务" class="headerlink" title="下载安装redis服务"></a>下载安装redis服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://download.redis.io/releases/redis-6.0.10.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar xzf redis-6.0.10.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> redis-6.0.10</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure>
<p>当make的时候报错，提示<code>make: *** [server.o] 错误 1</code> ，原因是因为当前默认的gcc版本太低，需要手动升级gcc。</p>
<h2 id="升级GCC"><a href="#升级GCC" class="headerlink" title="升级GCC"></a>升级GCC</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum -y install centos-release-scl</span><br><span class="line">yum -y install devtoolset-9-*</span><br><span class="line"><span class="meta">#</span><span class="bash">临时启动gcc9</span></span><br><span class="line">scl enable devtoolset-9 bash</span><br></pre></td></tr></table></figure>
<p>永久使用gcc9</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source /opt/rh/devtoolset-9/enable&quot; &gt;&gt;/etc/profile</span><br></pre></td></tr></table></figure>
<h2 id="redis启动和关闭"><a href="#redis启动和关闭" class="headerlink" title="redis启动和关闭"></a>redis启动和关闭</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> src/redis-server</span></span><br></pre></td></tr></table></figure>
<p>后台启动设置，修改redis.conf，设置<code>daemonize yes</code>，重新启动。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> src/redis-server redis.conf</span></span><br></pre></td></tr></table></figure>
<p>客户端链接</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> src/redis-cli</span></span><br></pre></td></tr></table></figure>
<p>带密码链接</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> src/redis-cli -a password</span></span><br></pre></td></tr></table></figure>

<h2 id="开放6379端口"><a href="#开放6379端口" class="headerlink" title="开放6379端口"></a>开放6379端口</h2><p>查看网络</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --get-active-zones</span><br></pre></td></tr></table></figure>
<p>查看某个端口是否打开</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --query-port=6379/tcp</span><br></pre></td></tr></table></figure>
<p>打开对应的端口</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=6379/tcp --permanent</span><br></pre></td></tr></table></figure>
<p>重启防火墙</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<h2 id="关闭linux7防火墙"><a href="#关闭linux7防火墙" class="headerlink" title="关闭linux7防火墙"></a>关闭linux7防火墙</h2><p>查看防火墙状态</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld.service</span><br></pre></td></tr></table></figure>
<p>暂时关闭防火墙</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure>
<p>永久关闭防火墙</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>
<p>临时开启防火墙</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld.service</span><br></pre></td></tr></table></figure>
<p>永久开启防火墙</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable firewalld.service</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/download">https://redis.io/download</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ToBeExpert/p/10297697.html">https://www.cnblogs.com/ToBeExpert/p/10297697.html</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2021/02/01/TCP%E5%92%8CUDP%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/01/TCP%E5%92%8CUDP%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/" class="post-title-link" itemprop="url">TCP和UDP那些事儿</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-01 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-01T00:00:00+08:00">2021-02-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:03" itemprop="dateModified" datetime="2022-07-05T22:46:03+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">网络技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>学习网络的时候都了解过tcp和udp的一些特点，比如tcp有三次握手四次挥手，tcp消息可靠；udp传递速度快，udp可能丢数据。但是如果在详细一点来说可能就没那么清楚了，在这里我就本着知其然知其所以然的目标尽量搞清楚这些概念和特点。</p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>首先我们先研究TCP：传输控制协议（英语：Transmission Control Protocol，缩写：TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能。<br>TCP协议的运行可划分为三个阶段：连接创建(connection establishment)、数据传送（data transfer）和连接终止（connection termination）</p>
<h2 id="连接创建-connection-establishment"><a href="#连接创建-connection-establishment" class="headerlink" title="连接创建(connection establishment)"></a>连接创建(connection establishment)</h2><p>通常由一端（服务端）被被动打开一个套接字（socket）然后监听另一方（客户端）的连接，服务端执行了listen函数后，就在服务器创建两个队列：</p>
<ul>
<li>SYN队列：存放完成了二次握手的结果。队列长度由listen函数的参数backlog指定。</li>
<li>ACCEPT队列：存放完成了三次握手的结果。队列长度由listen函数的参数backlog指定。</li>
</ul>
<p>三次握手的过程：</p>
<ol>
<li>客户端（通过执行函数connect）向服务端发送一个SYN包，请求一个主动打开。该包携带客户端为这个连接请求而设定的随机数A作为消息序列号。</li>
<li>服务器端收到一个合法的SYN包后，把该包放入SYN队列中；回送一个SYN/ACK。ACK的确认码应为A+1，SYN/ACK包本身携带一个服务端随机产生的序号B。</li>
<li>客户端收到SYN/ACK包后，发送一个ACK包，该包的序号被设定为A+1，而ACK的确认码则为B+1。然后客户端的connect函数成功返回。当服务器端收到这个ACK包的时候，把请求帧从SYN队列中移出，放至ACCEPT队列中；这时accept函数如果处于阻塞状态，可以被唤醒，从ACCEPT队列中取出ACK包，重新创建一个新的用于双向通信的sockfd，并返回。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/mvilplss/note/master/image/TCP%E5%92%8CUDP%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/img.png" alt="img.png"></p>
<p>如果服务器端接到了客户端发的SYN后回了SYN-ACK后客户端掉线了，服务器端没有收到客户端回来的ACK，那么，这个连接处于一个中间状态，既没成功，也没失败。于是，服务器端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s，TCP才会断开这个连接。使用三个TCP参数来调整行为：tcp_synack_retries 减少重试次数；tcp_max_syn_backlog，增大SYN连接数；tcp_abort_on_overflow决定超出能力时的行为。其中DDOS就可以利用发送大量SYN包造成服务端网络或系统资源耗尽，导致正常用户的请求无法访问。</p>
<h2 id="数据传送（data-transfer）"><a href="#数据传送（data-transfer）" class="headerlink" title="数据传送（data transfer）"></a>数据传送（data transfer）</h2><p>在TCP的数据传送状态，很多重要的机制保证了TCP的可靠性和强壮性。它们包括：使用序号，对收到的TCP报文段进行排序以及检测重复的数据；使用校验和检测报文段的错误，即无错传输；使用确认和计时器来检测和纠正丢包或延时；流控制（Flow control）；拥塞控制（Congestion control）；丢失包的重传。</p>
<h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><p>通常在每个TCP报文段中都有一对序号和确认号。TCP报文发送者称自己的字节流的编号为序号（sequence number），称接收到对方的字节流编号为确认号。TCP报文的接收者为了确保可靠性，在接收到一定数量的连续字节流后才发送确认。这是对TCP的一种扩展，称为选择确认（Selective Acknowledgement）。选择确认使得TCP接收者可以对乱序到达的数据块进行确认。每一个字节传输过后，SN号都会递增1。<br>通过使用序号和确认号，TCP层可以把收到的报文段中的字节按正确的顺序交付给应用层。序号是32位的无符号数，在它增大到23^2-1时，便会回绕到0。对于初始化序列号(ISN)的选择是TCP中关键的一个操作，它可以确保强壮性和安全性。<br>TCP协议使用序号标识每端发出的字节的顺序，从而另一端接收数据时可以重建顺序，无惧传输时的包的乱序交付或丢包。在发送第一个包时（SYN包），选择一个随机数作为序号的初值，以克制TCP序号预测攻击.<br>发送确认包（Acks），携带了接收到的对方发来的字节流的编号，称为确认号，以告诉对方已经成功接收的数据流的字节位置。Ack并不意味着数据已经交付了上层应用程序。<br>可靠性通过发送方检测到丢失的传输数据并重传这些数据。包括超时重传（Retransmission timeout，RTO）与重复累计确认（duplicate cumulative acknowledgements，DupAcks）。</p>
<h4 id="基于重复累计确认的重传"><a href="#基于重复累计确认的重传" class="headerlink" title="基于重复累计确认的重传"></a>基于重复累计确认的重传</h4><p>如果一个包（不妨设它的序号是100，即该包始于第100字节）丢失，接收方就不能确认这个包及其以后的包，因为采用了累计ack。接收方在收到100以后的包时，发出对包含第99字节的包的确认。这种重复确认是包丢失的信号。发送方如果收到3次对同一个包的确认，就重传最后一个未被确认的包。阈值设为3被证实可以减少乱序包导致的无作用的重传（spurious retransmission）现象。选择性确认(SACK)的使用能明确反馈哪个包收到了，极大改善了TCP重传必要的包的能力。</p>
<h4 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h4><p>发送方使用一个保守估计的时间作为收到数据包的确认的超时上限。如果超过这个上限仍未收到确认包，发送方将重传这个数据包。每当发送方收到确认包后，会重置这个重传定时器。</p>
<h3 id="数据传输举例"><a href="#数据传输举例" class="headerlink" title="数据传输举例"></a>数据传输举例</h3><ol>
<li>发送方首先发送第一个包含序列号为1（可变化）和1460字节数据的TCP报文段给接收方。接收方以一个没有数据的TCP报文段来回复（只含报头），用确认号1461来表示已完全收到并请求下一个报文段。</li>
<li>发送方然后发送第二个包含序列号为1461，长度为1460字节的数据的TCP报文段给接收方。正常情况下，接收方以一个没有数据的TCP报文段来回复，用确认号2921（1461+1460）来表示已完全收到并请求下一个报文段。发送接收这样继续下去。</li>
<li>然而当这些数据包都是相连的情况下，接收方没有必要每一次都回应。比如，他收到第1到5条TCP报文段，只需回应第五条就行了。在例子中第3条TCP报文段被丢失了，所以尽管他收到了第4和5条，然而他只能回应第2条。</li>
<li>发送方在发送了第三条以后，没能收到回应，因此当时钟（timer）过时（expire）时，他重发第三条。（每次发送者发送一条TCP报文段后，都会再次启动一次时钟：RTT）。</li>
<li>这次第三条被成功接收，接收方可以直接确认第5条，因为4，5两条已收到。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/mvilplss/note/master/image/TCP%E5%92%8CUDP%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/img1.png" alt="img.png"></p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>流量控制用来避免主机分组发送得过快而使接收方来不及完全收下，一般由接收方通告给发送方进行调控。<br>TCP使用滑动窗口协议实现流量控制。接收方在“接收窗口”域指出还可接收的字节数量。发送方在没有新的确认包的情况下至多发送“接收窗口”允许的字节数量。接收方可修改“接收窗口”的值。<br>TCP包的序号与接收窗口的行为很像时钟。<br>当接收方宣布接收窗口的值为0，发送方停止进一步发送数据，开始了“保持定时器”（persist timer），以避免因随后的修改接收窗口的数据包丢失使连接的双侧进入死锁，发送方无法发出数据直至收到接收方修改窗口的指示。当“保持定时器”到期时，TCP发送方尝试恢复发送一个小的ZWP包（Zero Window Probe），期待接收方回复一个带着新的接收窗口大小的确认包。一般ZWP包会设置成3次，如果3次过后还是0的话，有的TCP实现就会发RST把链接断了。</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>拥塞控制是发送方根据网络的承载情况控制分组的发送量，以获取高性能又能避免拥塞崩溃（congestion collapse，网络性能下降几个数量级）。这在网络流之间产生近似最大最小公平分配。<br>发送方与接收方根据确认包或者包丢失的情况，以及定时器，估计网络拥塞情况，从而修改数据流的行为，这称为拥塞控制或网络拥塞避免。<br>TCP的现代实现包含四种相互影响的拥塞控制算法：慢开始、拥塞避免、快速重传、快速恢复。</p>
<h3 id="最大分段大小"><a href="#最大分段大小" class="headerlink" title="最大分段大小"></a>最大分段大小</h3><p>最大分段大小 (MSS)是在单个分段中TCP愿意接受的数据的字节数最大值。MSS应当足够小以避免IP分片，它会导致丢包或过多的重传。在TCP连接创建时，双端在SYN报文中用MSS选项宣布各自的MSS，这是从双端各自直接相连的数据链路层的最大传输单元(MTU)的尺寸减去固定的IP首部和TCP首部长度。以太网MTU为1500字节， MSS值可达1460字节。使用IEEE 802.3的MTU为1492字节，MSS可达1452字节。如果目的IP地址为“非本地的”，MSS通常的默认值为536（这个默认值允许20字节的IP首部和20字节的TCP首部以适合576字节IP数据报）。此外，发送方可用传输路径MTU发现（RFC 1191）推导出从发送方到接收方的网络路径上的最小MTU，以此动态调整MSS以避免网络IP分片。</p>
<h3 id="选择确认"><a href="#选择确认" class="headerlink" title="选择确认"></a>选择确认</h3><p>最初采取累计确认的TCP协议在丢包时效率很低。例如，假设通过10个分组发出了1万个字节的数据。如果第一个分组丢失，在纯粹的累计确认协议下，接收方不能说它成功收到了1,000到9,999字节，但未收到包含0到999字节的第一个分组。因而，发送方可能必须重传所有1万个字节。<br>为此，TCP采取了“选择确认”（selective acknowledgment，SACK）选项。RFC 2018对此定义为允许接收方确认它成功收到的分组的不连续的块，以及基础TCP确认的成功收到最后连续字节序号。这种确认可以指出SACK block，包含了已经成功收到的连续范围的开始与结束字节序号。在上述例子中，接收方可以发出SACK指出序号1000到9999，发送方因此知道只需重发第一个分组(字节 0 到 999)。<br>TCP发送方会把乱序收包当作丢包，因此会重传乱序收到的包，导致连接的性能下降。重复SACK选项（duplicate-SACK option）是定义在RFC 2883中的SACK的一项扩展，可解决这一问题。接收方发出D-ACK指出没有丢包，接收方恢复到高传输率。D-SACK使用了SACK的第一个段来做标志，<br>如果SACK的第一个段的范围被ACK所覆盖，那么就是D-SACK;<br>如果SACK的第一个段的范围被SACK的第二个段覆盖，那么就是D-SACK<br>D-SACK旨在告诉发送端：收到了重复的数据，数据包没有丢，丢的是ACK包；或者“Fast Retransmit算法”触发的重传不是因为发出去的包丢了，也不是因为回应的ACK包丢了，而是因为网络延时导致的reordering。<br>SACK选项并不是强制的。仅当双端都支持时才会被使用。TCP连接创建时会在TCP头中协商SACK细节。在 Linux下，可以通过tcp_sack参数打开SACK功能（Linux 2.4后默认打开）。Linux下的tcp_dsack参数用于开启D-SACK功能（Linux 2.4后默认打开）。选择确认也用于流控制传输协议 (SCTP).</p>
<h2 id="连接终止（connection-termination）"><a href="#连接终止（connection-termination）" class="headerlink" title="连接终止（connection termination）"></a>连接终止（connection termination）</h2><p>连接终止使用了四路握手过程（或称四次握手，four-way handshake），在这个过程中连接的每一侧都独立地被终止。当一个端点要停止它这一侧的连接，就向对侧发送FIN，对侧回复ACK表示确认。因此，拆掉一侧的连接过程需要一对FIN和ACK，分别由两侧端点发出。<br>首先发出FIN的一侧，如果给对侧的FIN响应了ACK，那么就会超时等待2*MSL时间，然后关闭连接。在这段超时等待时间内，本地的端口不能被新连接使用；避免延时的包的到达与随后的新连接相混淆。RFC793定义了MSL为2分钟，Linux设置成了30s。参数tcp_max_tw_buckets控制并发的TIME_WAIT的数量，默认值是180000，如果超限，那么，系统会把多的TIME_WAIT状态的连接给destory掉，然后在日志里打一个警告（如：time wait bucket table overflow）<br>连接可以工作在TCP半开状态。即一侧关闭了连接，不再发送数据；但另一侧没有关闭连接，仍可以发送数据。已关闭的一侧仍然应接收数据，直至对侧也关闭了连接。<br>也可以通过测三次握手关闭连接。主机A发出FIN，主机B回复FIN &amp; ACK，然后主机A回复ACK.<br><img src="https://raw.githubusercontent.com/mvilplss/note/master/image/TCP%E5%92%8CUDP%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/img3.png" alt="img.png"></p>
<h2 id="状态编码"><a href="#状态编码" class="headerlink" title="状态编码"></a>状态编码</h2><p>下表为TCP状态码列表，以S指代服务器，C指代客户端，S&amp;C表示两者，S/C表示两者之一：<br>LISTEN S<br>服务器等待从任意远程TCP端口的连接请求。侦听状态。<br>SYN-SENT C<br>客户在发送连接请求后等待匹配的连接请求。通过connect()函数向服务器发出一个同步（SYNC）信号后进入此状态。<br>SYN-RECEIVED S<br>服务器已经收到并发送同步（SYNC）信号之后等待确认（ACK）请求。<br>ESTABLISHED S&amp;C<br>服务器与客户的连接已经打开，收到的数据可以发送给用户。数据传输步骤的正常情况。此时连接两端是平等的。这称作全连接。<br>FIN-WAIT-1 S&amp;C<br>（服务器或客户）主动关闭端调用close（）函数发出FIN请求包，表示本方的数据发送全部结束，等待TCP连接另一端的ACK确认包或FIN&amp;ACK请求包。<br>FIN-WAIT-2 S&amp;C<br>主动关闭端在FIN-WAIT-1状态下收到ACK确认包，进入等待远程TCP的连接终止请求的半关闭状态。这时可以接收数据，但不再发送数据。<br>CLOSE-WAIT S&amp;C<br>被动关闭端接到FIN后，就发出ACK以回应FIN请求，并进入等待本地用户的连接终止请求的半关闭状态。这时可以发送数据，但不再接收数据。<br>CLOSING S&amp;C<br>在发出FIN后，又收到对方发来的FIN后，进入等待对方对己方的连接终止（FIN）的确认（ACK）的状态。少见。<br>LAST-ACK S&amp;C<br>被动关闭端全部数据发送完成之后，向主动关闭端发送FIN，进入等待确认包的状态。<br>TIME-WAIT S/C<br>主动关闭端接收到FIN后，就发送ACK包，等待足够时间以确保被动关闭端收到了终止请求的确认包。【按照RFC 793，一个连接可以在TIME-WAIT保证最大四分钟，即最大分段寿命（maximum segment lifetime）的2倍】<br>CLOSED S&amp;C<br>完全没有连接。</p>
<p><img src="https://raw.githubusercontent.com/mvilplss/note/master/image/TCP%E5%92%8CUDP%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/img4.png" alt="img.png"></p>
<h2 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h2><p><img src="https://raw.githubusercontent.com/mvilplss/note/master/image/TCP%E5%92%8CUDP%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/img5.png" alt="img.png"></p>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>用户数据报协议（英语：User Datagram Protocol，缩写：UDP；又称用户数据包协议）是一个简单的面向数据报的通信协议，位于OSI模型的传输层。该协议由David P. Reed在1980年设计且在RFC 768中被规范。典型网络上的众多使用UDP协议的关键应用在一定程度上是相似的。<br>在TCP/IP模型中，UDP为网络层以上和应用层以下提供了一个简单的接口。UDP只提供数据的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份（所以UDP有时候也被认为是不可靠的数据报协议）。UDP在IP数据报的头部仅仅加入了复用和数据校验字段。<br>UDP适用于不需要或在程序中执行错误检查和纠正的应用，它避免了协议栈中此类处理的开销。对时间有较高要求的应用程序通常使用UDP，因为丢弃数据包比等待或重传导致延迟更可取。</p>
<h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>由于UDP缺乏可靠性且属于无连接协议，所以应用程序通常必须容许一些丢失、错误或重复的数据包。某些应用程序（如TFTP）可能会根据需要在应用程序层中添加基本的可靠性机制。<br>一些应用程序不太需要可靠性机制，甚至可能因为引入可靠性机制而降低性能，所以它们使用UDP这种缺乏可靠性的协议。流媒体，实时多人游戏和IP语音（VoIP）是经常使用UDP的应用程序。 在这些特定应用中，丢包通常不是重大问题。如果应用程序需要高度可靠性，则可以使用诸如TCP之类的协议。<br>例如，在VoIP中延迟和抖动是主要问题。如果使用TCP，那么任何数据包丢失或错误都将导致抖动，因为TCP在请求及重传丢失数据时不向应用程序提供后续数据。如果使用UDP，那么应用程序则需要提供必要的握手，例如实时确认已收到的消息。<br>由于UDP缺乏拥塞控制，所以需要基于网络的机制来减少因失控和高速UDP流量负荷而导致的拥塞崩溃效应。换句话说，因为UDP发送端无法检测拥塞，所以像使用包队列和丢弃技术的路由器之类的网络基础设备会被用于降低UDP过大流量。数据拥塞控制协议（DCCP）设计成通过在诸如流媒体类型的高速率UDP流中增加主机拥塞控制，来减小这个潜在的问题。</p>
<h2 id="UDP头部"><a href="#UDP头部" class="headerlink" title="UDP头部"></a>UDP头部</h2><p><img src="https://raw.githubusercontent.com/mvilplss/note/master/image/TCP%E5%92%8CUDP%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/img6.png" alt="img_1.png"></p>
<h1 id="TCP和UDP比较"><a href="#TCP和UDP比较" class="headerlink" title="TCP和UDP比较"></a>TCP和UDP比较</h1><ol>
<li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</li>
<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保   证可靠交付</li>
<li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的<br>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</li>
<li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</li>
<li>TCP首部开销20字节;UDP的首部开销小，只有8个字节</li>
<li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</li>
</ol>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/85">https://time.geekbang.org/column/intro/85</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Li_Ning_/article/details/52117463">https://blog.csdn.net/Li_Ning_/article/details/52117463</a></li>
<li><a target="_blank" rel="noopener" href="https://nmap.org/book/tcpip-ref.html">https://nmap.org/book/tcpip-ref.html</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2021/01/22/Mysql%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E7%AD%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/22/Mysql%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E7%AD%94/" class="post-title-link" itemprop="url">Mysql的一些问答</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-22 00:00:00" itemprop="dateCreated datePublished" datetime="2021-01-22T00:00:00+08:00">2021-01-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:03" itemprop="dateModified" datetime="2022-07-05T22:46:03+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">开发技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="数据库相关问题"><a href="#数据库相关问题" class="headerlink" title="数据库相关问题"></a>数据库相关问题</h1><h2 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h2><ul>
<li>第一范式：确保每列的原子性,每列都是不可分割的最小数据单元</li>
<li>第二范式：在第一范式的基础上，要求每列都和主键相关</li>
<li>第三范式：在第二范式的基础上，要求其他列和主键是直接相关，而不是间接相关</li>
</ul>
<h2 id="分别说一下范式和反范式的优缺点"><a href="#分别说一下范式和反范式的优缺点" class="headerlink" title="分别说一下范式和反范式的优缺点"></a>分别说一下范式和反范式的优缺点</h2><p>1.范式化</p>
<p>优点：</p>
<ul>
<li>减少苏局冗余</li>
<li>表中重复数据较少，更新操作比较快</li>
<li>范式化的表通常比范式化的表小</li>
</ul>
<p>缺点：</p>
<ul>
<li>在查询的时候通常需要很多关联，降低性能</li>
<li>增加了索引优化的难度</li>
</ul>
<p>2.反范式化</p>
<p>优点：</p>
<ul>
<li>可以减少表的关联</li>
<li>更好的进行索引优化</li>
</ul>
<p>缺点：</p>
<ul>
<li>数据重复冗余</li>
<li>对数据表的修改需要更多的成本</li>
</ul>
<h2 id="Mysql-数据库索引。B-树和-B-树的区别"><a href="#Mysql-数据库索引。B-树和-B-树的区别" class="headerlink" title="Mysql 数据库索引。B+ 树和 B 树的区别"></a>Mysql 数据库索引。B+ 树和 B 树的区别</h2><p>MySQL数据库索引和存储引擎有关，MyISAM和InnoDB只支持BTREE索引。MEMORY和HEAP支持HASH和BTREE索引</p>
<p>B+树和B树的区别</p>
<ul>
<li>B+树非叶子节点只存储关键字和指向子节点的指针，而B树还存储了数据，在同样大小的情况下，B+树可以存储更多的关键字</li>
<li>B+树叶子节点存储了所有关键字和数据，并且多个节点用链表连接。可以快速支撑范围查找</li>
<li>B+树非叶子节点不存储数据，所以查询时间复杂度固定为O(logN)，B树查询时间复杂度不固定，最好是O(1)<br>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ace3cd6526c4">https://www.jianshu.com/p/ace3cd6526c4</a><h2 id="为什么-B-树比-B-树更适合应用于数据库索引，除了数据库索引，还有什么地方用到了（操作系统的文件索引）"><a href="#为什么-B-树比-B-树更适合应用于数据库索引，除了数据库索引，还有什么地方用到了（操作系统的文件索引）" class="headerlink" title="为什么 B+ 树比 B 树更适合应用于数据库索引，除了数据库索引，还有什么地方用到了（操作系统的文件索引）"></a>为什么 B+ 树比 B 树更适合应用于数据库索引，除了数据库索引，还有什么地方用到了（操作系统的文件索引）</h2>因为B树叶子节点和非叶子结点都存储了数据，这样就导致了非叶子结点能保存的关键字和指针变少，如果要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能降低</li>
</ul>
<p>除数据库索引，还有操作系统的文件索引用到了B树。参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33369979/article/details/89810632">https://blog.csdn.net/qq_33369979/article/details/89810632</a></p>
<h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><ul>
<li>聚簇索引，又叫主键索引，每个表只有一个主键索引，叶子节点保存主键的值和数据</li>
<li>非聚簇索引，又叫辅助索引，叶子节点保存索引字段的值和主键的值</li>
</ul>
<h2 id="前缀索引和覆盖索引"><a href="#前缀索引和覆盖索引" class="headerlink" title="前缀索引和覆盖索引"></a>前缀索引和覆盖索引</h2><p>1.前缀索引<br>对于列的值较长，比如BLOB、TEXT、VARCHAR，就必须建立前缀索引，即将值的前一部分作为索引。这样既可以节约空间，又可以提高查询效率。但无法使用前缀索引做 ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描。</p>
<p>2.覆盖索引<br>select的数据列从索引中就能获得，不必再从数据表中读取。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫 做覆盖索引。</p>
<p>当发起一个被索引覆盖的查询(也叫作索引覆盖查询)时，在EXPLAIN的Extra列可以看到“Using index”的信息</p>
<h2 id="介绍一下数据库的事务"><a href="#介绍一下数据库的事务" class="headerlink" title="介绍一下数据库的事务"></a>介绍一下数据库的事务</h2><ul>
<li>事务是一个操作序列，这些操作要么全部执行，要么都不执行。</li>
<li>事务具有四大特性：A（原子性）、C（一致性）、I（隔离性）、D（持久性）</li>
</ul>
<h2 id="Mysql-有哪些隔离级别"><a href="#Mysql-有哪些隔离级别" class="headerlink" title="Mysql 有哪些隔离级别"></a>Mysql 有哪些隔离级别</h2><table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>读已提交（read-committed）</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<h2 id="Mysql-什么情况会造成脏读、可重复度、幻读？如何解决"><a href="#Mysql-什么情况会造成脏读、可重复度、幻读？如何解决" class="headerlink" title="Mysql 什么情况会造成脏读、可重复度、幻读？如何解决"></a>Mysql 什么情况会造成脏读、可重复度、幻读？如何解决</h2><ul>
<li><strong>脏读</strong>：有两个事务A和B，A读取已经被B修改但未提交的字段，此时B回滚，那么A读取的字段就是临时且无效的。可以提高隔离级别，改成读已提交</li>
<li><strong>不可重复读</strong>： 有两个事务A和B，A读取了一个字段值，然后B更新并且提交事务，A再重新读取这个字段，就和之前不相等了。可以提高隔离级别，改成可重复读</li>
<li><strong>幻读</strong>： 有两个事务A和B，A读取某个范围内的记录时，B又在该范围内插入了新的记录并提交，当事务A再次读取该范围的记录时，会产生幻行。可以升级隔离级别到串行化，或者使用 MVCC + next-key锁机制实现</li>
</ul>
<h2 id="Mysql-在可重复度的隔离级别下会不会有幻读的情况，为什么？"><a href="#Mysql-在可重复度的隔离级别下会不会有幻读的情况，为什么？" class="headerlink" title="Mysql 在可重复度的隔离级别下会不会有幻读的情况，为什么？"></a>Mysql 在可重复度的隔离级别下会不会有幻读的情况，为什么？</h2><p>不会。InnoDB存储引擎默认隔离级别为RR，通过MVCC + next-key锁机制解决了幻读的问题。</p>
<p>PS：其实严格来说，是存在幻读的。。。可以尝试一下这个操作，A开启事务，执行查询，此时B开启事务新增一条数据并提交，此时A再查询，发现没有幻读，但是如果A执行一个update操作，再查询，会发现出现了幻读。我认为应该是A在执行update操作的时候，新建了一条创建版本号为A事务版本号的记录，然后标记B事务创建的记录为待删除的，查询的版本号依据是删除版本号为空或大于当前版本号，并且创建版本号小于等于当前事务版本号，那么这里刚刚A更新的这条数据，显然也符合查询的条件，所以也会被查出来。</p>
<ul>
<li>MVCC版本号原理参考文章 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/shujiying/p/11347632.html">https://www.cnblogs.com/shujiying/p/11347632.html</a></li>
<li>详细测试参考文章 <a target="_blank" rel="noopener" href="https://blog.csdn.net/w139074301/article/details/111052454">https://blog.csdn.net/w139074301/article/details/111052454</a><h2 id="Mysql-事务是如何实现的"><a href="#Mysql-事务是如何实现的" class="headerlink" title="Mysql 事务是如何实现的"></a>Mysql 事务是如何实现的</h2></li>
<li>原子性：通过undo log实现的。每条数据变更都伴随一条undo log日志的生成，当系统发生错误或执行回滚根据undo log做逆向操作</li>
<li>持久性：通过redo log实现的。redo log记录了数据的修改日志。数据持久化到磁盘，先是储存到缓冲池里，然后缓冲池中的数据定期同步到磁盘中，如果系统宕机，可能会丢失数据，系统重启后会读取redo log恢复数据</li>
<li>隔离性：mysql数据库通过MVCC + next-key机制实现了隔离性 </li>
<li>一致性：以上3大特性，保障了事务的一致性<h2 id="Binlog-和-Redo-log-的区别是什么，分别是什么用？"><a href="#Binlog-和-Redo-log-的区别是什么，分别是什么用？" class="headerlink" title="Binlog 和 Redo log 的区别是什么，分别是什么用？"></a>Binlog 和 Redo log 的区别是什么，分别是什么用？</h2></li>
<li>binlog是二进制文件，记录了对数据库执行更改的所有操作，不包括 select、show，因为这两个操作没有对数据本身做修改。但是若操作了数据，但是数据没有发生变化，也会记录到binlog。常用来数据恢复，数据备份。</li>
<li>redo log又叫做重做日志文件，记录了事务的修改，不管事务是否提交都记录下来。在实例和介质失败时，InnoDB存储引擎会使用redo log恢复到之前的状态，保证数据的完整性</li>
</ul>
<h2 id="谈一谈-MVCC-多版本并发控制"><a href="#谈一谈-MVCC-多版本并发控制" class="headerlink" title="谈一谈 MVCC 多版本并发控制"></a>谈一谈 MVCC 多版本并发控制</h2><p>MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<ul>
<li><p>SELECT<br>InnoDB会根据以下两个条件检查每行记录：<br>InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。<br>行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。<br>只有符合上述两个条件的记录，才能返回作为查询结果</p>
</li>
<li><p>INSERT<br>InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</p>
</li>
<li><p>DELETE<br>InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</p>
</li>
<li><p>UPDATE<br>InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</p>
</li>
</ul>
<h2 id="Innodb-和-MyISAM-的区别是什么"><a href="#Innodb-和-MyISAM-的区别是什么" class="headerlink" title="Innodb 和 MyISAM 的区别是什么"></a>Innodb 和 MyISAM 的区别是什么</h2><ul>
<li>Innodb 支持事务。MyISAM 不支持</li>
<li>Innodb 支持外键。MyISAM 不支持</li>
<li>Innodb 主键索引的叶子节点是数据文件，辅助索引的叶子节点是主键的值。MyISAM 的主键索引和辅助索引，叶子节点都是数据文件的指针</li>
<li>Innodb 不保存表的行数，执行 select count(*) from tb需要全表扫描。MyISAM 用一个变量保存了整个表的行数，执行上述语句只需要读取该变量，速度很快</li>
<li>Innodb 所有的表在磁盘上保存在一个文件中。MyISAM 存储成三个文件。</li>
<li>Innodb 需要更多的内存和存储。MyISAM 可被压缩，存储空间较小。</li>
<li>Innodb 移植方案拷贝文件、备份 binlog，或者用 mysqldump，移植较困难。MyISAM 数据以文件形式存储，在备份和回复时可以单独针对表进行操作</li>
<li>Innodb 支持行锁、表锁。MyISAM 支持表锁</li>
<li>Innodb 在5.7版本之前不支持全文索引。MyISAM 支持全文索引</li>
</ul>
<h2 id="Innodb-的默认加锁方式是什么，是怎么实现的"><a href="#Innodb-的默认加锁方式是什么，是怎么实现的" class="headerlink" title="Innodb 的默认加锁方式是什么，是怎么实现的"></a>Innodb 的默认加锁方式是什么，是怎么实现的</h2><ul>
<li>Innodb默认加锁方式是行级锁</li>
<li>通过给索引上的索引项加锁来实现的</li>
</ul>
<h2 id="如何高效处理大库-DDL"><a href="#如何高效处理大库-DDL" class="headerlink" title="如何高效处理大库 DDL"></a>如何高效处理大库 DDL</h2><ul>
<li>DDL是值数据定义语句，即建表，建视图这种，所以这里的问题，我认为可能是考察建表的时候注意事项。</li>
<li>比如数据字段的定义，遵循从小原则。表的创建，降低耦合。</li>
</ul>
<h2 id="Mysql-索引重建"><a href="#Mysql-索引重建" class="headerlink" title="Mysql 索引重建"></a>Mysql 索引重建</h2><ul>
<li>mysqldump导出然后重新导入，drop index + recreate index</li>
<li>alter table xxx ENGINE = InnoDB</li>
<li>repaire table xxx，这种对于InnoDB的无效</li>
<li>OPTIMIZE TABLE xxx</li>
</ul>
<h2 id="对于多列索引，哪些情况下能用到索引，哪些情况用不到索引"><a href="#对于多列索引，哪些情况下能用到索引，哪些情况用不到索引" class="headerlink" title="对于多列索引，哪些情况下能用到索引，哪些情况用不到索引"></a>对于多列索引，哪些情况下能用到索引，哪些情况用不到索引</h2><ul>
<li>like以%开头</li>
<li>or查询，必须左右字段都是索引，否则索引失效</li>
<li>联合索引，遵从最左匹配原则，如果不是使用第一列索引，索引失效</li>
<li>数据出现隐形转换，如varchar字段没加单引号，自动转为int类型，会使索引失效</li>
<li>索引字段使用not、&lt;&gt;、!=，索引失效</li>
<li>索引字段使用函数，索引无效</li>
</ul>
<h2 id="为什么使用数据库索引可以提高效率，在什么情况下会用不到数据库索引？"><a href="#为什么使用数据库索引可以提高效率，在什么情况下会用不到数据库索引？" class="headerlink" title="为什么使用数据库索引可以提高效率，在什么情况下会用不到数据库索引？"></a>为什么使用数据库索引可以提高效率，在什么情况下会用不到数据库索引？</h2><p>默认执行SQL语句是进行全表扫描，遇到匹配条件的就加入搜索结果合集。如果有索引，就会先去索引表中一次定位到特定值的行数，减少遍历匹配的行数。索引把无序的数据变成了相对有序的数据结构。</p>
<p>什么情况用不到数据库索引 见上题回答</p>
<h2 id="共享锁和排他锁的使用场景，"><a href="#共享锁和排他锁的使用场景，" class="headerlink" title="共享锁和排他锁的使用场景，"></a>共享锁和排他锁的使用场景，</h2><ul>
<li>更新、新增、删除默认加排它锁，查询默认不加锁</li>
<li>共享锁，使用语法select * from tb lock in share mode，自身可以读，其他事务也可以读（也可以继续加共享锁），但是其他事务无法修改</li>
<li>排它锁，适用语法select * from tb for update，自身可以进行增删改查，其他事务无法进行任何操作</li>
</ul>
<h2 id="关系型数据库和非关系数据库的优缺点"><a href="#关系型数据库和非关系数据库的优缺点" class="headerlink" title="关系型数据库和非关系数据库的优缺点"></a>关系型数据库和非关系数据库的优缺点</h2><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><p>优点：<br>二维表格，容易理解<br>操作方便<br>易于维护<br>支持SQL</p>
<p>缺点：<br>读写性能较差<br>固定的表结构，不够灵活<br>应对高并发场景，磁盘I/O存在瓶颈<br>海量数据的读写性能差</p>
<h3 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h3><p>优点：<br>不需要SQL解析，读写性能高<br>可以使用硬盘或者内存作为载体，速度快<br>基于键值对，数据没有耦合性，方便扩展<br>部署简单</p>
<p>缺点：<br>不支持SQL，增加了学习成本<br>没有事务</p>
<h2 id="Mysql-什么情况会造成慢查，如何查看慢查询"><a href="#Mysql-什么情况会造成慢查，如何查看慢查询" class="headerlink" title="Mysql 什么情况会造成慢查，如何查看慢查询"></a>Mysql 什么情况会造成慢查，如何查看慢查询</h2><p>响应时间超过阈值会产生慢查询日志。一般有以下情况会造成查询慢</p>
<p>没有设置索引，或查询没有用到索引<br>I/O吞吐量过小<br>内存不足<br>网络速度慢<br>查询的数据量过大<br>锁或者死锁<br>返回了不必要的行或列<br>查询语句存在问题，需要优化<br>慢查询日志默认是关闭的，如果非必要，不要开启，会影响性能。</p>
<p>使用SHOW VARIABLES LIKE ‘slow_query%’;</p>
<p>slow_query_log，慢查询开启关闭状态</p>
<p>slow_query_log_file，慢查询日志存储位置，用文本编辑器打开存储位置的文件，查询慢查询</p>
<h2 id="如何处理慢查询，你一般是怎么处理慢查询的"><a href="#如何处理慢查询，你一般是怎么处理慢查询的" class="headerlink" title="如何处理慢查询，你一般是怎么处理慢查询的"></a>如何处理慢查询，你一般是怎么处理慢查询的</h2><ul>
<li>把数据、日志、索引放到不同的I/O设备上，增加读取速度</li>
<li>纵向、横向分割表，减少表的尺寸</li>
<li>升级硬件</li>
<li>根据查询条件，建立索引，索引优化</li>
<li>提高网速</li>
<li>扩大服务器内存</li>
<li>分库分表</li>
</ul>
<h2 id="Mysql-中-varchar-和-char-的区别"><a href="#Mysql-中-varchar-和-char-的区别" class="headerlink" title="Mysql 中 varchar 和 char 的区别"></a>Mysql 中 varchar 和 char 的区别</h2><p>varchar会根据存储的内容改变长度，char是定长，如果长度不够，则使用空格补齐</p>
<h2 id="数据库外键的优缺点"><a href="#数据库外键的优缺点" class="headerlink" title="数据库外键的优缺点"></a>数据库外键的优缺点</h2><p>优点：<br>能最大限度的保证数据的一致性和完整性<br>增加ER图的可读性</p>
<p>缺点：<br>影响数据操作的效率<br>增加开发难度，导致表过多</p>
<h2 id="有没有使用过数据库的视图"><a href="#有没有使用过数据库的视图" class="headerlink" title="有没有使用过数据库的视图"></a>有没有使用过数据库的视图</h2><ul>
<li>使用create view view_name as select * from tb创建视图</li>
<li>使用select * from view_name正常查询视图</li>
</ul>
<h2 id="Mysql-中插入数据使用自增-id-好还是使用-uuid，为什么？"><a href="#Mysql-中插入数据使用自增-id-好还是使用-uuid，为什么？" class="headerlink" title="Mysql 中插入数据使用自增 id 好还是使用 uuid，为什么？"></a>Mysql 中插入数据使用自增 id 好还是使用 uuid，为什么？</h2><ul>
<li>单实例或单节点组，不担心网络爬虫获取数据量，推荐使用自增id，性能更好</li>
<li>分布式场景。20个节点下的小规模分布式场景，推荐uuid。20~200个节点的中规模分布式场景，推荐自增id+步长的策略。200以上节点，推荐推特雪花算法的全局自增ID</li>
</ul>
<h2 id="Mysql-有哪些数据类型，使用的时候有没有什么注意点"><a href="#Mysql-有哪些数据类型，使用的时候有没有什么注意点" class="headerlink" title="Mysql 有哪些数据类型，使用的时候有没有什么注意点"></a>Mysql 有哪些数据类型，使用的时候有没有什么注意点</h2><ul>
<li>整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、INT、BIG INT</li>
<li>浮点数类型：FLOAT、DOUBLE、DECIMAL</li>
<li>字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、MEDIUM BLOB、LONG BLOB</li>
<li>日期类型：Date、DateTime、TIMESTAMP、TIME、YEAR</li>
</ul>
<p>使用的时候建议遵循从小原则。</p>
<ul>
<li>使用char和vahrchar的时候，注意char会去掉字符串末尾的空格</li>
<li>使用text和blob的时候，注意定期清理碎片空间，使用OPTIMIZE TABLE命令</li>
<li>浮点数会造成精度丢失，尽量使用定点数DECIMAL</li>
</ul>
<h2 id="Mysql-集群有哪几种方式，分别适用于什么场景"><a href="#Mysql-集群有哪几种方式，分别适用于什么场景" class="headerlink" title="Mysql 集群有哪几种方式，分别适用于什么场景"></a>Mysql 集群有哪几种方式，分别适用于什么场景</h2><ul>
<li>组建MySQL集群的方式：<br>LVS + Keepalived + MySQL<br>DRBD + Heartbeat + MySQL<br>MySQL + Proxy<br>MySQL Cluster<br>MySQL + MHA<br>MySQL + MMM</li>
</ul>
<p>场景：<br>如果是双主复制，不需要数据拆分，可以使用MHA或Keepalived或Heartbeat<br>如果是双主复制，需要数据拆分，采用Cobar<br>如果是双主复制+Slave，还做了数据拆分，需要读写分离，采用Amoeba</p>
<h2 id="Mysql-主从模式如何保证主从强一致性"><a href="#Mysql-主从模式如何保证主从强一致性" class="headerlink" title="Mysql 主从模式如何保证主从强一致性"></a>Mysql 主从模式如何保证主从强一致性</h2><p>主从复制原理：master写数据留下写入日志，slave根据master留下的日志模仿数据执行过程写入<br>所以有两个步骤可能导致主从复制不一致：</p>
<ol>
<li>master日志写入不成功</li>
<li>slave根据日志模仿不成功<br>解决办法；<br>1.master上修改配置<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">innodb_flush_log_at_trx_commit</span> = <span class="string">1</span></span><br><span class="line"><span class="attr">sync_binlog</span> = <span class="string">1</span></span><br></pre></td></tr></table></figure>
上述两个选项的作用是：保证每次事务提交后，都能实时刷新到磁盘中，尤其是确保每次事务对应的binlog都能及时刷新到磁盘中</li>
<li>slave上修改配置<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">master_info_repository</span> = <span class="string">&quot;TABLE&quot;</span></span><br><span class="line"><span class="attr">relay_log_info_repository</span> = <span class="string">&quot;TABLE&quot;</span></span><br><span class="line"><span class="attr">relay_log_recovery</span> = <span class="string">1</span></span><br></pre></td></tr></table></figure>
上述前两个选项的作用是：确保在slave上和复制相关的元数据表也采用InnoDB引擎，受到InnoDB事务安全的保护，而后一个选项的作用是开启relay log自动修复机制，发生crash时，会自动判断哪些relay log需要重新从master上抓取回来再次应用，以此避免部分数据丢失的可能性。</li>
</ol>
<h2 id="Mysql-集群如何保证主从可用性"><a href="#Mysql-集群如何保证主从可用性" class="headerlink" title="Mysql 集群如何保证主从可用性"></a>Mysql 集群如何保证主从可用性</h2><p>使用HA检测工具。HA工具部署在第三台服务器上，同时连接主从，检测主从是否存活。如果主库宕机则及时将从库升级为主库，将原来的主库降级为从库</p>
<h2 id="Mysql-读写分离有哪些解决办法"><a href="#Mysql-读写分离有哪些解决办法" class="headerlink" title="Mysql 读写分离有哪些解决办法"></a>Mysql 读写分离有哪些解决办法</h2><ul>
<li>配置多数据源</li>
<li>使用中间件代理<br>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/bc45c8bccf3c">https://www.jianshu.com/p/bc45c8bccf3c</a><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1></li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/circle/discuss/6xECGC/">https://leetcode-cn.com/circle/discuss/6xECGC/</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2021/01/04/ES%E5%92%8CLogStash%E7%BB%93%E5%90%88%E5%AF%BC%E5%85%A5mysql%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/04/ES%E5%92%8CLogStash%E7%BB%93%E5%90%88%E5%AF%BC%E5%85%A5mysql%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">ES和LogStash结合导入mysql数据</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-04 00:00:00" itemprop="dateCreated datePublished" datetime="2021-01-04T00:00:00+08:00">2021-01-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:03" itemprop="dateModified" datetime="2022-07-05T22:46:03+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">开发技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ES和LogStash结合导入mysql数据"><a href="#ES和LogStash结合导入mysql数据" class="headerlink" title="ES和LogStash结合导入mysql数据"></a>ES和LogStash结合导入mysql数据</h1><p>我们安装和启动好ES，学会了ES的用法后，现在要应用到我们实际的项目中，我们如何将现有的数据在ES中创建索引呢？下面将介绍两种方式，通过ES的api直接索引和通过LogStash组件进行索引。</p>
<h2 id="通过ES的API进行索引"><a href="#通过ES的API进行索引" class="headerlink" title="通过ES的API进行索引"></a>通过ES的API进行索引</h2><p>本示例我们采用的Java语言开发，使用maven构建的工程，我们先把api相关依赖加入pom.xml</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;7.12.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;7.12.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>创建索引</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 创建高版本客户端</span><br><span class="line">RestHighLevelClient client = new RestHighLevelClient(RestClient.builder(new HttpHost(&quot;localhost&quot;, 9200, &quot;http&quot;)));</span><br><span class="line">// 创建索引对象</span><br><span class="line">IndexRequest indexRequest = new IndexRequest(&quot;posts&quot;)</span><br><span class="line">                .index(&quot;db_test&quot;)</span><br><span class="line">                .type(&quot;user&quot;)</span><br><span class="line">                .id(&quot;5&quot;)</span><br><span class="line">                .source(&quot;user&quot;, &quot;kimchy&quot;,</span><br><span class="line">                        &quot;postDate&quot;, null,</span><br><span class="line">                        &quot;message&quot;, &quot;trying out Elasticsearch&quot;);</span><br><span class="line">// 调用客户端创建索引</span><br><span class="line">IndexResponse index = client.index(indexRequest, RequestOptions.DEFAULT);</span><br><span class="line">// 关闭索引</span><br><span class="line">client.close();                    </span><br></pre></td></tr></table></figure>
<p>通过API创建索引的逻辑比较简单，关于查询索引，删除索引，更新索引请参考官方文档：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html">https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html</a></p>
<h2 id="LogStash导入数据"><a href="#LogStash导入数据" class="headerlink" title="LogStash导入数据"></a>LogStash导入数据</h2><h3 id="下载安装LogStash"><a href="#下载安装LogStash" class="headerlink" title="下载安装LogStash"></a>下载安装LogStash</h3><p>下面我们先下载安装LogStash，下载地址：<a target="_blank" rel="noopener" href="https://www.elastic.co/cn/downloads/logstash">https://www.elastic.co/cn/downloads/logstash</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/logstash/logstash-7.12.1-linux-x86_64.tar.gz</span><br><span class="line">tail -zxvf logstash-7.12.1-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure>
<p>运行测试</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd logstash-7.12.1</span><br><span class="line">./bin/logstash -e &#x27;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>运行完成后，我们控制台输入hello logstash。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">The stdin plugin is now waiting for input:</span><br><span class="line">hello logstash</span><br><span class="line">&#123;</span><br><span class="line">      &quot;@version&quot; =&gt; &quot;1&quot;,</span><br><span class="line">    &quot;@timestamp&quot; =&gt; 2020-05-14T03:56:07.035Z,</span><br><span class="line">       &quot;message&quot; =&gt; &quot;hello logstash&quot;,</span><br><span class="line">          &quot;host&quot; =&gt; &quot;apple&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面执行过程就是：输入（hello logstash）》通过logstash管道经过多个过滤器加工数据》输出结果。</p>
<h3 id="导入mysql数据"><a href="#导入mysql数据" class="headerlink" title="导入mysql数据"></a>导入mysql数据</h3><p>为了方便演示，我创建了一个tb_article表，并初始化了一些数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_article(</span><br><span class="line">                           id <span class="type">int</span>(<span class="number">11</span>) auto_increment <span class="keyword">primary</span> <span class="keyword">key</span> ,</span><br><span class="line">                           article <span class="type">varchar</span>(<span class="number">128</span>) comment <span class="string">&#x27;文章&#x27;</span>,</span><br><span class="line">                           tilte <span class="type">varchar</span>(<span class="number">64</span>) comment <span class="string">&#x27;标题&#x27;</span>,</span><br><span class="line">                           author <span class="type">varchar</span>(<span class="number">16</span>) comment <span class="string">&#x27;作者&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_article(article, tilte, author) <span class="keyword">VALUES</span> (<span class="string">&#x27;所有人都要得死，所有人都要奉承。这是出自《权利的游戏》电影中人们常说的一句话。&#x27;</span>,<span class="string">&#x27;名言&#x27;</span>,<span class="string">&#x27;张三&#x27;</span>),</span><br><span class="line">                                                      (<span class="string">&#x27;现在写在代码就是为了将来可以可写代码。&#x27;</span>,<span class="string">&#x27;哲理&#x27;</span>,<span class="string">&#x27;李四&#x27;</span>),</span><br><span class="line">                                                      (<span class="string">&#x27;当发生雪崩时，没有一片雪花是无辜的；这个观点的角度应该是上帝视角。&#x27;</span>,<span class="string">&#x27;哲理&#x27;</span>,<span class="string">&#x27;张三&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>导入mysql的数据前，我们要准备mysql驱动，存放位置要写到下面的配置中</p>
<p>编写logstash数据处理配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个conf文件，将下面配置写入</span></span><br><span class="line">vi config/mysql.conf</span><br><span class="line"></span><br><span class="line">input &#123;</span><br><span class="line">         stdin &#123;&#125;</span><br><span class="line">         jdbc &#123;</span><br><span class="line">               # mysql 数据库链接,shop为数据库名</span><br><span class="line">               jdbc_connection_string =&gt; &quot;jdbc:mysql://172.21.24.215:3306/article&quot;</span><br><span class="line">               # 用户名和密码</span><br><span class="line">               jdbc_user =&gt; &quot;root&quot;</span><br><span class="line">               jdbc_password =&gt; &quot;root&quot;</span><br><span class="line">               # 驱动</span><br><span class="line">               jdbc_driver_library =&gt; &quot;/root/Downloads/logstash-7.12.1/lib/mlib/mysql-connector-java-8.0.24/mysql-connector-java-8.0.24.jar&quot;</span><br><span class="line">               # 驱动类名</span><br><span class="line">               jdbc_driver_class =&gt; &quot;com.mysql.cj.jdbc.Driver&quot;</span><br><span class="line">               jdbc_paging_enabled =&gt; &quot;true&quot;</span><br><span class="line">               jdbc_page_size =&gt; &quot;100&quot;</span><br><span class="line">               # 执行的sql 文件路径+名称</span><br><span class="line">               #statement_filepath =&gt; &quot;/root/Downloads/logstash-7.12.1/config/sql/tbinfo.sql&quot;</span><br><span class="line">               statement =&gt; &quot;select * from tb_article&quot;</span><br><span class="line">               # 设置监听间隔  各字段含义（由左至右）分、时、天、月、年，全部为*默认含义为每分钟都更新</span><br><span class="line">               schedule =&gt; &quot;* * * * *&quot;</span><br><span class="line">               # 索引类型</span><br><span class="line">               type =&gt; &quot;article&quot;</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   filter &#123;</span><br><span class="line">	   json &#123;</span><br><span class="line">			source =&gt; &quot;message&quot;</span><br><span class="line">			remove_field =&gt; [&quot;message&quot;]</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">     output &#123;</span><br><span class="line">         if [type]==&quot;article&quot;&#123;</span><br><span class="line">             elasticsearch &#123;</span><br><span class="line">                 hosts =&gt; [&quot;localhost:9200&quot;]</span><br><span class="line">                 index =&gt; &quot;article&quot;</span><br><span class="line">                 document_id =&gt; &quot;%&#123;id&#125;&quot;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         stdout &#123;</span><br><span class="line">               codec =&gt; &quot;json_lines&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>启动logstash</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/logstash -f config/mysql.conf</span><br></pre></td></tr></table></figure>
<p>日志会输出导入ES的json数据。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@version&quot;:&quot;1&quot;,&quot;type&quot;:&quot;article&quot;,&quot;@timestamp&quot;:&quot;2020-05-14T07:32:08.869Z&quot;,&quot;id&quot;:&quot;1&quot;,&quot;article&quot;:&quot;所有人都要得死，所有人都要奉承。这是出自《权利的游戏》电影中人们常说的一句话。&quot;,&quot;title&quot;:&quot;名言&quot;,&quot;author&quot;:&quot;张三&quot;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&quot;@version&quot;:&quot;1&quot;,&quot;type&quot;:&quot;article&quot;,&quot;@timestamp&quot;:&quot;2020-05-14T07:32:08.869Z&quot;,&quot;id&quot;:&quot;1&quot;,&quot;article&quot;:&quot;现在写在代码就是为了将来可以可写代码。&quot;,&quot;title&quot;:&quot;哲理&quot;,&quot;author&quot;:&quot;李四&quot;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&quot;@version&quot;:&quot;1&quot;,&quot;type&quot;:&quot;article&quot;,&quot;@timestamp&quot;:&quot;2020-05-14T07:32:08.869Z&quot;,&quot;id&quot;:&quot;1&quot;,&quot;article&quot;:&quot;当发生雪崩时，没有一片雪花是无辜的；这个观点的角度应该是上帝视角。&quot;,&quot;title&quot;:&quot;哲理&quot;,&quot;author&quot;:&quot;张三&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>到此我们已经将mysql的数据导入了ES中。</p>
<h3 id="通过binlog进行同步"><a href="#通过binlog进行同步" class="headerlink" title="通过binlog进行同步"></a>通过binlog进行同步</h3><p>参考文章：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/document/product/845/35562">https://cloud.tencent.com/document/product/845/35562</a></p>
<h2 id="怎么快速把mysql的大数据量导入ES？"><a href="#怎么快速把mysql的大数据量导入ES？" class="headerlink" title="怎么快速把mysql的大数据量导入ES？"></a>怎么快速把mysql的大数据量导入ES？</h2><p>线上有个场景，就是有两千多万的一个订单数据，通过上述的mysql导入太慢，每秒导入100条数据，大约需要56小时，耗时主要是jdbc的IO和ES的写入数据IO。<br>优化方案是减少网络IO：</p>
<ol>
<li>先将数据库数据导出cvs文件中，避免jdbc的IO。</li>
<li>批量写入ES，减少IO次数。</li>
</ol>
<p>导出mysql数据:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM tb_article</span> </span><br><span class="line">    -&gt; INTO OUTFILE &#x27;tb_article.cvs&#x27;;</span><br></pre></td></tr></table></figure>
<p>增加logstash的cvs导入配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">       file &#123;</span><br><span class="line">         path =&gt; [&quot;/Users/atomic/Desktop/tb_article.csv&quot;]</span><br><span class="line">         start_position =&gt; &quot;beginning&quot;,</span><br><span class="line">         type =&gt; &quot;article&quot;</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> filter &#123;</span><br><span class="line">  csv&#123;</span><br><span class="line">      separator =&gt; &quot;,&quot;</span><br><span class="line">      columns =&gt; [&quot;id&quot;,&quot;article&quot;,&quot;title&quot;,&quot;author&quot;]</span><br><span class="line">      skip_empty_columns =&gt; true</span><br><span class="line">      remove_field =&gt; [&quot;host&quot;, &quot;tags&quot;, &quot;path&quot;, &quot;message&quot;]</span><br><span class="line">     &#125;</span><br><span class="line">  mutate&#123;</span><br><span class="line">          convert =&gt; &#123;</span><br><span class="line">            &quot;id&quot; =&gt; &quot;integer&quot;</span><br><span class="line">            &quot;article&quot; =&gt; &quot;string&quot;</span><br><span class="line">            &quot;title&quot; =&gt; &quot;string&quot;</span><br><span class="line">            &quot;author&quot; =&gt; &quot;string&quot;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   output &#123;</span><br><span class="line">       if [type]==&quot;article&quot;&#123;</span><br><span class="line">           elasticsearch &#123;</span><br><span class="line">               hosts =&gt; [&quot;localhost:9200&quot;]</span><br><span class="line">               index =&gt; &quot;article&quot;</span><br><span class="line">               document_id =&gt; &quot;%&#123;id&#125;&quot;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       stdout &#123;</span><br><span class="line">         codec =&gt; &quot;json_lines&quot;</span><br><span class="line">        &#125;      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>执行导入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/logstash -f config/input/tb_artical.conf</span><br></pre></td></tr></table></figure>
<p>此时，每秒写入约1W数据，处理两千万数据只需要半个小时，在可接受范围内。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1647080">https://cloud.tencent.com/developer/article/1647080</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/cn/downloads/logstash">https://www.elastic.co/cn/downloads/logstash</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/pengge2/article/details/114585863">https://blog.csdn.net/pengge2/article/details/114585863</a></li>
<li>LogStash性能优化 <a target="_blank" rel="noopener" href="http://www.leiyawu.com/2018/04/13/logstash%E4%BC%98%E5%8C%96/">http://www.leiyawu.com/2018/04/13/logstash%E4%BC%98%E5%8C%96/</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2020/12/10/Dubbo%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/10/Dubbo%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" class="post-title-link" itemprop="url">Dubbo的负载均衡</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-10 00:00:00" itemprop="dateCreated datePublished" datetime="2020-12-10T00:00:00+08:00">2020-12-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:03" itemprop="dateModified" datetime="2022-07-05T22:46:03+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">开发技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>负载均衡其实就是一个同样的工作任务下，对具有同样一批工作能力的人根据不同策略进行分工的一个哲学问题。不过在程序中进行任务分配就比较单纯了，在Dubbo<br>中分为这几个负载均衡策略：随机加权负载均衡、轮询加权负载均衡、最小活跃数负载均衡、一致性哈希负载均衡、还有在dubbo新版本中新增的最短响应负载均衡。比起Dubbo<br>服务的导出，引用和调用过程的源码，负载均衡的源码更值得进行研究分析，因为这些算法不仅在Dubbo中出现，在apache，nginx都有类似的算法。下面我们会逐个进行分析。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>分析负载均衡源码前，我们先了解下负载均衡的加载方式。在通过集群调用某个 inovker 之前，需要先选择出一个 invoker ，这时需要通过SPI加载一个负载均衡器，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractClusterInvoker</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> LoadBalance <span class="title">initLoadBalance</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, Invocation invocation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过配置 loadbalance 获取配置的负载均衡器，缺省配置为 random</span></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(invokers)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(invokers.get(<span class="number">0</span>).getUrl()</span><br><span class="line">                .getMethodParameter(RpcUtils.getMethodName(invocation), LOADBALANCE_KEY, DEFAULT_LOADBALANCE));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(DEFAULT_LOADBALANCE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Dubbo 中，所有负载均衡实现类均继承自 AbstractLoadBalance，该类实现了 LoadBalance 接口，并封装了一些公共的逻辑。所以在分析负载均衡实现之前，先来看一下 AbstractLoadBalance<br>的逻辑。首先来看一下负载均衡的入口方法 select，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只有一个 invoker 直接返回，无需进行负载均衡</span></span><br><span class="line">    <span class="keyword">if</span> (invokers.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 doSelect 方法进行负载均衡，该方法为抽象方法，由子类实现</span></span><br><span class="line">    <span class="keyword">return</span> doSelect(invokers, url, invocation);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取权重（在加权算法中需要此方法获取权重）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    URL url = invoker.getUrl();</span><br><span class="line">    <span class="comment">// Multiple registry scenario, load balance among multiple registries.</span></span><br><span class="line">    <span class="keyword">if</span> (REGISTRY_SERVICE_REFERENCE_PATH.equals(url.getServiceInterface())) &#123;</span><br><span class="line">        weight = url.getParameter(REGISTRY_KEY + <span class="string">&quot;.&quot;</span> + WEIGHT_KEY, DEFAULT_WEIGHT);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 通过url 获取 weight 配置，缺省配置为 100</span></span><br><span class="line">        weight = url.getMethodParameter(invocation.getMethodName(), WEIGHT_KEY, DEFAULT_WEIGHT);</span><br><span class="line">        <span class="keyword">if</span> (weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取服务的启动时间戳</span></span><br><span class="line">            <span class="keyword">long</span> timestamp = invoker.getUrl().getParameter(TIMESTAMP_KEY, <span class="number">0L</span>);</span><br><span class="line">            <span class="keyword">if</span> (timestamp &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">                <span class="comment">// 计算服务的运行时间</span></span><br><span class="line">                <span class="keyword">long</span> uptime = System.currentTimeMillis() - timestamp;</span><br><span class="line">                <span class="keyword">if</span> (uptime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获取服务预热时间 warmup ，默认为 10 分钟</span></span><br><span class="line">                <span class="keyword">int</span> warmup = invoker.getUrl().getParameter(WARMUP_KEY, DEFAULT_WARMUP);</span><br><span class="line">                <span class="keyword">if</span> (uptime &gt; <span class="number">0</span> &amp;&amp; uptime &lt; warmup) &#123;</span><br><span class="line">                    <span class="comment">// 重新计算服务权重</span></span><br><span class="line">                    weight = calculateWarmupWeight((<span class="keyword">int</span>)uptime, warmup, weight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(weight, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算预热权重</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateWarmupWeight</span><span class="params">(<span class="keyword">int</span> uptime, <span class="keyword">int</span> warmup, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算权重，下面代码逻辑上等价于 (uptime / warmup) * weight。</span></span><br><span class="line">    <span class="comment">// 随着服务运行时间 uptime 增大，权重计算值 ww 会慢慢接近配置值 weight</span></span><br><span class="line">    <span class="keyword">int</span> ww = (<span class="keyword">int</span>) ( uptime / ((<span class="keyword">float</span>) warmup / weight));</span><br><span class="line">    <span class="keyword">return</span> ww &lt; <span class="number">1</span> ? <span class="number">1</span> : (Math.min(ww, weight));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是权重的计算过程，该过程主要用于保证当服务运行时长小于服务预热时间时，对服务进行降权，避免让服务在启动之初就处于高负载状态。服务预热是一个优化手段，与此类似的还有 JVM<br>预热（<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhoufanyang_china/article/details/89888689%EF%BC%89%E3%80%82%E4%B8%BB%E8%A6%81%E7%9B%AE%E7%9A%84%E6%98%AF%E8%AE%A9%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E5%90%8E%E2%80%9C%E4%BD%8E%E5%8A%9F%E7%8E%87%E2%80%9D%E8%BF%90%E8%A1%8C%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%EF%BC%8C%E4%BD%BF%E5%85%B6%E6%95%88%E7%8E%87%E6%85%A2%E6%85%A2%E6%8F%90%E5%8D%87%E8%87%B3%E6%9C%80%E4%BD%B3%E7%8A%B6%E6%80%81%E3%80%82">https://blog.csdn.net/zhoufanyang_china/article/details/89888689）。主要目的是让服务启动后“低功率”运行一段时间，使其效率慢慢提升至最佳状态。</a></p>
<p>关于 AbstractLoadBalance 就先分析到这，接下来分析各个实现类的代码。首先，我们从 Dubbo 缺省的实现类 RandomLoadBalance 看起。</p>
<h2 id="RandomLoadBalance"><a href="#RandomLoadBalance" class="headerlink" title="RandomLoadBalance"></a>RandomLoadBalance</h2><p>RandomLoadBalance 是加权随机算法的具体实现，它的算法思想很简单。假设我们有一组服务器 servers = [A, B, C]，他们对应的权重为 weights = [5, 3, 2]<br>，权重总和为10。现在把这些权重值平铺在一维坐标值上，[0, 5) 区间属于服务器 A，[5, 8) 区间属于服务器 B，[8, 10) 区间属于服务器 C。接下来通过随机数生成器生成一个范围在 [0, 10)<br>之间的随机数，然后计算这个随机数会落到哪个区间上。比如数字3会落到服务器 A 对应的区间上，此时返回服务器 A 即可。权重越大的机器，在坐标轴上对应的区间范围就越大，<br>因此随机数生成器生成的数字就会有更大的概率落到此区间内。只要随机数生成器产生的随机数分布性很好，在经过多次选择后，每个服务器被选中的次数比例接近其权重比例。比如，经过一万次选择后，服务器 A 被选中的次数大约为5000次，服务器<br>B 被选中的次数约为3000次，服务器 C 被选中的次数约为2000次。</p>
<p>以上就是 RandomLoadBalance 背后的算法思想，比较简单。下面开始分析源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">&quot;random&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Select one invoker between a list using a random criteria</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Number of invokers</span></span><br><span class="line">        <span class="keyword">int</span> length = invokers.size();</span><br><span class="line">        <span class="comment">// Every invoker has the same weight?</span></span><br><span class="line">        <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// the weight of every invokers</span></span><br><span class="line">        <span class="keyword">int</span>[] weights = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="comment">// the first invoker&#x27;s weight</span></span><br><span class="line">        <span class="keyword">int</span> firstWeight = getWeight(invokers.get(<span class="number">0</span>), invocation);</span><br><span class="line">        weights[<span class="number">0</span>] = firstWeight;</span><br><span class="line">        <span class="comment">// The sum of weights</span></span><br><span class="line">        <span class="keyword">int</span> totalWeight = firstWeight;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> weight = getWeight(invokers.get(i), invocation);</span><br><span class="line">            <span class="comment">// save for later use</span></span><br><span class="line">            weights[i] = weight;</span><br><span class="line">            <span class="comment">// Sum</span></span><br><span class="line">            totalWeight += weight;</span><br><span class="line">            <span class="keyword">if</span> (sameWeight &amp;&amp; weight != firstWeight) &#123;</span><br><span class="line">                sameWeight = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalWeight &gt; <span class="number">0</span> &amp;&amp; !sameWeight) &#123;</span><br><span class="line">            <span class="comment">// If (not every invoker has the same weight &amp; at least one invoker&#x27;s weight&gt;0), select randomly based on totalWeight.</span></span><br><span class="line">            <span class="keyword">int</span> offset = ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class="line">            <span class="comment">// Return a invoker based on the random value.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                offset -= weights[i];</span><br><span class="line">                <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> invokers.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If all invokers have the same weight value or totalWeight=0, return evenly.</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(ThreadLocalRandom.current().nextInt(length));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RandomLoadBalance 的算法思想比较简单，在经过多次请求后，能够将调用请求按照权重值进行“均匀”分配。当然 RandomLoadBalance 也存在一定的缺点，当调用次数比较少时，Random<br>产生的随机数可能会比较集中，此时多数请求会落到同一台服务器上。这个缺点并不是很严重，多数情况下可以忽略。RandomLoadBalance 是一个简单，高效的负载均衡实现，因此 Dubbo 选择它作为缺省实现。</p>
<blockquote>
<p>思考下，如果设计一个抽奖算法，奖品分为一等奖，二等奖，三等奖，中间概率可以配置，这个场景是否和随机加权有点类似？</p>
</blockquote>
<h2 id="LeastActiveLoadBalance"><a href="#LeastActiveLoadBalance" class="headerlink" title="LeastActiveLoadBalance"></a>LeastActiveLoadBalance</h2><p>LeastActiveLoadBalance 翻译过来是最小活跃数负载均衡。活跃调用数越小，表明该服务提供者效率越高，单位时间内可处理更多的请求。此时应优先将请求分配给该服务提供者。在具体实现中，每个服务提供者对应一个活跃数<br>active。初始情况下，所有服务提供者活跃数均为0。每发起一个请求，活跃数加1，完成请求后则将活跃数减1。在服务运行一段时间后，<br>性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求、这就是最小活跃数负载均衡算法的基本思想。除了最小活跃数，LeastActiveLoadBalance<br>在实现上还引入了权重值。所以准确的来说，LeastActiveLoadBalance 是基于加权最小活跃数算法实现的。举个例子说明一下，在一个服务提供者集群中，有两个性能优异的服务提供者。某一时刻它们的活跃数相同，此时 Dubbo<br>会根据它们的权重去分配请求，权重越大，获取到新请求的概率就越大。如果两个服务提供者权重相同，此时随机选择一个即可。关于 LeastActiveLoadBalance 的背景知识就先介绍到这里，下面开始分析源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeastActiveLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">&quot;leastactive&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Number of invokers</span></span><br><span class="line">        <span class="keyword">int</span> length = invokers.size();</span><br><span class="line">        <span class="comment">// The least active value of all invokers</span></span><br><span class="line">        <span class="keyword">int</span> leastActive = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// The number of invokers having the same least active value (leastActive)</span></span><br><span class="line">        <span class="keyword">int</span> leastCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// The index of invokers having the same least active value (leastActive)</span></span><br><span class="line">        <span class="keyword">int</span>[] leastIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="comment">// the weight of every invokers</span></span><br><span class="line">        <span class="keyword">int</span>[] weights = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="comment">// The sum of the warmup weights of all the least active invokers</span></span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// The weight of the first least active invoker</span></span><br><span class="line">        <span class="keyword">int</span> firstWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// Every least active invoker has the same weight value?</span></span><br><span class="line">        <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 选择出所有最小活跃数 invokers </span></span><br><span class="line">        <span class="comment">// Filter out all the least active invokers</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            Invoker&lt;T&gt; invoker = invokers.get(i);</span><br><span class="line">            <span class="comment">// Get the active number of the invoker</span></span><br><span class="line">            <span class="keyword">int</span> active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive();</span><br><span class="line">            <span class="comment">// Get the weight of the invoker&#x27;s configuration. The default value is 100.</span></span><br><span class="line">            <span class="keyword">int</span> afterWarmup = getWeight(invoker, invocation);</span><br><span class="line">            <span class="comment">// save for later use</span></span><br><span class="line">            weights[i] = afterWarmup;</span><br><span class="line">            <span class="comment">// If it is the first invoker or the active number of the invoker is less than the current least active number</span></span><br><span class="line">            <span class="comment">// 当出现一个比所有都小的一个活跃数，则重新设置一些属性</span></span><br><span class="line">            <span class="keyword">if</span> (leastActive == -<span class="number">1</span> || active &lt; leastActive) &#123;</span><br><span class="line">                <span class="comment">// Reset the active number of the current invoker to the least active number</span></span><br><span class="line">                leastActive = active;</span><br><span class="line">                <span class="comment">// Reset the number of least active invokers</span></span><br><span class="line">                leastCount = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// Put the first least active invoker first in leastIndexes</span></span><br><span class="line">                leastIndexes[<span class="number">0</span>] = i;</span><br><span class="line">                <span class="comment">// Reset totalWeight</span></span><br><span class="line">                totalWeight = afterWarmup;</span><br><span class="line">                <span class="comment">// Record the weight the first least active invoker</span></span><br><span class="line">                firstWeight = afterWarmup;</span><br><span class="line">                <span class="comment">// Each invoke has the same weight (only one invoker here)</span></span><br><span class="line">                sameWeight = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// If current invoker&#x27;s active value equals with leaseActive, then accumulating.</span></span><br><span class="line">                <span class="comment">// 如果最小活跃数相同，则将最小活跃数的 invoker 的索引放入数组，然后累加总权重</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (active == leastActive) &#123;</span><br><span class="line">                <span class="comment">// Record the index of the least active invoker in leastIndexes order</span></span><br><span class="line">                leastIndexes[leastCount++] = i;</span><br><span class="line">                <span class="comment">// Accumulate the total weight of the least active invoker</span></span><br><span class="line">                totalWeight += afterWarmup;</span><br><span class="line">                <span class="comment">// If every invoker has the same weight?</span></span><br><span class="line">                <span class="keyword">if</span> (sameWeight &amp;&amp; afterWarmup != firstWeight) &#123;</span><br><span class="line">                    sameWeight = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Choose an invoker from all the least active invokers</span></span><br><span class="line">        <span class="keyword">if</span> (leastCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// If we got exactly one invoker having the least active value, return this invoker directly.</span></span><br><span class="line">            <span class="keyword">return</span> invokers.get(leastIndexes[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 权重不同，并且有多个最小活跃数，则进行随机加权算法选出一个 invoker </span></span><br><span class="line">        <span class="keyword">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// If (not every invoker has the same weight &amp; at least one invoker&#x27;s weight&gt;0), select randomly based on </span></span><br><span class="line">            <span class="comment">// totalWeight.</span></span><br><span class="line">            <span class="keyword">int</span> offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class="line">            <span class="comment">// Return a invoker based on the random value.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leastCount; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> leastIndex = leastIndexes[i];</span><br><span class="line">                offsetWeight -= weights[leastIndex];</span><br><span class="line">                <span class="keyword">if</span> (offsetWeight &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> invokers.get(leastIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If all invokers have the same weight value or totalWeight=0, return evenly.</span></span><br><span class="line">        <span class="comment">// 所有权重都一样，则随机选取一个 invoker</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(leastIndexes[ThreadLocalRandom.current().nextInt(leastCount)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的逻辑比较多，我们在代码中写了大量的注释，有帮助大家理解代码逻辑。下面简单总结一下以上代码所做的事情，如下：</p>
<ul>
<li>遍历 invokers 列表，寻找活跃数最小的 Invoker</li>
<li>如果有多个 Invoker 具有相同的最小活跃数，此时记录下这些 Invoker 在 invokers 集合中的下标，并累加它们的权重，比较它们的权重值是否相等</li>
<li>如果只有一个 Invoker 具有最小的活跃数，此时直接返回该 Invoker 即可</li>
<li>如果有多个 Invoker 具有最小活跃数，且它们的权重不相等，此时处理方式和 <code>RandomLoadBalance</code> 一致</li>
<li>如果有多个 Invoker 具有最小活跃数，但它们的权重相等，此时随机返回一个即可</li>
</ul>
<p>以上就是 LeastActiveLoadBalance 大致的实现逻辑，大家在阅读的源码的过程中要注意区分活跃数与权重这两个概念，不要混为一谈。</p>
<h2 id="RoundRobinLoadBalance"><a href="#RoundRobinLoadBalance" class="headerlink" title="RoundRobinLoadBalance"></a>RoundRobinLoadBalance</h2><p>我们来看一下 Dubbo 中加权轮询负载均衡的实现 RoundRobinLoadBalance。在详细分析源码前，我们先来了解一下什么是加权轮询。<br>这里从最简单的轮询开始讲起，所谓轮询是指将请求轮流分配给每台服务器。举个例子，我们有三台服务器 A、B、C。我们将第一个请求分配给服务器 A，第二个请求分配给服务器 B，第三个请求分配给服务器 C，第四个请求再次分配给服务器<br>A。这个过程就叫做轮询。轮询是一种无状态负载均衡算法，实现简单，适用于每台服务器性能相近的场景下。但现实情况下 ，我们并不能保证每台服务器性能均相近。<br>如果我们将等量的请求分配给性能较差的服务器，这显然是不合理的。因此，这个时候我们需要对轮询过程进行加权，<br>以调控每台服务器的负载。经过加权后，每台服务器能够得到的请求数比例，接近或等于他们的权重比。比如服务器 A、B、C 权重比为<br>5:2:1。那么在8次请求中，服务器 A 将收到其中的5次请求，服务器 B 会收到其中的2次请求，服务器 C 则收到其中的1次请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">&quot;roundrobin&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RECYCLE_PERIOD = <span class="number">60000</span>;<span class="comment">// 回收间隔时间 1 分钟</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 权重对象，用来记录权重和当前权重，上次更新时间戳信息</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightedRoundRobin</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">        <span class="keyword">private</span> AtomicLong current = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 上次更新时间，主要是当上次更新时间超过 RECYCLE_PERIOD = 60000 时候，则删除此权重对象，防止服务失效，长期占用</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> lastUpdate;</span><br><span class="line">        <span class="comment">// 设置权重，并初始化当前值 current</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">            current.set(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 每次增加当前权重大小</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">increaseCurrent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> current.addAndGet(weight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前值减去总值</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sel</span><span class="params">(<span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">            current.addAndGet(-<span class="number">1</span> * total);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略getter setter</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 目标方法签名和服务地址的权重轮询的映射</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt; methodWeightMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// key = 全限定类名 + &quot;.&quot; + 方法名，比如 com.xxx.DemoService.sayHello，属于方法级别key</span></span><br><span class="line">        String key = invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">&quot;.&quot;</span> + invocation.getMethodName();</span><br><span class="line">        <span class="comment">// 如果不存在则加入一个</span></span><br><span class="line">        ConcurrentMap&lt;String, WeightedRoundRobin&gt; map = methodWeightMap.computeIfAbsent(key, k -&gt; <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> maxCurrent = Long.MIN_VALUE;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        Invoker&lt;T&gt; selectedInvoker = <span class="keyword">null</span>;</span><br><span class="line">        WeightedRoundRobin selectedWRR = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="comment">// 类似 dubbo://172.0.0.1:2808/org.apache.dubbo.demo.DemoService ，属于服务级别key</span></span><br><span class="line">            String identifyString = invoker.getUrl().toIdentityString();</span><br><span class="line">            <span class="keyword">int</span> weight = getWeight(invoker, invocation);</span><br><span class="line">            WeightedRoundRobin weightedRoundRobin = map.computeIfAbsent(identifyString, k -&gt; &#123;</span><br><span class="line">                WeightedRoundRobin wrr = <span class="keyword">new</span> WeightedRoundRobin();</span><br><span class="line">                wrr.setWeight(weight);</span><br><span class="line">                <span class="keyword">return</span> wrr;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 如果权重不相等，则更新权重值</span></span><br><span class="line">            <span class="keyword">if</span> (weight != weightedRoundRobin.getWeight()) &#123;</span><br><span class="line">                <span class="comment">//weight changed</span></span><br><span class="line">                weightedRoundRobin.setWeight(weight);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前值增加一个权重</span></span><br><span class="line">            <span class="keyword">long</span> cur = weightedRoundRobin.increaseCurrent();</span><br><span class="line">            <span class="comment">// 更新时间</span></span><br><span class="line">            weightedRoundRobin.setLastUpdate(now);</span><br><span class="line">            <span class="comment">// 如果当前值大于最大当前值，则为要选择的 invoker</span></span><br><span class="line">            <span class="keyword">if</span> (cur &gt; maxCurrent) &#123;</span><br><span class="line">                maxCurrent = cur;</span><br><span class="line">                selectedInvoker = invoker;</span><br><span class="line">                selectedWRR = weightedRoundRobin;</span><br><span class="line">            &#125;</span><br><span class="line">            totalWeight += weight;<span class="comment">// 累加总权重</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当新的 invokers 数量和map缓存的不一致，则根据更新时间移除距离现在大于1分钟的 invoker</span></span><br><span class="line">        <span class="keyword">if</span> (invokers.size() != map.size()) &#123;</span><br><span class="line">            map.entrySet().removeIf(item -&gt; now - item.getValue().getLastUpdate() &gt; RECYCLE_PERIOD);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为这里是轮询，因此 选中的 invoker 的当前值将会被减去总权重</span></span><br><span class="line">        <span class="keyword">if</span> (selectedInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">            selectedWRR.sel(totalWeight);</span><br><span class="line">            <span class="keyword">return</span> selectedInvoker;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// should not happen here</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面轮询加权的算法比较难理解，但是我们列举以下计算过程就比较清晰了，假设有三台服务器[ A , B , C ] ，其对应权重为[ 3 : 2 : 1]，w 代表权重，current*<br>代表当前服务的当前值，totalWeight=3+2+1=6，每次执行 current* 都会递增一个w，然后选中的服务的current值会减去总权重totalWeight，那么按照上面算法轮询顺序如下：</p>
<table>
<thead>
<tr>
<th>次数</th>
<th>A(w=3)</th>
<th>B(w=2)</th>
<th>C(w=1)</th>
<th>选中</th>
<th>更新current</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>currentA=3</td>
<td>currentB=2</td>
<td>currentC=1</td>
<td>A</td>
<td>currentA=(3-totalWeight)=-3</td>
</tr>
<tr>
<td>2</td>
<td>currentA=0</td>
<td>currentB=4</td>
<td>currentC=2</td>
<td>B</td>
<td>currentB=(4-totalWeight)=-2</td>
</tr>
<tr>
<td>3</td>
<td>currentA=3</td>
<td>currentB=0</td>
<td>currentC=3</td>
<td>A</td>
<td>currentA=(3-totalWeight)=-3</td>
</tr>
<tr>
<td>4</td>
<td>currentA=0</td>
<td>currentB=2</td>
<td>currentC=4</td>
<td>C</td>
<td>currentC=(4-totalWeight)=-2</td>
</tr>
<tr>
<td>5</td>
<td>currentA=3</td>
<td>currentB=4</td>
<td>currentC=-1</td>
<td>B</td>
<td>currentB=(4-totalWeight)=-2</td>
</tr>
<tr>
<td>6</td>
<td>currentA=6</td>
<td>currentB=0</td>
<td>currentC=0</td>
<td>A</td>
<td>currentA=(6-totalWeight)=0</td>
</tr>
<tr>
<td>7</td>
<td>currentA=3</td>
<td>currentB=2</td>
<td>currentC=1</td>
<td>A</td>
<td>currentA=(3-totalWeight)=-3</td>
</tr>
</tbody></table>
<p>通过上面的执行过程可以发现，这种算法不仅巧妙的实现了轮询，而且还很平滑，即调用服务依次为A-B-A-C-B-A-A。</p>
<blockquote>
<p>除了上面的算法，思考下加入要求你实现轮询加权，还有没有其他的实现方式？如优先队列？计数器？或其他算法？</p>
</blockquote>
<h2 id="ConsistentHashLoadBalance"><a href="#ConsistentHashLoadBalance" class="headerlink" title="ConsistentHashLoadBalance"></a>ConsistentHashLoadBalance</h2><p>一致性 hash 算法由麻省理工学院的 Karger 及其合作作者于1997年提出的，算法提出之初是用于大规模缓存系统的负载均衡。它的工作过程是这样的，首先根据 ip 或者其他的信息为缓存节点生成一个 hash，并将这个 hash<br>投射到 [0, 2^32 - 1] 的圆环上。当有查询或写入请求时，则为缓存项的 key 生成一个 hash 值。然后查找第一个大于或等于该 hash<br>值的缓存节点，并到这个节点中查询或写入缓存项。如果当前节点挂了，则在下一次查询或写入缓存时，为缓存项查找另一个大于其 hash 值的缓存节点即可。大致效果如下图所示，每个缓存节点在圆环上占据一个位置。如果缓存项的 key 的 hash<br>值小于缓存节点 hash 值，则到该缓存节点中存储或读取缓存项。比如下面绿色点对应的缓存项将会被存储到 cache-2 节点中。由于 cache-3 挂了，原本应该存到该节点中的缓存项最终会存储到 cache-4 节点中。<br><img src="https://raw.githubusercontent.com/mvilplss/note/master/image/Dubbo%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1_images/6ae78d7e.png"><br>下面来看看一致性 hash 在 Dubbo 中的应用。我们把上图的缓存节点替换成 Dubbo 的服务提供者，于是得到了下图：<br><img src="https://raw.githubusercontent.com/mvilplss/note/master/image/Dubbo%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1_images/05058665.png"><br>这里相同颜色的节点均属于同一个服务提供者，比如 Invoker1-1，Invoker1-2，……, Invoker1-160。这样做的目的是通过引入虚拟节点，让 Invoker<br>在圆环上分散开来，避免数据倾斜问题。所谓数据倾斜是指，由于节点不够分散，导致大量请求落到了同一个节点上，而其他节点只会接收到了少量请求的情况。比如：<br><img src="https://raw.githubusercontent.com/mvilplss/note/master/image/Dubbo%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1_images/16808650.png"><br>如上，由于 Invoker-1 和 Invoker-2 在圆环上分布不均，导致系统中75%的请求都会落到 Invoker-1 上，只有 25% 的请求会落到 Invoker-2<br>上。解决这个问题办法是引入虚拟节点，通过虚拟节点均衡各个节点的请求量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">&quot;consistenthash&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HASH_NODES = <span class="string">&quot;hash.nodes&quot;</span>;<span class="comment">// 设置 hash 的虚拟节点个数，默认 160</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HASH_ARGUMENTS = <span class="string">&quot;hash.arguments&quot;</span>;<span class="comment">// 配置的 hash 计算参与的参数下标，如：0,1,2，默认0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt; selectors = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">        <span class="comment">// 类似：org.apache.dubbo.demo.DemoService.sayHello</span></span><br><span class="line">        String key = invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">&quot;.&quot;</span> + methodName;</span><br><span class="line">        <span class="comment">// using the hashcode of list to compute the hash only pay attention to the elements in the list</span></span><br><span class="line">        <span class="comment">// 获取 集合 invokers 的原始 hash 值，其目的用来判断集合是否有改变</span></span><br><span class="line">        <span class="keyword">int</span> invokersHashCode = invokers.hashCode();</span><br><span class="line">        ConsistentHashSelector&lt;T&gt; selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class="line">        <span class="comment">// 如果 selector 为 null 或者 invokers 集合有变动，则进行重新hash计算</span></span><br><span class="line">        <span class="keyword">if</span> (selector == <span class="keyword">null</span> || selector.identityHashCode != invokersHashCode) &#123;</span><br><span class="line">            <span class="comment">// 对服务列表 invokers 进行创建一个 hash 节点</span></span><br><span class="line">            ConsistentHashSelector&lt;T&gt; hashSelector = <span class="keyword">new</span> ConsistentHashSelector&lt;&gt;(invokers, methodName, invokersHashCode);</span><br><span class="line">            selectors.put(key, hashSelector);</span><br><span class="line">            selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> selector.select(invocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashSelector</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt; virtualInvokers;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> replicaNumber;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> identityHashCode;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] argumentIndex;</span><br><span class="line">        <span class="comment">// 初始化 hash 虚拟节点</span></span><br><span class="line">        ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, <span class="keyword">int</span> identityHashCode) &#123;</span><br><span class="line">            <span class="comment">// new 一个 TreeMap 用来存储 hash 和 invoker 映射</span></span><br><span class="line">            <span class="keyword">this</span>.virtualInvokers = <span class="keyword">new</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.identityHashCode = identityHashCode;</span><br><span class="line">            URL url = invokers.get(<span class="number">0</span>).getUrl();</span><br><span class="line">            <span class="comment">// 获取要创建的节点个数，缺省配置为160</span></span><br><span class="line">            <span class="keyword">this</span>.replicaNumber = url.getMethodParameter(methodName, HASH_NODES, <span class="number">160</span>);</span><br><span class="line">            <span class="comment">// 获取参与 hash 计算的参数下标</span></span><br><span class="line">            String[] index = COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, HASH_ARGUMENTS, <span class="string">&quot;0&quot;</span>));</span><br><span class="line">            argumentIndex = <span class="keyword">new</span> <span class="keyword">int</span>[index.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index.length; i++) &#123;</span><br><span class="line">                argumentIndex[i] = Integer.parseInt(index[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 进行循环服务列表，计算 hash 并设置到虚拟节点 virtualInvokers 中</span></span><br><span class="line">            <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">                <span class="comment">// 获取服务器地址，类似：127.0.0.1:8082</span></span><br><span class="line">                String address = invoker.getUrl().getAddress();</span><br><span class="line">                <span class="comment">// 循环节点的四分之一次，因为每次会进行虚拟4个节点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; replicaNumber / <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="comment">// 对地址进行+i，然后做md5计算：127.0.0.1:80820</span></span><br><span class="line">                    <span class="comment">// 对 address + i 进行 md5 运算，得到一个长度为16的字节数组</span></span><br><span class="line">                    <span class="keyword">byte</span>[] digest = md5(address + i);</span><br><span class="line">                    <span class="comment">// 对 digest 部分字节进行4次 hash 运算，得到四个不同的 long 型正整数</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">4</span>; h++) &#123;</span><br><span class="line">                        <span class="comment">// h = 0 时，取 digest 中下标为 0 ~ 3 的4个字节进行位运算</span></span><br><span class="line">                        <span class="comment">// h = 1 时，取 digest 中下标为 4 ~ 7 的4个字节进行位运算</span></span><br><span class="line">                        <span class="comment">// h = 2, h = 3 时过程同上</span></span><br><span class="line">                        <span class="keyword">long</span> m = hash(digest, h);</span><br><span class="line">                        <span class="comment">// 将 hash 到 invoker 的映射关系存储到 virtualInvokers 中，</span></span><br><span class="line">                        <span class="comment">// virtualInvokers 需要提供高效的查询操作，因此选用 TreeMap 作为存储结构</span></span><br><span class="line">                        virtualInvokers.put(m, invoker);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Invoker&lt;T&gt; <span class="title">select</span><span class="params">(Invocation invocation)</span> </span>&#123;</span><br><span class="line">            String key = toKey(invocation.getArguments());</span><br><span class="line">            <span class="keyword">byte</span>[] digest = md5(key);</span><br><span class="line">            <span class="comment">// 取 digest 数组的前四个字节进行 hash 运算，再将 hash 值传给 selectForKey 方法，</span></span><br><span class="line">            <span class="comment">// 寻找合适的 Invoker</span></span><br><span class="line">            <span class="keyword">return</span> selectForKey(hash(digest, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> String <span class="title">toKey</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : argumentIndex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; args.length) &#123;</span><br><span class="line">                    buf.append(args[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Invoker&lt;T&gt; <span class="title">selectForKey</span><span class="params">(<span class="keyword">long</span> hash)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 到 TreeMap 中查找第一个节点值大于或等于当前 hash 的 Invoker</span></span><br><span class="line">            Map.Entry&lt;Long, Invoker&lt;T&gt;&gt; entry = virtualInvokers.ceilingEntry(hash);</span><br><span class="line">            <span class="comment">// 如果 hash 大于 Invoker 在圆环上最大的位置，此时 entry = null，</span></span><br><span class="line">            <span class="comment">// 需要将 TreeMap 的头节点赋值给 entry</span></span><br><span class="line">            <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                entry = virtualInvokers.firstEntry();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [-128, 127, -128, 127, -128, 127, -128, 127, -128, 127, -128, 127, -128, 127, -128, 127]</span></span><br><span class="line">        <span class="comment">// 10000000,01111111,10000000,01111111,10000000,01111111,10000000,01111111,10000000,01111111,10000000,01111111,</span></span><br><span class="line">        <span class="comment">//        10000000,01111111,10000000,01111111</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">hash</span><span class="params">(<span class="keyword">byte</span>[] digest, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (((<span class="keyword">long</span>) (digest[<span class="number">3</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">                    | ((<span class="keyword">long</span>) (digest[<span class="number">2</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                    | ((<span class="keyword">long</span>) (digest[<span class="number">1</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">                    | (digest[number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>))</span><br><span class="line">                    &amp; <span class="number">0xFFFFFFFFL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] md5(String value) &#123;</span><br><span class="line">            MessageDigest md5;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                md5 = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            md5.reset();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = value.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">            md5.update(bytes);</span><br><span class="line">            <span class="keyword">return</span> md5.digest();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一致性hash负载均衡的难点在于理解虚拟节点的生成和根据 hash 值选择节点，也就是对treeMap数据结构的理解 和 hash 相关的位算法的理解。</p>
<h2 id="ShortestResponseLoadBalance"><a href="#ShortestResponseLoadBalance" class="headerlink" title="ShortestResponseLoadBalance"></a>ShortestResponseLoadBalance</h2><p>在2.7.7版本中由 August 贡献( <a target="_blank" rel="noopener" href="https://github.com/apache/dubbo/pull/6064">https://github.com/apache/dubbo/pull/6064</a> )，作者添加此负载理由当使用 LeastActiveLoadBalance<br>时候，如果服务直接性能差距较大时候，就可能会出现性能好的服务触发限流了，但是性能不好的服务可能还比较空闲。因此实现来一个根据服务响应快慢来做负载均衡的一个算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortestResponseLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">&quot;shortestresponse&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Number of invokers</span></span><br><span class="line">        <span class="keyword">int</span> length = invokers.size();</span><br><span class="line">        <span class="comment">// Estimated shortest response time of all invokers</span></span><br><span class="line">        <span class="keyword">long</span> shortestResponse = Long.MAX_VALUE;</span><br><span class="line">        <span class="comment">// The number of invokers having the same estimated shortest response time</span></span><br><span class="line">        <span class="keyword">int</span> shortestCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// The index of invokers having the same estimated shortest response time</span></span><br><span class="line">        <span class="keyword">int</span>[] shortestIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="comment">// the weight of every invokers</span></span><br><span class="line">        <span class="keyword">int</span>[] weights = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="comment">// The sum of the warmup weights of all the shortest response  invokers</span></span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// The weight of the first shortest response invokers</span></span><br><span class="line">        <span class="keyword">int</span> firstWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// Every shortest response invoker has the same weight value?</span></span><br><span class="line">        <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Filter out all the shortest response invokers</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            Invoker&lt;T&gt; invoker = invokers.get(i);</span><br><span class="line">            RpcStatus rpcStatus = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName());</span><br><span class="line">            <span class="comment">// Calculate the estimated response time from the product of active connections and succeeded average elapsed time.</span></span><br><span class="line">            <span class="keyword">long</span> succeededAverageElapsed = rpcStatus.getSucceededAverageElapsed();</span><br><span class="line">            <span class="keyword">int</span> active = rpcStatus.getActive();</span><br><span class="line">            <span class="keyword">long</span> estimateResponse = succeededAverageElapsed * active;</span><br><span class="line">            <span class="keyword">int</span> afterWarmup = getWeight(invoker, invocation);</span><br><span class="line">            weights[i] = afterWarmup;</span><br><span class="line">            <span class="comment">// Same as LeastActiveLoadBalance</span></span><br><span class="line">            <span class="keyword">if</span> (estimateResponse &lt; shortestResponse) &#123;</span><br><span class="line">                shortestResponse = estimateResponse;</span><br><span class="line">                shortestCount = <span class="number">1</span>;</span><br><span class="line">                shortestIndexes[<span class="number">0</span>] = i;</span><br><span class="line">                totalWeight = afterWarmup;</span><br><span class="line">                firstWeight = afterWarmup;</span><br><span class="line">                sameWeight = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (estimateResponse == shortestResponse) &#123;</span><br><span class="line">                shortestIndexes[shortestCount++] = i;</span><br><span class="line">                totalWeight += afterWarmup;</span><br><span class="line">                <span class="keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; afterWarmup != firstWeight) &#123;</span><br><span class="line">                    sameWeight = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shortestCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers.get(shortestIndexes[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shortestCount; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> shortestIndex = shortestIndexes[i];</span><br><span class="line">                offsetWeight -= weights[shortestIndex];</span><br><span class="line">                <span class="keyword">if</span> (offsetWeight &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> invokers.get(shortestIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invokers.get(shortestIndexes[ThreadLocalRandom.current().nextInt(shortestCount)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最短响应负载均衡和最少活跃数负载均衡类似，只不过是最少活跃数的计算点是响应时间，其逻辑也是先获取最少响应时间的 invokers<br>的下标，如果只有一个最少响应时间的服务就直接返回，否则判断是否权重相同，如果权重相同则随机抽取一个服务返回，否则根据权重选择一个服务然后返回。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本章内容设计到一些经典的算法，理解起来不是很难，但是千亿级的服务器的访问下就是这些负载均衡在高效稳定的分配者一个个请求到服务端，弄懂和掌握这些负载均衡的逻辑至关重要。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/#3%E6%80%BB%E7%BB%93">http://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/#3%E6%80%BB%E7%BB%93</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2020/12/09/Dubbo%E7%9A%84%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/09/Dubbo%E7%9A%84%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99/" class="post-title-link" itemprop="url">Dubbo的集群容错</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-09 00:00:00" itemprop="dateCreated datePublished" datetime="2020-12-09T00:00:00+08:00">2020-12-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:03" itemprop="dateModified" datetime="2022-07-05T22:46:03+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">开发技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>为了避免单点故障，现在的应用通常至少会部署在两台服务器上。对于一些负载比较高的服务，会部署更多的服务器。这样，在同一环境下的服务提供者数量会大于1。对于服务消费者来说，同一环境下出现了多个服务提供者。这时会出现一个问题，服务消费者需要决定选择哪个服务提供者进行调用。另外服务调用失败时的处理措施也是需要考虑的，是重试呢，还是抛出异常，亦或是只打印异常等。为了处理这些问题，Dubbo 定义了集群接口 Cluster 以及 Cluster Invoker。集群 Cluster 用途是将多个服务提供者合并为一个 Cluster Invoker，并将这个 Invoker 暴露给服务消费者。这样一来，服务消费者只需通过这个 Invoker 进行远程调用即可，至于具体调用哪个服务提供者，以及调用失败后如何处理等问题，现在都交给集群模块去处理。集群模块是服务提供者和服务消费者的中间层，为服务消费者屏蔽了服务提供者的情况，这样服务消费者就可以专心处理远程调用相关事宜。比如发请求，接受服务提供者返回的数据等。这就是集群的作用。</p>
<p>Dubbo 提供了多种集群实现，包含但不限于 Failover Cluster、Failfast Cluster 和 Failsafe Cluster 等。每种集群实现类的用途不同，接下来会一一进行分析。</p>
<h1 id="集群容错"><a href="#集群容错" class="headerlink" title="集群容错"></a>集群容错</h1><p>在对集群相关代码进行分析之前，这里有必要先来介绍一下集群容错的所有组件。包含 Cluster、Cluster Invoker、Directory、Router 和 LoadBalance 等。<br><img src="https://raw.githubusercontent.com/mvilplss/note/master/image/Dubbo%E7%9A%84%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99_images/f0369658.png"><br>集群工作过程可分为两个阶段，第一个阶段是在服务消费者初始化期间，集群 Cluster 实现类为服务消费者创建 Cluster Invoker 实例，即上图中的 merge 操作。第二个阶段是在服务消费者进行远程调用时。以 FailoverClusterInvoker 为例，该类型 Cluster Invoker 首先会调用 Directory 的 list 方法列举 Invoker 列表（可将 Invoker 简单理解为服务提供者）。Directory 的用途是保存 Invoker，可简单类比为 List<Invoker>。其实现类 RegistryDirectory 是一个动态服务目录，可感知注册中心配置的变化，它所持有的 Invoker 列表会随着注册中心内容的变化而变化。每次变化后，RegistryDirectory 会动态增删 Invoker，并调用 Router 的 route 方法进行路由，过滤掉不符合路由规则的 Invoker。当 FailoverClusterInvoker 拿到 Directory 返回的 Invoker 列表后，它会通过 LoadBalance 从 Invoker 列表中选择一个 Invoker。最后 FailoverClusterInvoker 会将参数传给 LoadBalance 选择出的 Invoker 实例的 invoke 方法，进行真正的远程调用。</p>
<p>以上就是集群工作的整个流程，这里并没介绍集群是如何容错的。Dubbo 主要提供了这样几种容错方式：</p>
<ul>
<li>Failover Cluster - 失败自动切换重试（默认）</li>
<li>Failfast Cluster - 快速失败</li>
<li>Failsafe Cluster - 安全失败</li>
<li>Failback Cluster - 失败自动恢复</li>
<li>Forking Cluster - 并行调用多个服务提供者</li>
</ul>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="Cluster实现类分析"><a href="#Cluster实现类分析" class="headerlink" title="Cluster实现类分析"></a>Cluster实现类分析</h2><p>集群接口 Cluster 和 Cluster Invoker，这两者是不同的。Cluster 是接口，而 Cluster Invoker 是一种 Invoker。服务提供者的选择逻辑，以及远程调用失败后的的处理逻辑均是封装在<br>Cluster Invoker 中。那么 Cluster 接口和相关实现类有什么用呢？用途比较简单，仅用于生成 Cluster Invoker。下面我们来看一下源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailoverCluster</span> <span class="keyword">implements</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAME = <span class="string">&quot;failover&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并返回 FailoverClusterInvoker 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FailoverClusterInvoker&lt;T&gt;(directory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，FailoverCluster 总共就包含这几行代码，用于创建 FailoverClusterInvoker 对象，很简单。下面再看一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailbackCluster</span> <span class="keyword">implements</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAME = <span class="string">&quot;failback&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并返回 FailbackClusterInvoker 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FailbackClusterInvoker&lt;T&gt;(directory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，FailbackCluster 的逻辑也是很简单，无需解释了。所以接下来，我们把重点放在各种 Cluster Invoker 上</p>
<h2 id="ClusterInvoker分析"><a href="#ClusterInvoker分析" class="headerlink" title="ClusterInvoker分析"></a>ClusterInvoker分析</h2><p>当服务消费者进行远程调用时，在执行具体的cluster invoker时，其父类的<br>AbstractClusterInvoker 的invoke方法总会被调用，这种设计思想在实际项目中也常见，即在在执行子类具体的实现方法前先执行一些共同的逻辑。</p>
<p>我们看下AbstractClusterInvoker的inovke源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">// 首先检测当前invoker是否被销毁</span></span><br><span class="line">    checkWhetherDestroyed();</span><br><span class="line">    <span class="comment">// binding attachments into invocation. 绑定附加值到invocation中</span></span><br><span class="line">    Map&lt;String, Object&gt; contextAttachments = RpcContext.getContext().getObjectAttachments();</span><br><span class="line">    <span class="keyword">if</span> (contextAttachments != <span class="keyword">null</span> &amp;&amp; contextAttachments.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        ((RpcInvocation) invocation).addObjectAttachments(contextAttachments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过服务注册表中获取可调用服务地址列表</span></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invokers = directory.list(invocation);</span><br><span class="line">    <span class="comment">// 初始化负载均衡器</span></span><br><span class="line">    LoadBalance loadbalance = initLoadBalance(invokers, invocation);</span><br><span class="line">    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class="line">    <span class="comment">// 调用具体的子类实现方法</span></span><br><span class="line">    <span class="keyword">return</span> doInvoke(invocation, invokers, loadbalance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkWhetherDestroyed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (destroyed.get()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Rpc cluster invoker for &quot;</span> + getInterface() + <span class="string">&quot; on consumer &quot;</span> + NetUtils.getLocalHost()</span><br><span class="line">                + <span class="string">&quot; use dubbo version &quot;</span> + Version.getVersion()</span><br><span class="line">                + <span class="string">&quot; is now destroyed! Can not invoke any more.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractClusterInvoker 的 invoke 方法主要是获取可用的服务列表 List<Inovker> ，然后初始化负载均衡器 LoadBalance ，最后再调用模板方法 doInvoke 进行后续操作。</p>
<h2 id="FailoverClusterInvoker"><a href="#FailoverClusterInvoker" class="headerlink" title="FailoverClusterInvoker"></a>FailoverClusterInvoker</h2><p>FailoverClusterInvoker 在调用失败时，会自动切换 Invoker 进行多次重试。默认配置下，Dubbo 会使用这个类作为缺省，重试三次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; copyInvokers = invokers;</span><br><span class="line">    checkInvokers(copyInvokers, invocation);</span><br><span class="line">    String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">    <span class="keyword">int</span> len = getUrl().getMethodParameter(methodName, RETRIES_KEY, DEFAULT_RETRIES) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        len = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// retry loop.</span></span><br><span class="line">    RpcException le = <span class="keyword">null</span>; <span class="comment">// last exception.</span></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invoked = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(copyInvokers.size()); <span class="comment">// invoked invokers.</span></span><br><span class="line">    Set&lt;String&gt; providers = <span class="keyword">new</span> HashSet&lt;String&gt;(len);<span class="comment">// 记录提供者地址，目前版本是没有用到</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            checkWhetherDestroyed();</span><br><span class="line">            <span class="comment">// 在进行重试前重新列举 Invoker，这样做的好处是，如果某个服务挂了，</span></span><br><span class="line">            <span class="comment">// 通过调用 list 可得到最新可用的 Invoker 列表</span></span><br><span class="line">            copyInvokers = list(invocation);</span><br><span class="line">            <span class="comment">// check again</span></span><br><span class="line">            checkInvokers(copyInvokers, invocation);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过负载均衡选择 Invoker，首先在未调用过的进行选择，如果都调用过则进行选择下一个。</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyInvokers, invoked);</span><br><span class="line">        <span class="comment">// 加入被调用列表，再次重试时排除已调用的 invoker</span></span><br><span class="line">        invoked.add(invoker);</span><br><span class="line">        RpcContext.getContext().setInvokers((List) invoked);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Result result = invoker.invoke(invocation);</span><br><span class="line">            <span class="keyword">if</span> (le != <span class="keyword">null</span> &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;重试日志&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.isBiz()) &#123; <span class="comment">// 判断是否是业务异常，如果是则直接抛出异常，终止重试！</span></span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            le = e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            le = <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            providers.add(invoker.getUrl().getAddress());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不知道你是否发现，并不是所有的异常都进行重试，那哪些异常是不进行重试呢？我们分析下上面的这段代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 省略重试逻辑</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.isBiz()) &#123; <span class="comment">// 判断是否是业务异常，如果是则直接抛出异常，终止重试！</span></span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">  le = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="comment">/**final**/</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNKNOWN_EXCEPTION = <span class="number">0</span>;<span class="comment">// 未知异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NETWORK_EXCEPTION = <span class="number">1</span>;<span class="comment">// 网络异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMEOUT_EXCEPTION = <span class="number">2</span>;<span class="comment">// 超时异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BIZ_EXCEPTION = <span class="number">3</span>;<span class="comment">// 业务异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FORBIDDEN_EXCEPTION = <span class="number">4</span>;<span class="comment">// 禁止异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERIALIZATION_EXCEPTION = <span class="number">5</span>;<span class="comment">// 序列化异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NO_INVOKER_AVAILABLE_AFTER_FILTER = <span class="number">6</span>;<span class="comment">// 过滤后无可用 invoker 异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIMIT_EXCEEDED_EXCEPTION = <span class="number">7</span>;<span class="comment">// 超过限制异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMEOUT_TERMINATE = <span class="number">8</span>;<span class="comment">// 终止超时异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="comment">// 判断是否是业务异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBiz</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code == BIZ_EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面我们可以清晰的知道，只有非业务异常的时候才会进行自动重试。那么现在思考一个问题：<code>如果服务端抛出一个非业务异常的RpcException，那么消费端会进行自动重试吗？</code>。</p>
<p>答案：服务端任何异常都不会触发消费端进行重试的，因为在上面 FailoverClusterInvoker 的 doInvoke 方法回去调用结果 result<br>的时候，服务端异常已经封装对象中并不会在此方法中抛出异常，而是将带有异常信息的结果传递业务调用层来处理。</p>
<h2 id="FailbackClusterInvoker"><a href="#FailbackClusterInvoker" class="headerlink" title="FailbackClusterInvoker"></a>FailbackClusterInvoker</h2><p>FailbackClusterInvoker 会在调用失败后，返回一个空结果给服务消费者。并通过定时任务对失败的调用进行重试，适合执行消息通知等操作。下面来看一下它的实现逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    Invoker&lt;T&gt; invoker = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkInvokers(invokers, invocation);</span><br><span class="line">        invoker = select(loadbalance, invocation, invokers, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Failback to invoke method &quot;</span> + invocation.getMethodName() + <span class="string">&quot;, wait for retry in background. Ignored exception: &quot;</span></span><br><span class="line">                + e.getMessage() + <span class="string">&quot;, &quot;</span>, e);</span><br><span class="line">        <span class="comment">// 将所有失败，包括业务失败都到重试计时任务中</span></span><br><span class="line">        addFailed(loadbalance, invocation, invokers, invoker);</span><br><span class="line">        <span class="comment">// 立即返回一个空结果给服务消费者</span></span><br><span class="line">        <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, <span class="keyword">null</span>, invocation); <span class="comment">// ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加重试计时任务</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addFailed</span><span class="params">(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, Invoker&lt;T&gt; lastInvoker)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (failTimer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failTimer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建一个 hash轮计时器，学习资料：https://www.cnblogs.com/eryuan/p/7955677.html</span></span><br><span class="line">                <span class="comment">// http://www.cse.wustl.edu/~cdgill/courses/cs6874/TimingWheels.ppt</span></span><br><span class="line">                failTimer = <span class="keyword">new</span> HashedWheelTimer(</span><br><span class="line">                        <span class="keyword">new</span> NamedThreadFactory(<span class="string">&quot;failback-cluster-timer&quot;</span>, <span class="keyword">true</span>),</span><br><span class="line">                        <span class="number">1</span>,</span><br><span class="line">                        TimeUnit.SECONDS, <span class="number">32</span>, failbackTasks);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个重试计时任务</span></span><br><span class="line">    RetryTimerTask retryTimerTask = <span class="keyword">new</span> RetryTimerTask(loadbalance, invocation, invokers, lastInvoker, retries, RETRY_FAILED_PERIOD);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 加入计时器中</span></span><br><span class="line">        failTimer.newTimeout(retryTimerTask, RETRY_FAILED_PERIOD, TimeUnit.SECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Failback background works error,invocation-&gt;&quot;</span> + invocation + <span class="string">&quot;, exception: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryTimerTask</span> <span class="keyword">implements</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 重试的时候，根据均衡器选一个下一个 invoker  </span></span><br><span class="line">      Invoker&lt;T&gt; retryInvoker = select(loadbalance, invocation, invokers, Collections.singletonList(lastInvoker));</span><br><span class="line">      lastInvoker = retryInvoker;</span><br><span class="line">      retryInvoker.invoke(invocation);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      logger.error(<span class="string">&quot;Failed retry to invoke method &quot;</span> + invocation.getMethodName() + <span class="string">&quot;, waiting again.&quot;</span>, e);</span><br><span class="line">      <span class="keyword">if</span> ((++retryTimes) &gt;= retries) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Failed retry times exceed threshold (&quot;</span> + retries + <span class="string">&quot;), We have to abandon, invocation-&gt;&quot;</span> + invocation);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果定时重试失败，则不超过重试次数前会再次放入重试任务中  </span></span><br><span class="line">        rePut(timeout);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rePut</span><span class="params">(Timeout timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Timer timer = timeout.timer();</span><br><span class="line">    <span class="keyword">if</span> (timer.isStop() || timeout.isCancelled()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    timer.newTimeout(timeout.task(), tick, TimeUnit.SECONDS);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是调用失败后，加入hash时间轮计时器，每间隔n秒重试一次，重试m次未成功则停止，n和m都可以配置。</p>
<h2 id="FailfastClusterInvoker"><a href="#FailfastClusterInvoker" class="headerlink" title="FailfastClusterInvoker"></a>FailfastClusterInvoker</h2><p>FailfastClusterInvoker 只会进行一次调用，失败后立即抛出异常。适用于幂等操作，比如新增记录。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    checkInvokers(invokers, invocation);</span><br><span class="line">    <span class="comment">// 选择 Invoker</span></span><br><span class="line">    Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 Invoker</span></span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RpcException &amp;&amp; ((RpcException) e).isBiz()) &#123; <span class="comment">// biz exception.</span></span><br><span class="line">            <span class="keyword">throw</span> (RpcException) e;<span class="comment">// 业务异常抛出原异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他异常抛出解析过的异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e <span class="keyword">instanceof</span> RpcException ? ((RpcException) e).getCode() : <span class="number">0</span>,</span><br><span class="line">              <span class="string">&quot;Failfast invoke providers &quot;</span> + invoker.getUrl() + <span class="string">&quot; &quot;</span> + loadbalance.getClass().getSimpleName()</span><br><span class="line">              + <span class="string">&quot; select from all providers &quot;</span> + invokers + <span class="string">&quot; for service &quot;</span> + getInterface().getName()</span><br><span class="line">              + <span class="string">&quot; method &quot;</span> + invocation.getMethodName() + <span class="string">&quot; on consumer &quot;</span> + NetUtils.getLocalHost()</span><br><span class="line">              + <span class="string">&quot; use dubbo version &quot;</span> + Version.getVersion()</span><br><span class="line">              + <span class="string">&quot;, but no luck to perform the invocation. Last error is: &quot;</span> + e.getMessage(),</span><br><span class="line">              e.getCause() != <span class="keyword">null</span> ? e.getCause() : e);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快速失败的代码比较简单，就是出现任何调用异常立即抛出异常。</p>
<h2 id="FailsafeClusterInvoker"><a href="#FailsafeClusterInvoker" class="headerlink" title="FailsafeClusterInvoker"></a>FailsafeClusterInvoker</h2><p>FailsafeClusterInvoker 是一种失败安全的 Cluster Invoker。所谓的失败安全是指，当调用过程中出现异常时，FailsafeClusterInvoker<br>仅会打印异常，而不会抛出异常。适用于写入审计日志等操作。下面分析源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkInvokers(invokers, invocation);</span><br><span class="line">        <span class="comment">// 选择 invoker</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="comment">// 打印调用异常</span></span><br><span class="line">        logger.error(<span class="string">&quot;Failsafe ignore exception: &quot;</span> + e.getMessage(), e);</span><br><span class="line">        <span class="comment">// 异常抛出空结果</span></span><br><span class="line">        <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, <span class="keyword">null</span>, invocation); <span class="comment">// ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ForkingClusterInvoker"><a href="#ForkingClusterInvoker" class="headerlink" title="ForkingClusterInvoker"></a>ForkingClusterInvoker</h2><p>ForkingClusterInvoker 会在运行时通过线程池创建多个线程，并发调用多个服务提供者。只要有一个服务提供者成功返回了结果，doInvoke 方法就会立即结束运行。ForkingClusterInvoker<br>的应用场景是在一些对实时性要求比较高读操作（注意是读操作，并行写操作可能不安全）下使用，但这将会耗费更多的资源。下面来看该类的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkingClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor = Executors.newCachedThreadPool( <span class="keyword">new</span> NamedInternalThreadFactory</span><br><span class="line">            (<span class="string">&quot;forking-cluster-timer&quot;</span>, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkInvokers(invokers, invocation);</span><br><span class="line">            <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; selected;</span><br><span class="line">            <span class="comment">// 获取 fork 的个数</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> forks = getUrl().getParameter(FORKS_KEY, DEFAULT_FORKS);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> timeout = getUrl().getParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);</span><br><span class="line">          <span class="comment">// 如果 forks 配置不合理，则直接将 invokers 赋值给 selected</span></span><br><span class="line">          <span class="keyword">if</span> (forks &lt;= <span class="number">0</span> || forks &gt;= invokers.size()) &#123;</span><br><span class="line">                selected = invokers;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                selected = <span class="keyword">new</span> ArrayList&lt;&gt;(forks);</span><br><span class="line">                <span class="keyword">while</span> (selected.size() &lt; forks) &#123;</span><br><span class="line">                    <span class="comment">// 根据均衡器和 selected 集合选择一个 invoker</span></span><br><span class="line">                    Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, selected);</span><br><span class="line">                    <span class="keyword">if</span> (!selected.contains(invoker)) &#123;</span><br><span class="line">                        <span class="comment">// 记录调用过的 invoker</span></span><br><span class="line">                        selected.add(invoker);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置调用集合到上下文</span></span><br><span class="line">            RpcContext.getContext().setInvokers((List) selected);</span><br><span class="line">            <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">            <span class="comment">// 创建一个阻塞队列</span></span><br><span class="line">            <span class="keyword">final</span> BlockingQueue&lt;Object&gt; ref = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> Invoker&lt;T&gt; invoker : selected) &#123;</span><br><span class="line">                <span class="comment">// 循环提交 invoker 到线程池中</span></span><br><span class="line">                executor.execute(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 调用 invoker</span></span><br><span class="line">                        Result result = invoker.invoke(invocation);</span><br><span class="line">                        <span class="comment">// 将返回结果放入阻塞队列中</span></span><br><span class="line">                        ref.offer(result);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        <span class="keyword">int</span> value = count.incrementAndGet();</span><br><span class="line">                        <span class="comment">// 如果全部失败，则将异常放入阻塞队列</span></span><br><span class="line">                        <span class="keyword">if</span> (value &gt;= selected.size()) &#123;</span><br><span class="line">                            ref.offer(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 等待第一个结果</span></span><br><span class="line">                Object ret = ref.poll(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">                <span class="keyword">if</span> (ret <span class="keyword">instanceof</span> Throwable) &#123;</span><br><span class="line">                    Throwable e = (Throwable) ret;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e <span class="keyword">instanceof</span> RpcException ? ((RpcException) e).getCode() : <span class="number">0</span>, <span class="string">&quot;Failed to forking invoke provider &quot;</span> + selected + <span class="string">&quot;, but no luck to perform the invocation. Last error is: &quot;</span> + e.getMessage(), e.getCause() != <span class="keyword">null</span> ? e.getCause() : e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> (Result) ret;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Failed to forking invoke provider &quot;</span> + selected + <span class="string">&quot;, but no luck to perform the invocation. Last error is: &quot;</span> + e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            RpcContext.getContext().clearAttachments();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ForkingClusterInvoker 代码也不算复杂，其原理是循环forks次数，每次通过负载均衡器和已筛选列表筛选出一个 invoker 放入 selected 中，然后再循环筛选出来的 selected<br>逐个放入到线程池，进行执行。在线程池中的任务执行完毕后放入阻塞队列，在线程池外通过阻塞队列等待第一个结果返回。</p>
<blockquote>
<p>此集群不太常用，否则还有很多优化的空间，比如所有线程共享一个线程池，阻塞队列可以独享。</p>
</blockquote>
<h2 id="BroadcastClusterInvoker"><a href="#BroadcastClusterInvoker" class="headerlink" title="BroadcastClusterInvoker"></a>BroadcastClusterInvoker</h2><p>我们再来看一下 BroadcastClusterInvoker。BroadcastClusterInvoker 会逐个调用每个服务提供者，如果其中一台报错，在循环调用结束后，BroadcastClusterInvoker<br>会抛出异常。该类通常用于通知所有提供者更新缓存或日志等本地资源信息。源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    checkInvokers(invokers, invocation);</span><br><span class="line">    RpcContext.getContext().setInvokers((List) invokers);</span><br><span class="line">    RpcException exception = <span class="keyword">null</span>;</span><br><span class="line">    Result result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 循环调用每个服务</span></span><br><span class="line">    <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = invoker.invoke(invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">            exception = e;</span><br><span class="line">            logger.warn(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            exception = <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">            logger.warn(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有异常则在最后抛出</span></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了一些常见的集群容错策略，集群容错对于 Dubbo 框架来说，是很重要的逻辑。集群模块处于服务提供者和消费者之间，对于服务消费者来说，集群可向其屏蔽服务提供者集群的情况，使其能够专心进行远程调用。除此之外，<br>通过集群模块，我们还可以对服务之间的调用链路进行编排优化，治理服务。总的来说，对于 Dubbo 而言，集群容错相关逻辑是非常重要的。想要对 Dubbo 有比较深的理解，集群容错是必须要掌握的。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh/docs/v2.7/dev/source/cluster/">http://dubbo.apache.org/zh/docs/v2.7/dev/source/cluster/</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2020/12/06/Dubbo%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/06/Dubbo%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">Dubbo的接口调用过程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-06 00:00:00" itemprop="dateCreated datePublished" datetime="2020-12-06T00:00:00+08:00">2020-12-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:03" itemprop="dateModified" datetime="2022-07-05T22:46:03+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">开发技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本篇文件我们研究dubbo服务的调用过程，即从消费端发起接口调用到服务端接收请求，然后返回到消费端结果的整个一个调用过程。</p>
<h1 id="消费端发起调用"><a href="#消费端发起调用" class="headerlink" title="消费端发起调用"></a>消费端发起调用</h1><h2 id="invoker的调用"><a href="#invoker的调用" class="headerlink" title="invoker的调用"></a>invoker的调用</h2><p>直接看在服务引用过程中被代理后的接口源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">proxy0</span> <span class="keyword">implements</span> <span class="title">ClassGenerator</span>.<span class="title">DC</span>, <span class="title">Destroyable</span>, <span class="title">EchoService</span>, <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Method[] methods;</span><br><span class="line">    <span class="keyword">private</span> InvocationHandler handler;</span><br><span class="line">    <span class="comment">// 调用sayHello，最终会委托给InvokerInvocationHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        Object[] arrobject = <span class="keyword">new</span> Object[]&#123;string&#125;;</span><br><span class="line">        Object object = <span class="keyword">this</span>.handler.invoke(<span class="keyword">this</span>, methods[<span class="number">0</span>], arrobject);</span><br><span class="line">        <span class="keyword">return</span> (String)object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxy0</span><span class="params">(InvocationHandler invocationHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = invocationHandler;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//其他代码省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面源码可知，最终调用的sayHello方法会委托给InvokerInvocationHandler增强类，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(InvokerInvocationHandler.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Invoker&lt;?&gt; invoker;</span><br><span class="line">    <span class="keyword">private</span> ConsumerModel consumerModel;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvokerInvocationHandler</span><span class="params">(Invoker&lt;?&gt; handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.invoker = handler;</span><br><span class="line">        String serviceKey = invoker.getUrl().getServiceKey();</span><br><span class="line">        <span class="keyword">if</span> (serviceKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.consumerModel = ApplicationModel.getConsumerModel(serviceKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span><span class="comment">// 消费者接口代理类拦截方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(invoker, args);</span><br><span class="line">        &#125;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        <span class="comment">// 其他代码省略...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// RPC会话类，包括rpc调用的方法，参数，返回值等属性</span></span><br><span class="line">        RpcInvocation rpcInvocation = <span class="keyword">new</span> RpcInvocation(method, invoker.getInterface().getName(), args);</span><br><span class="line">        <span class="comment">// org.apache.dubbo.demo.DemoService</span></span><br><span class="line">        String serviceKey = invoker.getUrl().getServiceKey();</span><br><span class="line">        rpcInvocation.setTargetServiceUniqueName(serviceKey);</span><br><span class="line">        <span class="keyword">if</span> (consumerModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            rpcInvocation.put(Constants.CONSUMER_MODEL, consumerModel);</span><br><span class="line">            rpcInvocation.put(Constants.METHOD_MODEL, consumerModel.getMethodModel(method));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发起调用 MockClusterInvoker.invoke</span></span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(rpcInvocation).recreate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续根据调用链传给MockClusterInvoker类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">ClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MockClusterInvoker.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Directory&lt;T&gt; directory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Invoker&lt;T&gt; invoker;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MockClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory, Invoker&lt;T&gt; invoker)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.directory = directory;</span><br><span class="line">        <span class="keyword">this</span>.invoker = invoker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他代码省略...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        Result result = <span class="keyword">null</span>;</span><br><span class="line">        String value = getUrl().getMethodParameter(invocation.getMethodName(), MOCK_KEY, Boolean.FALSE.toString()).trim();</span><br><span class="line">        <span class="keyword">if</span> (value.length() == <span class="number">0</span> || <span class="string">&quot;false&quot;</span>.equalsIgnoreCase(value)) &#123;</span><br><span class="line">            <span class="comment">// 非mock调用，继续下一个请求</span></span><br><span class="line">            result = <span class="keyword">this</span>.invoker.invoke(invocation);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value.startsWith(<span class="string">&quot;force&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;force-mock: &quot;</span> + invocation.getMethodName() + <span class="string">&quot; force-mock enabled , url : &quot;</span> + getUrl());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//force:direct mock</span></span><br><span class="line">            result = doMockInvoke(invocation, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//fail-mock</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = <span class="keyword">this</span>.invoker.invoke(invocation);</span><br><span class="line">                <span class="comment">//fix:#4585</span></span><br><span class="line">                <span class="keyword">if</span>(result.getException() != <span class="keyword">null</span> &amp;&amp; result.getException() <span class="keyword">instanceof</span> RpcException)&#123;</span><br><span class="line">                    RpcException rpcException= (RpcException)result.getException();</span><br><span class="line">                    <span class="keyword">if</span>(rpcException.isBiz())&#123;</span><br><span class="line">                        <span class="keyword">throw</span>  rpcException;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        result = doMockInvoke(invocation, rpcException);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">                <span class="comment">// 业务异常则抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (e.isBiz()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">&quot;fail-mock: &quot;</span> + invocation.getMethodName() + <span class="string">&quot; fail-mock enabled , url : &quot;</span> + getUrl(), e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 非业务异常则降级</span></span><br><span class="line">                result = doMockInvoke(invocation, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他代码省略...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">继续下一个请求，把请求传递给AbstractCluster的内部类：InterceptorInvokerNode,进行cluster拦截器的调用前后调用：</span><br><span class="line">```java</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorInvokerNode</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> AbstractClusterInvoker&lt;T&gt; clusterInvoker;</span><br><span class="line">        <span class="keyword">private</span> ClusterInterceptor interceptor;</span><br><span class="line">        <span class="keyword">private</span> AbstractClusterInvoker&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">            Result asyncResult;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 拦截器before调用，默认拦截器为：ConsumerContextClusterInterceptor，主要是对消费端的RpcContext对象上下文属性设置</span></span><br><span class="line">                interceptor.before(next, invocation);</span><br><span class="line">                <span class="comment">// 调用拦截器拦截方法，传递next(FailoverClusterInvoker实例)</span></span><br><span class="line">                asyncResult = interceptor.intercept(next, invocation);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// onError callback</span></span><br><span class="line">                <span class="keyword">if</span> (interceptor <span class="keyword">instanceof</span> ClusterInterceptor.Listener) &#123;</span><br><span class="line">                    ClusterInterceptor.Listener listener = (ClusterInterceptor.Listener) interceptor;</span><br><span class="line">                    listener.onError(e, clusterInvoker, invocation);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 拦截器after调用</span></span><br><span class="line">                interceptor.after(next, invocation);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> asyncResult.whenCompleteWithContext((r, t) -&gt; &#123;</span><br><span class="line">                <span class="comment">// onResponse callback</span></span><br><span class="line">                <span class="keyword">if</span> (interceptor <span class="keyword">instanceof</span> ClusterInterceptor.Listener) &#123;</span><br><span class="line">                    ClusterInterceptor.Listener listener = (ClusterInterceptor.Listener) interceptor;</span><br><span class="line">                    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        listener.onMessage(r, clusterInvoker, invocation);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        listener.onError(t, clusterInvoker, invocation);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用FailoverClusterInvoker.doInvoke之前，会先执行其父类的invoke方法：<br>父类：AbstractClusterInvoker</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">ClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行invoke</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        checkWhetherDestroyed();<span class="comment">// 判断是否要停机，如果要停机，则中断调用。（优雅停机）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// binding attachments into invocation.</span></span><br><span class="line">        Map&lt;String, Object&gt; contextAttachments = RpcContext.getContext().getObjectAttachments();</span><br><span class="line">        <span class="keyword">if</span> (contextAttachments != <span class="keyword">null</span> &amp;&amp; contextAttachments.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            ((RpcInvocation) invocation).addObjectAttachments(contextAttachments);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从注册表获取可调用服务地址列表</span></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation);</span><br><span class="line">        <span class="comment">// 初始化负载均衡器</span></span><br><span class="line">        LoadBalance loadbalance = initLoadBalance(invokers, invocation);</span><br><span class="line">        RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class="line">        <span class="comment">// 调用子类实现方法（默认是FailoverClusterInvoker的实例，可以通过&lt;dubbo:reference cluster=&quot;&quot; ... 指定集群）</span></span><br><span class="line">        <span class="comment">// 子类的具体实现请看下面源码</span></span><br><span class="line">        <span class="keyword">return</span> doInvoke(invocation, invokers, loadbalance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkWhetherDestroyed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed.get()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Rpc cluster invoker for &quot;</span> + getInterface() + <span class="string">&quot; on consumer &quot;</span> + NetUtils.getLocalHost()</span><br><span class="line">                    + <span class="string">&quot; use dubbo version &quot;</span> + Version.getVersion()</span><br><span class="line">                    + <span class="string">&quot; is now destroyed! Can not invoke any more.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="comment">// 最终由RegistryDirectory.doList提供服务列表，见下面的RegistryDirectory源码分析</span></span><br><span class="line">        <span class="keyword">return</span> directory.list(invocation);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据负载均衡配置通过SPI获取均衡扩展点，默认为random</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> LoadBalance <span class="title">initLoadBalance</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(invokers)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(invokers.get(<span class="number">0</span>).getUrl()</span><br><span class="line">                    .getMethodParameter(RpcUtils.getMethodName(invocation), LOADBALANCE_KEY, DEFAULT_LOADBALANCE));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(DEFAULT_LOADBALANCE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Invoker&lt;T&gt; <span class="title">select</span><span class="params">(LoadBalance loadbalance, Invocation invocation,</span></span></span><br><span class="line"><span class="function"><span class="params">                                List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String methodName = invocation == <span class="keyword">null</span> ? StringUtils.EMPTY_STRING : invocation.getMethodName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> sticky = invokers.get(<span class="number">0</span>).getUrl()</span><br><span class="line">                .getMethodParameter(methodName, CLUSTER_STICKY_KEY, DEFAULT_CLUSTER_STICKY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stickyInvoker != <span class="keyword">null</span> &amp;&amp; !invokers.contains(stickyInvoker)) &#123;</span><br><span class="line">            stickyInvoker = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sticky &amp;&amp; stickyInvoker != <span class="keyword">null</span> &amp;&amp; (selected == <span class="keyword">null</span> || !selected.contains(stickyInvoker))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (availablecheck &amp;&amp; stickyInvoker.isAvailable()) &#123;</span><br><span class="line">                <span class="keyword">return</span> stickyInvoker;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Invoker&lt;T&gt; invoker = doSelect(loadbalance, invocation, invokers, selected);</span><br><span class="line">        <span class="keyword">if</span> (sticky) &#123;</span><br><span class="line">            stickyInvoker = invoker;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(LoadBalance loadbalance, Invocation invocation,</span></span></span><br><span class="line"><span class="function"><span class="params">                                List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (invokers.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Invoker&lt;T&gt; invoker = loadbalance.select(invokers, getUrl(), invocation);</span><br><span class="line">        <span class="comment">//If the `invoker` is in the  `selected` or invoker is unavailable &amp;&amp; availablecheck is true, reselect.</span></span><br><span class="line">        <span class="keyword">if</span> ((selected != <span class="keyword">null</span> &amp;&amp; selected.contains(invoker))</span><br><span class="line">                || (!invoker.isAvailable() &amp;&amp; getUrl() != <span class="keyword">null</span> &amp;&amp; availablecheck)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果选出的invker被调用过，或者不可用，则需要重新在选择一个</span></span><br><span class="line">                Invoker&lt;T&gt; rInvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck);</span><br><span class="line">                <span class="keyword">if</span> (rInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    invoker = rInvoker;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//Check the index of current selected invoker, if it&#x27;s not the last one, choose the one at index+1.</span></span><br><span class="line">                    <span class="keyword">int</span> index = invokers.indexOf(invoker);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//Avoid collision</span></span><br><span class="line">                        invoker = invokers.get((index + <span class="number">1</span>) % invokers.size());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.warn(e.getMessage() + <span class="string">&quot; may because invokers list dynamic change, ignore.&quot;</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;cluster reselect fail reason is :&quot;</span> + t.getMessage() + <span class="string">&quot; if can not solve, you can set cluster.availablecheck=false in url&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重新选择</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Invoker&lt;T&gt; <span class="title">reselect</span><span class="params">(LoadBalance loadbalance, Invocation invocation,</span></span></span><br><span class="line"><span class="function"><span class="params">                                List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected, <span class="keyword">boolean</span> availablecheck)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Allocating one in advance, this list is certain to be used.</span></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; reselectInvokers = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">                invokers.size() &gt; <span class="number">1</span> ? (invokers.size() - <span class="number">1</span>) : invokers.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// First, try picking a invoker not in `selected`.</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (availablecheck &amp;&amp; !invoker.isAvailable()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (selected == <span class="keyword">null</span> || !selected.contains(invoker)) &#123;</span><br><span class="line">                reselectInvokers.add(invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!reselectInvokers.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> loadbalance.select(reselectInvokers, getUrl(), invocation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Just pick an available invoker using loadbalance policy</span></span><br><span class="line">        <span class="keyword">if</span> (selected != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : selected) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((invoker.isAvailable()) <span class="comment">// available first</span></span><br><span class="line">                        &amp;&amp; !reselectInvokers.contains(invoker)) &#123;</span><br><span class="line">                    reselectInvokers.add(invoker);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!reselectInvokers.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> loadbalance.select(reselectInvokers, getUrl(), invocation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractClusterInvoker集群抽象类有多个实现，包括以下几个：</p>
<ul>
<li>mock=org.apache.dubbo.rpc.cluster.support.wrapper.MockClusterWrapper</li>
<li>failover=org.apache.dubbo.rpc.cluster.support.FailoverCluster</li>
<li>failfast=org.apache.dubbo.rpc.cluster.support.FailfastCluster</li>
<li>failsafe=org.apache.dubbo.rpc.cluster.support.FailsafeCluster</li>
<li>failback=org.apache.dubbo.rpc.cluster.support.FailbackCluster</li>
<li>forking=org.apache.dubbo.rpc.cluster.support.ForkingCluster</li>
<li>available=org.apache.dubbo.rpc.cluster.support.AvailableCluster</li>
<li>mergeable=org.apache.dubbo.rpc.cluster.support.MergeableCluster</li>
<li>broadcast=org.apache.dubbo.rpc.cluster.support.BroadcastCluster</li>
<li>zone-aware=org.apache.dubbo.rpc.cluster.support.registry.ZoneAwareCluster<br>每个具体实现会在后续的文章进行介绍，本次只简单介绍下FailoverCluster的源码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailoverClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(FailoverClusterInvoker.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FailoverClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(directory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此集群实现逻辑是：在调用失败后，根据重试次数进行更换其他服务进行重试，一般用在只读的场景。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; copyInvokers = invokers;</span><br><span class="line">        String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">        <span class="comment">// 获取重试次数</span></span><br><span class="line">        <span class="keyword">int</span> len = getUrl().getMethodParameter(methodName, RETRIES_KEY, DEFAULT_RETRIES) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            len = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// retry loop.</span></span><br><span class="line">        RpcException le = <span class="keyword">null</span>; <span class="comment">// last exception.</span></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invoked = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(copyInvokers.size()); <span class="comment">// invoked invokers.</span></span><br><span class="line">        Set&lt;String&gt; providers = <span class="keyword">new</span> HashSet&lt;String&gt;(len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//Reselect before retry to avoid a change of candidate `invokers`.</span></span><br><span class="line">            <span class="comment">//<span class="doctag">NOTE:</span> if `invokers` changed, then `invoked` also lose accuracy.</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 检测是否要停机</span></span><br><span class="line">                <span class="keyword">super</span>.checkWhetherDestroyed();</span><br><span class="line">                <span class="comment">// 重新获取服务列表</span></span><br><span class="line">                copyInvokers = <span class="keyword">super</span>.list(invocation);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用父类根据负载均衡，排除被调用过的服务筛选出一个invoker</span></span><br><span class="line">            Invoker&lt;T&gt; invoker = <span class="keyword">super</span>.select(loadbalance, invocation, copyInvokers, invoked);</span><br><span class="line">            <span class="comment">// 加入已调用</span></span><br><span class="line">            invoked.add(invoker);</span><br><span class="line">            <span class="comment">// 设置当前线程到上下文</span></span><br><span class="line">            RpcContext.getContext().setInvokers((List) invoked);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 到这里，我们获取到最终的invoker，其结构如下：</span></span><br><span class="line">                <span class="comment">// InvokerWrapper.invoke</span></span><br><span class="line">                <span class="comment">// &gt; ProtocolFilterWrapper$1.invoke 进行过滤器调用链</span></span><br><span class="line">                <span class="comment">//  &gt; ListenerInvokerWrapper.invoke</span></span><br><span class="line">                <span class="comment">//   &gt; AsyncToSyncInvoker.invoke 默认结果是通过CompletableFuture异步获取的，转同步则通过调用get获取</span></span><br><span class="line">                <span class="comment">//    &gt; DubboInvoker.super.invoke</span></span><br><span class="line">                Result result = invoker.invoke(invocation);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.isBiz()) &#123; <span class="comment">// biz exception.</span></span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">                le = e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                le = <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                providers.add(invoker.getUrl().getAddress());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
稍微看下异步转同步的相关源码，这样在最后返回结果的时候不会迷茫:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取到Future</span></span><br><span class="line">    Result asyncResult = invoker.invoke(invocation);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (InvokeMode.SYNC == ((RpcInvocation) invocation).getInvokeMode()) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * NOTICE!</span></span><br><span class="line"><span class="comment">             * must call &#123;<span class="doctag">@link</span> java.util.concurrent.CompletableFuture#get(long, TimeUnit)&#125; because</span></span><br><span class="line"><span class="comment">             * &#123;<span class="doctag">@link</span> java.util.concurrent.CompletableFuture#get()&#125; was proved to have serious performance drop.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// AsyncRpcResult.get </span></span><br><span class="line">            asyncResult.get(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> asyncResult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AsyncRpcResult.get源码：</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executor != <span class="keyword">null</span> &amp;&amp; executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">        ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;</span><br><span class="line">        <span class="comment">// 等待执行结果执行完毕，然后才会调用下面的responseFuture.get</span></span><br><span class="line">        threadlessExecutor.waitAndDrain();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> responseFuture.get(timeout, unit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ThreadlessExecutor.waitAndDrain源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitAndDrain</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Runnable runnable = queue.take();</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        waiting = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 等待一个结果执行完毕</span></span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125;</span><br><span class="line">    runnable = queue.poll();</span><br><span class="line">    <span class="keyword">while</span> (runnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.info(t);</span><br><span class="line">        &#125;</span><br><span class="line">        runnable = queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    finished = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>下面我们将略过过滤器调用链，直接分析AbstractInvoker和DubboInvoker源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; attachment;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> available = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean destroyed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 先调用invoke方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation inv)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 完善RpcInvocation属性</span></span><br><span class="line">        RpcInvocation invocation = (RpcInvocation) inv;</span><br><span class="line">        invocation.setInvoker(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmptyMap(attachment)) &#123;</span><br><span class="line">            invocation.addObjectAttachmentsIfAbsent(attachment);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, Object&gt; contextAttachments = RpcContext.getContext().getObjectAttachments();</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmptyMap(contextAttachments)) &#123;</span><br><span class="line">            invocation.addObjectAttachments(contextAttachments);</span><br><span class="line">        &#125;</span><br><span class="line">        invocation.setInvokeMode(RpcUtils.getInvokeMode(url, invocation));</span><br><span class="line">        RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class="line">        AsyncRpcResult asyncResult;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 发起调用</span></span><br><span class="line">            asyncResult = (AsyncRpcResult) doInvoke(invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123; <span class="comment">// biz exception</span></span><br><span class="line">            Throwable te = e.getTargetException();</span><br><span class="line">            <span class="keyword">if</span> (te == <span class="keyword">null</span>) &#123;</span><br><span class="line">                asyncResult = AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e, invocation);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (te <span class="keyword">instanceof</span> RpcException) &#123;</span><br><span class="line">                    ((RpcException) te).setCode(RpcException.BIZ_EXCEPTION);</span><br><span class="line">                &#125;</span><br><span class="line">                asyncResult = AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, te, invocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.isBiz()) &#123;</span><br><span class="line">                asyncResult = AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e, invocation);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            asyncResult = AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e, invocation);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置响应future到当前线程上下文</span></span><br><span class="line">        RpcContext.getContext().setFuture(<span class="keyword">new</span> FutureAdapter(asyncResult.getResponseFuture()));</span><br><span class="line">        <span class="keyword">return</span> asyncResult;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取线程池执行器，默认是fixed，其他还有（cached，limited，eager），可以通过threadpool=fixed来定制</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ExecutorService <span class="title">getCallbackExecutor</span><span class="params">(URL url, Invocation inv)</span> </span>&#123;</span><br><span class="line">        ExecutorService sharedExecutor = ExtensionLoader.getExtensionLoader(ExecutorRepository.class).getDefaultExtension().getExecutor(url);</span><br><span class="line">        <span class="keyword">if</span> (InvokeMode.SYNC == RpcUtils.getInvokeMode(getUrl(), inv)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ThreadlessExecutor(sharedExecutor);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sharedExecutor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractInvoker根据不同的协议有多个实现包括dubboInvoker，redisInvoker，thriftInvoker，grpcInvoker等，我们这次简单研究下dubboInvoker的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExchangeClient[] clients;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicPositiveInteger index = <span class="keyword">new</span> AtomicPositiveInteger();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String version;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock destroyLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Invoker&lt;?&gt;&gt; invokers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 设置调用服务的全限定路径（path -&gt; org.apache.dubbo.demo.DemoService）和版本号</span></span><br><span class="line">        RpcInvocation inv = (RpcInvocation) invocation;</span><br><span class="line">        <span class="keyword">final</span> String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">        inv.setAttachment(PATH_KEY, getUrl().getPath());</span><br><span class="line">        inv.setAttachment(VERSION_KEY, version);</span><br><span class="line">        <span class="comment">// 选择一个交换器客户端，默认是一个，需要多个可以通过conections=n定制</span></span><br><span class="line">        ExchangeClient currentClient;</span><br><span class="line">        <span class="keyword">if</span> (clients.length == <span class="number">1</span>) &#123;</span><br><span class="line">            currentClient = clients[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentClient = clients[index.getAndIncrement() % clients.length];<span class="comment">// 多个进行轮训获取</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断是否是单程访问</span></span><br><span class="line">            <span class="keyword">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);</span><br><span class="line">            <span class="keyword">int</span> timeout = calculateTimeout(invocation, methodName);</span><br><span class="line">            <span class="keyword">if</span> (isOneway) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class="keyword">false</span>);</span><br><span class="line">                currentClient.send(inv, isSent);</span><br><span class="line">                <span class="comment">// 单向立即返回空结果</span></span><br><span class="line">                <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(invocation);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 获取业务线程池执行器，此处获取的是ThreadLessExecutor，内部包装了一个默认是cached线程池和自己内部的一个阻塞队列，主要是为了实现异步转同步调用</span></span><br><span class="line">                ExecutorService executor = getCallbackExecutor(getUrl(), inv);</span><br><span class="line">                <span class="comment">// 最终由交换器（ReferenceCountExchangeClient为起点逐步执行）发起请求</span></span><br><span class="line">                CompletableFuture&lt;Object&gt; request = currentClient.request(inv, timeout, executor);</span><br><span class="line">                <span class="comment">// 结果进行类型转换</span></span><br><span class="line">                CompletableFuture&lt;AppResponse&gt; appResponseFuture = request.thenApply(obj -&gt; (AppResponse) obj);</span><br><span class="line">                <span class="comment">// save for 2.6.x compatibility, for example, TraceFilter in Zipkin uses com.alibaba.xxx.FutureAdapter</span></span><br><span class="line">                FutureContext.getContext().setCompatibleFuture(appResponseFuture);</span><br><span class="line">                AsyncRpcResult result = <span class="keyword">new</span> AsyncRpcResult(appResponseFuture, inv);</span><br><span class="line">                result.setExecutor(executor);</span><br><span class="line">                <span class="comment">// 返回异步结果，最终由异步结果根据url转换成同步，通过result.get()获取最终返回结果</span></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.TIMEOUT_EXCEPTION, <span class="string">&quot;Invoke remote method timeout. method: &quot;</span> + invocation.getMethodName() + <span class="string">&quot;, provider: &quot;</span> + getUrl() + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.NETWORK_EXCEPTION, <span class="string">&quot;Failed to invoke remote method: &quot;</span> + invocation.getMethodName() + <span class="string">&quot;, provider: &quot;</span> + getUrl() + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">super</span>.isAvailable()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ExchangeClient client : clients) &#123;</span><br><span class="line">            <span class="keyword">if</span> (client.isConnected() &amp;&amp; !client.hasAttribute(Constants.CHANNEL_ATTRIBUTE_READONLY_KEY)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此我们整个invoker的调用执行分析完毕，大致调用流程为：</p>
<ul>
<li>proxy0.sayHello                   代理类执行</li>
<li>InvokerInvocationHandler.invoke   代理类增强器执行</li>
<li>MockClusterInvoker.invoke mock    集群执行</li>
<li>AbstractCluster$InterceptorInvokerNode.invoke 执行cluster拦截器</li>
<li>FailoverClusterInvoker.doInvoke   容错集群执行</li>
<li>InvokerWrapper.invoke             invoker包装类</li>
<li>ProtocolFilterWrapper$1.invoke    进行过滤器调用链</li>
<li>ListenerInvokerWrapper.invoke     执行监听wrapper</li>
<li>AsyncToSyncInvoker.invoke         结果获取异步转同步</li>
<li>DubboInvoker.doInvoke             最终交给交换器发起request请求</li>
</ul>
<h2 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h2><ol>
<li>ReferenceCountExchangeClient.request 引用计数器交换器，只做当前被调用服务引用个数的统计</li>
<li>HeaderExchangeClient.request 初始化头协议通道<code>所谓头协议，是因为协议的参数放在请求头中</code></li>
<li>HeaderExchangeChannel.request 将请求数据封装Request，然后将Request，channel，线程池执行器excutor封装到DefaultFuture（里面封装了id和DefaultFuture映射）</li>
<li>NettyClient.send 根据netty的NioSocketChannel获取或创建dubbo定义的NettyChannel</li>
<li>NettyChannel.send 内部发送数据是通过netty的NioSocketChannel进行发送<br>看下HeaderExchangeChannel封装的Request对象：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Object&gt; <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout, ExecutorService executor)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>.getLocalAddress(), <span class="keyword">null</span>, <span class="string">&quot;Failed to send request &quot;</span> + request + <span class="string">&quot;, cause: The channel &quot;</span> + <span class="keyword">this</span> + <span class="string">&quot; is closed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// create request.</span></span><br><span class="line">    Request req = <span class="keyword">new</span> Request();</span><br><span class="line">    req.setVersion(Version.getProtocolVersion());<span class="comment">// 设置协议版本号</span></span><br><span class="line">    req.setTwoWay(<span class="keyword">true</span>);<span class="comment">// 设置双向为true</span></span><br><span class="line">    req.setData(request);<span class="comment">// 设置RpcInvocation对象</span></span><br><span class="line">    <span class="comment">// 创建一个future</span></span><br><span class="line">    DefaultFuture future = DefaultFuture.newFuture(channel, req, timeout, executor);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 继续传递</span></span><br><span class="line">        channel.send(req);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">        future.cancel();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
最终经过多次调用，会经过NettyChannel的send方法:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="comment">// whether the channel is closed</span></span><br><span class="line">    <span class="keyword">super</span>.send(message, sent);<span class="comment">// 调用父类抽象方法判断客户端是否已经关闭了</span></span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用netty的io.netty.channel.socket.nio.NioSocketChannel.writeAndFlush方法进行发送数据</span></span><br><span class="line">        ChannelFuture future = channel.writeAndFlush(message);</span><br><span class="line">        <span class="keyword">if</span> (sent) &#123;</span><br><span class="line">            <span class="comment">// wait timeout ms</span></span><br><span class="line">            timeout = getUrl().getPositiveParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);</span><br><span class="line">            success = future.await(timeout);</span><br><span class="line">        &#125;</span><br><span class="line">        Throwable cause = future.cause();</span><br><span class="line">        <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> cause;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        removeChannelIfDisconnected(channel);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">&quot;Failed to send message &quot;</span> + PayloadDropper.getRequestWithoutData(message) + <span class="string">&quot; to &quot;</span> + getRemoteAddress() + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">&quot;Failed to send message &quot;</span> + PayloadDropper.getRequestWithoutData(message) + <span class="string">&quot; to &quot;</span> + getRemoteAddress()</span><br><span class="line">                + <span class="string">&quot;in timeout(&quot;</span> + timeout + <span class="string">&quot;ms) limit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>将我们封装好的Request做为message通过netty.NioSocketChannel.writeAndFlush准备发送到服务端，不过在发送之前，我们需要要对message进行编码。还记得吗？我们在引用服务创建的netty客户端的时候已经设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> NettyClientHandler nettyClientHandler = <span class="keyword">new</span> NettyClientHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">    bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">    <span class="comment">// 这里的netty配置可以参考：https://netty.io/wiki/</span></span><br><span class="line">    bootstrap.group(NIO_EVENT_LOOP_GROUP)</span><br><span class="line">            .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">            .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">            .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)</span><br><span class="line">            .channel(socketChannelClass());</span><br><span class="line">    bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, Math.max(<span class="number">3000</span>, getConnectTimeout()));</span><br><span class="line">    bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> heartbeatInterval = UrlUtils.getHeartbeat(getUrl());</span><br><span class="line">            <span class="comment">// 新版加入的ssl支持</span></span><br><span class="line">            <span class="keyword">if</span> (getUrl().getParameter(SSL_ENABLED_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                ch.pipeline().addLast(<span class="string">&quot;negotiation&quot;</span>, SslHandlerInitializer.sslClientHandler(getUrl(), nettyClientHandler));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里是我们关注的重点🌟</span></span><br><span class="line">            <span class="comment">// 通过NettyCodecAdapter设置解码器decoder，编码器encoder，事件处理器handler</span></span><br><span class="line">            <span class="comment">// 当netty发送数据前首先会调用encoder进行对要发送的object进行编码，接收到消息后会进行调用decoder进行解码，最后再调用handler。</span></span><br><span class="line">            NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyClient.<span class="keyword">this</span>);</span><br><span class="line">            ch.pipeline()</span><br><span class="line">                    .addLast(<span class="string">&quot;decoder&quot;</span>, adapter.getDecoder())<span class="comment">// ByteToMessageDecoder</span></span><br><span class="line">                    .addLast(<span class="string">&quot;encoder&quot;</span>, adapter.getEncoder())<span class="comment">// MessageToByteEncoder</span></span><br><span class="line">                    .addLast(<span class="string">&quot;client-idle-handler&quot;</span>, <span class="keyword">new</span> IdleStateHandler(heartbeatInterval, <span class="number">0</span>, <span class="number">0</span>, MILLISECONDS))</span><br><span class="line">                    .addLast(<span class="string">&quot;handler&quot;</span>, nettyClientHandler);</span><br><span class="line"></span><br><span class="line">            String socksProxyHost = ConfigUtils.getProperty(SOCKS_PROXY_HOST);</span><br><span class="line">            <span class="keyword">if</span>(socksProxyHost != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> socksProxyPort = Integer.parseInt(ConfigUtils.getProperty(SOCKS_PROXY_PORT, DEFAULT_SOCKS_PROXY_PORT));</span><br><span class="line">                Socks5ProxyHandler socks5ProxyHandler = <span class="keyword">new</span> Socks5ProxyHandler(<span class="keyword">new</span> InetSocketAddress(socksProxyHost, socksProxyPort));</span><br><span class="line">                ch.pipeline().addFirst(socks5ProxyHandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为这是客户端发送数据，所以发送前会执行InternalEncoder进行编码，这里只针对dubbo协议的编码进行介绍：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编码器</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Object msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 对byteBuf包装</span></span><br><span class="line">        org.apache.dubbo.remoting.buffer.ChannelBuffer buffer = <span class="keyword">new</span> NettyBackedChannelBuffer(out);</span><br><span class="line">        <span class="comment">// 获取 io.netty.channel.socket.nio.NioSocketChannel</span></span><br><span class="line">        Channel ch = ctx.channel();</span><br><span class="line">        <span class="comment">// 根据spi获取NettyChannel</span></span><br><span class="line">        NettyChannel channel = NettyChannel.getOrAddChannel(ch, url, handler);</span><br><span class="line">        <span class="comment">// 交给DubboCountCodec</span></span><br><span class="line">        codec.encode(channel, buffer, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中DubboCountCodec主要作用是用来解决接收数据时候数据包的问题，在接收数据的时候会直接交给DubboCodec，首先会执行DubboCodec的父类ExchangeCodec.encode的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(Channel channel, ChannelBuffer buffer, Object msg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是请求数据还是响应数据</span></span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">        encodeRequest(channel, buffer, (Request) msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">        encodeResponse(channel, buffer, (Response) msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.encode(channel, buffer, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们这次是发送数据，因此会进入encodeRequest方法进行真正的编码，我们分析编码先了解下dubbo的协议：<br><img src="https://raw.githubusercontent.com/mvilplss/note/master/image/.Dubbo%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B_images/c28fb30f.png"><br>Dubbo 数据包分为消息头和消息体，消息头用于存储一些元信息，比如魔数（Magic），数据包类型（Request/Response），消息体长度（Data Length）等。消息体中用于存储具体的调用消息，比如方法名称，参数列表等。下面简单列举一下消息头的内容。<br>|偏移量(Bit)    |字段    |取值    |<br>| ————– | ————– | ————– |<br>|0 ~ 7    |魔数高位|    0xda00   |<br>|8 ~ 15    |魔数低位|    0xbb    |<br>|16    |数据包类型|    0 - Response, 1 - Request        |<br>|17    |调用方式|    仅在第16位被设为1的情况下有效，0 - 单向调用，1 - 双向调用     |<br>|18    |事件标识|    0 - 当前数据包是请求或响应包，1 - 当前数据包是心跳包    |<br>|19 ~ 23    |序列化器编号|    2 - Hessian2Serialization   3 - JavaSerialization  4 - CompactedJavaSerialization  6 - FastJsonSerialization  7 - NativeJavaSerialization  8 - KryoSerialization  9 - FstSerialization    |<br>|24 ~ 31|    状态    |20 - OK |<br>|30 - CLIENT_TIMEOUT 31 - SERVER_TIMEOUT  40 - BAD_REQUEST  50 - BAD_RESPONSE  |<br>|32 ~ 95|    请求编号|    共8字节，运行时生成 |<br>|96 ~ 127|    消息体长度|    运行时计算 |</p>
<p>然后我们再看下面的编码就会很轻松：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编码：</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeRequest</span><span class="params">(Channel channel, ChannelBuffer buffer, Request req)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 首先会通过SPI获取序列化扩展点，默认：hessian2</span></span><br><span class="line">    Serialization serialization = getSerialization(channel);</span><br><span class="line">    <span class="comment">// header. 设置请求头16位</span></span><br><span class="line">    <span class="keyword">byte</span>[] header = <span class="keyword">new</span> <span class="keyword">byte</span>[HEADER_LENGTH];</span><br><span class="line">    <span class="comment">// set magic number.：0xdabb 魔法数字，类似Java的0xCAFEBABE</span></span><br><span class="line">    Bytes.short2bytes(MAGIC, header);</span><br><span class="line">    <span class="comment">// set request and serialization flag. 设置序列号类型标识</span></span><br><span class="line">    header[<span class="number">2</span>] = (<span class="keyword">byte</span>) (FLAG_REQUEST | serialization.getContentTypeId());</span><br><span class="line">    <span class="keyword">if</span> (req.isTwoWay()) &#123;</span><br><span class="line">        header[<span class="number">2</span>] |= FLAG_TWOWAY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (req.isEvent()) &#123;</span><br><span class="line">        header[<span class="number">2</span>] |= FLAG_EVENT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set request id. 请求ID</span></span><br><span class="line">    Bytes.long2bytes(req.getId(), header, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// encode request data.</span></span><br><span class="line">    <span class="keyword">int</span> savedWriteIndex = buffer.writerIndex();</span><br><span class="line">    buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);<span class="comment">// 设置请求头16字节位置，占用宽度</span></span><br><span class="line">    <span class="comment">// 对buffer包装，在请求头后面写入序列化数据</span></span><br><span class="line">    ChannelBufferOutputStream bos = <span class="keyword">new</span> ChannelBufferOutputStream(buffer);</span><br><span class="line">    ObjectOutput out = serialization.serialize(channel.getUrl(), bos);</span><br><span class="line">    <span class="keyword">if</span> (req.isEvent()) &#123;</span><br><span class="line">        encodeEventData(channel, out, req.getData());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        encodeRequestData(channel, out, req.getData(), req.getVersion());</span><br><span class="line">    &#125;</span><br><span class="line">    out.flushBuffer();</span><br><span class="line">    <span class="keyword">if</span> (out <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">        ((Cleanable) out).cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">    bos.flush();</span><br><span class="line">    bos.close();</span><br><span class="line">    <span class="keyword">int</span> len = bos.writtenBytes();</span><br><span class="line">    checkPayload(channel, len);<span class="comment">// 检测数据长度是否超过默认的8M</span></span><br><span class="line">    Bytes.int2bytes(len, header, <span class="number">12</span>);<span class="comment">// 将body长度写入header</span></span><br><span class="line">    <span class="comment">// write </span></span><br><span class="line">    buffer.writerIndex(savedWriteIndex); <span class="comment">// 写入开始位置</span></span><br><span class="line">    buffer.writeBytes(header); <span class="comment">// write header. 写入请求头</span></span><br><span class="line">    buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len); <span class="comment">// 写入结束位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，我们已经将请求发送到了服务端，服务端的具体会在下面单独分析，我们继续分析消费端获取到响应后的操作。首先肯定是netty收到返回数据时候先调用解码器进行响应数据解码NettyCodecAdapter$InternalDecoder：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解码器</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf input, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 对返回数据包装</span></span><br><span class="line">        ChannelBuffer message = <span class="keyword">new</span> NettyBackedChannelBuffer(input);</span><br><span class="line">        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);</span><br><span class="line">        <span class="comment">// decode object.</span></span><br><span class="line">        <span class="comment">// 循环获取数据</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 获取数据的起始下标</span></span><br><span class="line">            <span class="keyword">int</span> saveReaderIndex = message.readerIndex();</span><br><span class="line">            <span class="comment">// 调用DubboCountCodec.decode</span></span><br><span class="line">            Object msg = codec.decode(channel, message);</span><br><span class="line">            <span class="keyword">if</span> (msg == Codec2.DecodeResult.NEED_MORE_INPUT) &#123;</span><br><span class="line">                message.readerIndex(saveReaderIndex);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//is it possible to go here ?</span></span><br><span class="line">                <span class="keyword">if</span> (saveReaderIndex == message.readerIndex()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Decode without read data.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    out.add(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (message.readable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DubboCountCodec.decode源码如下，主要是将接收多个消息然后封装到MultiMessage对象中，最终还是委托给DubboCodec来解码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, ChannelBuffer buffer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> save = buffer.readerIndex();</span><br><span class="line">    MultiMessage result = MultiMessage.create();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        Object obj = codec.decode(channel, buffer);</span><br><span class="line">        <span class="keyword">if</span> (Codec2.DecodeResult.NEED_MORE_INPUT == obj) &#123;</span><br><span class="line">            buffer.readerIndex(save);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.addMessage(obj);</span><br><span class="line">            logMessageLength(obj, buffer.readerIndex() - save);</span><br><span class="line">            save = buffer.readerIndex();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (result.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Codec2.DecodeResult.NEED_MORE_INPUT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DubboCodec的解码方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此方法只是先对head进行读取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, ChannelBuffer buffer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> readable = buffer.readableBytes();</span><br><span class="line">    <span class="keyword">byte</span>[] header = <span class="keyword">new</span> <span class="keyword">byte</span>[Math.min(readable, HEADER_LENGTH)];</span><br><span class="line">    buffer.readBytes(header);</span><br><span class="line">    <span class="keyword">return</span> decode(channel, buffer, readable, header);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解码前数据包校验</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(Channel channel, ChannelBuffer buffer, <span class="keyword">int</span> readable, <span class="keyword">byte</span>[] header)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// check magic number. 根据版本号来判断是否正常，非正常情况交给父类TelnetCodec处理</span></span><br><span class="line">    <span class="keyword">if</span> (readable &gt; <span class="number">0</span> &amp;&amp; header[<span class="number">0</span>] != MAGIC_HIGH || readable &gt; <span class="number">1</span> &amp;&amp; header[<span class="number">1</span>] != MAGIC_LOW) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = header.length;</span><br><span class="line">        <span class="keyword">if</span> (header.length &lt; readable) &#123;</span><br><span class="line">            header = Bytes.copyOf(header, readable);</span><br><span class="line">            buffer.readBytes(header, length, readable - length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; header.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (header[i] == MAGIC_HIGH &amp;&amp; header[i + <span class="number">1</span>] == MAGIC_LOW) &#123;</span><br><span class="line">                buffer.readerIndex(buffer.readerIndex() - header.length + i);</span><br><span class="line">                header = Bytes.copyOf(header, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 父类TelnetCodec</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.decode(channel, buffer, readable, header);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check length. 判断请求头是否缺包</span></span><br><span class="line">    <span class="keyword">if</span> (readable &lt; HEADER_LENGTH) &#123;</span><br><span class="line">        <span class="keyword">return</span> DecodeResult.NEED_MORE_INPUT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get data length. 获取body长度</span></span><br><span class="line">    <span class="keyword">int</span> len = Bytes.bytes2int(header, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    checkPayload(channel, len);<span class="comment">// 检测长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tt = len + HEADER_LENGTH;</span><br><span class="line">    <span class="keyword">if</span> (readable &lt; tt) &#123; <span class="comment">// 判断总数据长度是否缺包</span></span><br><span class="line">        <span class="keyword">return</span> DecodeResult.NEED_MORE_INPUT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// limit input stream.读取固定长度的数据</span></span><br><span class="line">    ChannelBufferInputStream is = <span class="keyword">new</span> ChannelBufferInputStream(buffer, len);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> decodeBody(channel, is, header);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对数据体进行解码，然后返回Request/Response对象</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">decodeBody</span><span class="params">(Channel channel, InputStream is, <span class="keyword">byte</span>[] header)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> flag = header[<span class="number">2</span>], <span class="comment">// 数据包类型 0 - Response, 1 - Request</span></span><br><span class="line">        proto = (<span class="keyword">byte</span>) (flag &amp; SERIALIZATION_MASK);</span><br><span class="line">    <span class="comment">// get request id.</span></span><br><span class="line">    <span class="keyword">long</span> id = Bytes.bytes2long(header, <span class="number">4</span>);<span class="comment">// 获取请求id</span></span><br><span class="line">    <span class="keyword">if</span> ((flag &amp; FLAG_REQUEST) == <span class="number">0</span>) &#123;<span class="comment">// 当时响应为：flag=2，FLAG_REQUEST=-128，此处暂时看不懂！</span></span><br><span class="line">        <span class="comment">// decode response. </span></span><br><span class="line">        Response res = <span class="keyword">new</span> Response(id);<span class="comment">// 封装数据到response中</span></span><br><span class="line">        <span class="keyword">if</span> ((flag &amp; FLAG_EVENT) != <span class="number">0</span>) &#123;</span><br><span class="line">            res.setEvent(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// get status.</span></span><br><span class="line">        <span class="keyword">byte</span> status = header[<span class="number">3</span>];<span class="comment">// 20为ok</span></span><br><span class="line">        res.setStatus(status);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (status == Response.OK) &#123;</span><br><span class="line">                Object data;</span><br><span class="line">                <span class="keyword">if</span> (res.isEvent()) &#123;<span class="comment">// 如果是事件，则直接反序列化</span></span><br><span class="line">                    ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);</span><br><span class="line">                    data = decodeEventData(channel, in);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    DecodeableRpcResult result;</span><br><span class="line">                    <span class="comment">// 判断是否是要在io线程模型上执行解码，如果是则直接解码，默认是false（在2.7.4前版本是true），可以通过decode.in.io配置🌟</span></span><br><span class="line">                    <span class="keyword">if</span> (channel.getUrl().getParameter(DECODE_IN_IO_THREAD_KEY, DEFAULT_DECODE_IN_IO_THREAD)) &#123;</span><br><span class="line">                        result = <span class="keyword">new</span> DecodeableRpcResult(channel, res, is,</span><br><span class="line">                                (Invocation) getRequestData(id), proto);</span><br><span class="line">                        result.decode();<span class="comment">// 直接解码</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 先不解码，直接返回可解码的result对象</span></span><br><span class="line">                        <span class="comment">// 此处getRequestData(id)值得看下，为了方便我就贴在这里了，通过id在DefaultFuture的map缓存中获取请求时的Invocation对象，这种实现方式是io线程和biz线程解耦的关键点。</span></span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                            protected Object getRequestData(long id) &#123;</span></span><br><span class="line"><span class="comment">                                DefaultFuture future = DefaultFuture.getFuture(id);</span></span><br><span class="line"><span class="comment">                                Request req = future.getRequest();</span></span><br><span class="line"><span class="comment">                                return req.getData();</span></span><br><span class="line"><span class="comment">                            &#125;</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        result = <span class="keyword">new</span> DecodeableRpcResult(channel, res,</span><br><span class="line">                                <span class="keyword">new</span> UnsafeByteArrayInputStream(readMessageData(is)),</span><br><span class="line">                                (Invocation) getRequestData(id), proto);</span><br><span class="line">                    &#125;</span><br><span class="line">                    data = result;</span><br><span class="line">                &#125;</span><br><span class="line">                res.setResult(data);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果异常则直接在io线程上解码</span></span><br><span class="line">                ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);</span><br><span class="line">                res.setErrorMessage(in.readUTF());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;Decode response failed: &quot;</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">            res.setStatus(Response.CLIENT_ERROR);</span><br><span class="line">            res.setErrorMessage(StringUtils.toString(t));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// decode request.</span></span><br><span class="line">        Request req = <span class="keyword">new</span> Request(id);</span><br><span class="line">        req.setVersion(Version.getProtocolVersion());</span><br><span class="line">        req.setTwoWay((flag &amp; FLAG_TWOWAY) != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((flag &amp; FLAG_EVENT) != <span class="number">0</span>) &#123;</span><br><span class="line">            req.setEvent(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object data;</span><br><span class="line">            <span class="keyword">if</span> (req.isEvent()) &#123;</span><br><span class="line">                ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);</span><br><span class="line">                data = decodeEventData(channel, in);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                DecodeableRpcInvocation inv;</span><br><span class="line">                <span class="comment">// 如果是request 同样会判断是否要在io线程解码</span></span><br><span class="line">                <span class="keyword">if</span> (channel.getUrl().getParameter(DECODE_IN_IO_THREAD_KEY, DEFAULT_DECODE_IN_IO_THREAD)) &#123;</span><br><span class="line">                    inv = <span class="keyword">new</span> DecodeableRpcInvocation(channel, req, is, proto);</span><br><span class="line">                    inv.decode();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    inv = <span class="keyword">new</span> DecodeableRpcInvocation(channel, req,</span><br><span class="line">                            <span class="keyword">new</span> UnsafeByteArrayInputStream(readMessageData(is)), proto);</span><br><span class="line">                &#125;</span><br><span class="line">                data = inv;</span><br><span class="line">            &#125;</span><br><span class="line">            req.setData(data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;Decode request failed: &quot;</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// bad request</span></span><br><span class="line">            req.setBroken(<span class="keyword">true</span>);</span><br><span class="line">            req.setData(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> req;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>netty调用解码器进行解码后，很快就会传递给当时设置的handler（nettyClientHandler），调用channelRead方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NettyClientHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 通过SPI获取到NettyChannel</span></span><br><span class="line">        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);</span><br><span class="line">        <span class="comment">// NettyClient.received &gt; MultiMessageHandler.received(循环处理多个消息）&gt;HeartbeatHandler.received（处理心跳）&gt;AllChannelHandler</span></span><br><span class="line">        handler.received(channel, msg);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>AllChannelHandler将是进入消费端业务线程池第一步,但是我们在这里不进行详细介绍，后期会单独介绍io线程和biz线程的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取一个共享的线程池，默认cached</span></span><br><span class="line">    ExecutorService executor = getPreferredExecutorService(message);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 提交一个任务到线程池中执行，此处</span></span><br><span class="line">        executor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    	<span class="keyword">if</span>(message <span class="keyword">instanceof</span> Request &amp;&amp; t <span class="keyword">instanceof</span> RejectedExecutionException)&#123;</span><br><span class="line">            sendFeedback(channel, (Request) message, t);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(message, channel, getClass() + <span class="string">&quot; error when process received event .&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提交的任务的run方法是这样的，这里的hander是：DecodeHandler，channel是NettyChannel，message是Response，从现在开始，所有的执行在biz线程中工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state == ChannelState.RECEIVED) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 交给DecodeHandler来处理，判断是否完全解码，从上面我们知道此时的Response的数据还未反序列化</span></span><br><span class="line">            handler.received(channel, message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;ChannelEventRunnable handle &quot;</span> + state + <span class="string">&quot; operation error, channel is &quot;</span> + channel</span><br><span class="line">                    + <span class="string">&quot;, message is &quot;</span> + message, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> CONNECTED:</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                handler.connected(channel);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;ChannelEventRunnable handle &quot;</span> + state + <span class="string">&quot; operation error, channel is &quot;</span> + channel, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DISCONNECTED:</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                handler.disconnected(channel);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;ChannelEventRunnable handle &quot;</span> + state + <span class="string">&quot; operation error, channel is &quot;</span> + channel, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SENT:</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                handler.sent(channel, message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;ChannelEventRunnable handle &quot;</span> + state + <span class="string">&quot; operation error, channel is &quot;</span> + channel</span><br><span class="line">                        + <span class="string">&quot;, message is &quot;</span> + message, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CAUGHT:</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                handler.caught(channel, exception);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;ChannelEventRunnable handle &quot;</span> + state + <span class="string">&quot; operation error, channel is &quot;</span> + channel</span><br><span class="line">                        + <span class="string">&quot;, message is: &quot;</span> + message + <span class="string">&quot;, exception is &quot;</span> + exception, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            logger.warn(<span class="string">&quot;unknown state: &quot;</span> + state + <span class="string">&quot;, message is &quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DecodeHandler进行进一步解码：io线程中返回的message数据有可能是为完全解码的数据，比如我们的反序列化在io线程中并未操作，而是交给了biz线程，所以需要进一步解码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Decodeable) &#123;</span><br><span class="line">        decode(message);</span><br><span class="line">    <span class="comment">// 下面是解码好的数据</span></span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">        decode(((Request) message).getData());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">        decode(((Response) message).getResult());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// HeaderExchangeHandler.received</span></span><br><span class="line">    handler.received(channel, message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(Object message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Decodeable) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((Decodeable) message).decode();<span class="comment">// 最终交给消息自身的解码器解码：DecodeableRpcResult.decode</span></span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        &#125; <span class="comment">// ~ end of catch</span></span><br><span class="line">    &#125; <span class="comment">// ~ end of if</span></span><br><span class="line">&#125; <span class="comment">// ~ end of method decode</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//DecodeableRpcResult.decode源码：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// spi获取序列化器进行反序列化</span></span><br><span class="line">    ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)</span><br><span class="line">            .deserialize(channel.getUrl(), input);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span> flag = in.readByte();<span class="comment">// 这里没有看懂？难道是在序列化的时候第一个字节写入了一个标记？</span></span><br><span class="line">    <span class="keyword">switch</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">case</span> DubboCodec.RESPONSE_NULL_VALUE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DubboCodec.RESPONSE_VALUE:</span><br><span class="line">            handleValue(in);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DubboCodec.RESPONSE_WITH_EXCEPTION:</span><br><span class="line">            handleException(in);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DubboCodec.RESPONSE_NULL_VALUE_WITH_ATTACHMENTS:</span><br><span class="line">            handleAttachment(in);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DubboCodec.RESPONSE_VALUE_WITH_ATTACHMENTS:<span class="comment">// 通过debug会进入这里</span></span><br><span class="line">            handleValue(in);<span class="comment">// 设置返回值对象</span></span><br><span class="line">            handleAttachment(in);<span class="comment">// 设置附加值</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DubboCodec.RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS:</span><br><span class="line">            handleException(in);</span><br><span class="line">            handleAttachment(in);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Unknown result flag, expect &#x27;0&#x27; &#x27;1&#x27; &#x27;2&#x27; &#x27;3&#x27; &#x27;4&#x27; &#x27;5&#x27;, but received: &quot;</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (in <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">        ((Cleanable) in).cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解码完毕后，紧接着交给HeaderExchangeHandler处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">        <span class="comment">// handle request.</span></span><br><span class="line">        Request request = (Request) message;</span><br><span class="line">        <span class="keyword">if</span> (request.isEvent()) &#123;</span><br><span class="line">            handlerEvent(channel, request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.isTwoWay()) &#123;</span><br><span class="line">                handleRequest(exchangeChannel, request);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handler.received(exchangeChannel, request.getData());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">        <span class="comment">// 做为消费端，返回的是response，因此会执行这里</span></span><br><span class="line">        handleResponse(channel, (Response) message);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handler.received(exchangeChannel, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最终交给了最初我们设置的DefaultFuture处理结果</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleResponse</span><span class="params">(Channel channel, Response response)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (response != <span class="keyword">null</span> &amp;&amp; !response.isHeartbeat()) &#123;</span><br><span class="line">        DefaultFuture.received(channel, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultFuture可谓是功能多，但是功不可没，承接了跨不同线程的发送请求和获取结果的桥梁！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFuture</span> <span class="keyword">extends</span> <span class="title">CompletableFuture</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 省略大部分其他代码...</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DefaultFuture</span><span class="params">(Channel channel, Request request, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">        <span class="keyword">this</span>.id = request.getId();</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout &gt; <span class="number">0</span> ? timeout : channel.getUrl().getPositiveParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);</span><br><span class="line">        <span class="comment">// put into waiting map.</span></span><br><span class="line">        FUTURES.put(id, <span class="keyword">this</span>);</span><br><span class="line">        CHANNELS.put(id, channel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送请求的时候，我们创建了一个DefaultFuture对象，并设置到FUTURES缓存中，request.id做为key。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DefaultFuture <span class="title">newFuture</span><span class="params">(Channel channel, Request request, <span class="keyword">int</span> timeout, ExecutorService executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> DefaultFuture future = <span class="keyword">new</span> DefaultFuture(channel, request, timeout);</span><br><span class="line">        future.setExecutor(executor);</span><br><span class="line">        <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">            ((ThreadlessExecutor) executor).setWaitingFuture(future);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// timeout check</span></span><br><span class="line">        timeoutCheck(future);</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Response response)</span> </span>&#123;</span><br><span class="line">        received(channel, response, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收响应的时候，再通过key也就是id获取发送时创建的DefaultFuture，然后执行doReceived</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Response response, <span class="keyword">boolean</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DefaultFuture future = FUTURES.remove(response.getId());</span><br><span class="line">            <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</span><br><span class="line">                future.doReceived(response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            CHANNELS.remove(response.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完成DefaultFuture 异步结果获取</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReceived</span><span class="params">(Response res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;response cannot be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.getStatus() == Response.OK) &#123;</span><br><span class="line">            <span class="comment">// 完成结果获取</span></span><br><span class="line">            <span class="keyword">this</span>.complete(res.getResult());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) &#123;</span><br><span class="line">            <span class="keyword">this</span>.completeExceptionally(<span class="keyword">new</span> TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.completeExceptionally(<span class="keyword">new</span> RemotingException(channel, res.getErrorMessage()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// the result is returning, but the caller thread may still waiting</span></span><br><span class="line">        <span class="comment">// to avoid endless waiting for whatever reason, notify caller thread to return. </span></span><br><span class="line">        <span class="comment">// 如果结果已经返回，biz线程还在等待状态，则通知异常。</span></span><br><span class="line">        <span class="comment">// 因为在发送请求后，ThreadlessExecutor会阻塞，一直等待队列中有任务（也就是上面提到的ChannelEventRunable），然后执行run后等待结果。</span></span><br><span class="line">        <span class="comment">// 上面的异步转同步的源码还有印象吗？</span></span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span> &amp;&amp; executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">            ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;</span><br><span class="line">            <span class="keyword">if</span> (threadlessExecutor.isWaiting()) &#123;</span><br><span class="line">                threadlessExecutor.notifyReturn(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The result has returned, but the biz thread is still waiting&quot;</span> +</span><br><span class="line">                        <span class="string">&quot; which is not an expected state, interrupt the thread manually by returning an exception.&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费端调用流程如下：<br><img src="https://raw.githubusercontent.com/mvilplss/note/master/image/.Dubbo%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B_images/invokercustomer.png"><br>至此响应结果获取完毕，经过过滤器逐步回到调用层InvokerInvocationHandler,然后返回到代理对象proxy0到业务层，客户端整个调用过程比较复杂，要有耐心，了解消费端调用和获取响应结果的过程后，我们分析服务端对调用的处理就会轻松很多。<br>趁着还有感觉，下面我们就直接分析服务端收到请求后的一系列操作过程。</p>
<h1 id="服务端处理请求"><a href="#服务端处理请求" class="headerlink" title="服务端处理请求"></a>服务端处理请求</h1><h2 id="接收和解码请求"><a href="#接收和解码请求" class="headerlink" title="接收和解码请求"></a>接收和解码请求</h2><p>我们在分析消费者调用过程时候就说过，netty的发送和接收数据后首先会进入编码器和解码器，而服务端接收请求后首先会进入解码器进行解码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NettyCodecAdapter$InternalDecoder 执行decode</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf input, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelBuffer message = <span class="keyword">new</span> NettyBackedChannelBuffer(input);</span><br><span class="line">        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);</span><br><span class="line">        <span class="comment">// decode object.</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> saveReaderIndex = message.readerIndex();</span><br><span class="line">            <span class="comment">// codec为DubboCountCodec</span></span><br><span class="line">            Object msg = codec.decode(channel, message);</span><br><span class="line">            <span class="keyword">if</span> (msg == Codec2.DecodeResult.NEED_MORE_INPUT) &#123;</span><br><span class="line">                message.readerIndex(saveReaderIndex);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//is it possible to go here ?</span></span><br><span class="line">                <span class="keyword">if</span> (saveReaderIndex == message.readerIndex()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Decode without read data.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    out.add(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (message.readable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DubboCountCodec尝试对多个消息进行收集到MultiMessage中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, ChannelBuffer buffer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> save = buffer.readerIndex();</span><br><span class="line">    MultiMessage result = MultiMessage.create();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        Object obj = codec.decode(channel, buffer);</span><br><span class="line">        <span class="keyword">if</span> (Codec2.DecodeResult.NEED_MORE_INPUT == obj) &#123;</span><br><span class="line">            buffer.readerIndex(save);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.addMessage(obj);</span><br><span class="line">            logMessageLength(obj, buffer.readerIndex() - save);</span><br><span class="line">            save = buffer.readerIndex();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (result.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Codec2.DecodeResult.NEED_MORE_INPUT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后交给DubboCodec进一步解码，解码方式在消费者调用时我们简单分析过：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, ChannelBuffer buffer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> readable = buffer.readableBytes();</span><br><span class="line">    <span class="keyword">byte</span>[] header = <span class="keyword">new</span> <span class="keyword">byte</span>[Math.min(readable, HEADER_LENGTH)];</span><br><span class="line">    buffer.readBytes(header);</span><br><span class="line">    <span class="keyword">return</span> decode(channel, buffer, readable, header);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(Channel channel, ChannelBuffer buffer, <span class="keyword">int</span> readable, <span class="keyword">byte</span>[] header)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// check magic number.</span></span><br><span class="line">    <span class="keyword">if</span> (readable &gt; <span class="number">0</span> &amp;&amp; header[<span class="number">0</span>] != MAGIC_HIGH</span><br><span class="line">            || readable &gt; <span class="number">1</span> &amp;&amp; header[<span class="number">1</span>] != MAGIC_LOW) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = header.length;</span><br><span class="line">        <span class="keyword">if</span> (header.length &lt; readable) &#123;</span><br><span class="line">            header = Bytes.copyOf(header, readable);</span><br><span class="line">            buffer.readBytes(header, length, readable - length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; header.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (header[i] == MAGIC_HIGH &amp;&amp; header[i + <span class="number">1</span>] == MAGIC_LOW) &#123;</span><br><span class="line">                buffer.readerIndex(buffer.readerIndex() - header.length + i);</span><br><span class="line">                header = Bytes.copyOf(header, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.decode(channel, buffer, readable, header);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check length.</span></span><br><span class="line">    <span class="keyword">if</span> (readable &lt; HEADER_LENGTH) &#123;</span><br><span class="line">        <span class="keyword">return</span> DecodeResult.NEED_MORE_INPUT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get data length.</span></span><br><span class="line">    <span class="keyword">int</span> len = Bytes.bytes2int(header, <span class="number">12</span>);</span><br><span class="line">    checkPayload(channel, len);<span class="comment">// 检测长度，默认是8M，可以通过payload设置。</span></span><br><span class="line">    <span class="keyword">int</span> tt = len + HEADER_LENGTH;</span><br><span class="line">    <span class="keyword">if</span> (readable &lt; tt) &#123;</span><br><span class="line">        <span class="keyword">return</span> DecodeResult.NEED_MORE_INPUT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// limit input stream. 读取固定长度的数据</span></span><br><span class="line">    ChannelBufferInputStream is = <span class="keyword">new</span> ChannelBufferInputStream(buffer, len);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> decodeBody(channel, is, header);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对body进行解码</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">decodeBody</span><span class="params">(Channel channel, InputStream is, <span class="keyword">byte</span>[] header)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> flag = header[<span class="number">2</span>], proto = (<span class="keyword">byte</span>) (flag &amp; SERIALIZATION_MASK);</span><br><span class="line">    <span class="comment">// get request id.</span></span><br><span class="line">    <span class="keyword">long</span> id = Bytes.bytes2long(header, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> ((flag &amp; FLAG_REQUEST) == <span class="number">0</span>) &#123; <span class="comment">// 此时flag=-62，进入Request解析</span></span><br><span class="line">        <span class="comment">// decode response.</span></span><br><span class="line">        <span class="comment">// 在消费者调用中我们分析过，这里省略了。</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// decode request.</span></span><br><span class="line">        Request req = <span class="keyword">new</span> Request(id);</span><br><span class="line">        req.setVersion(Version.getProtocolVersion());</span><br><span class="line">        req.setTwoWay((flag &amp; FLAG_TWOWAY) != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((flag &amp; FLAG_EVENT) != <span class="number">0</span>) &#123;</span><br><span class="line">            req.setEvent(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object data;</span><br><span class="line">            <span class="keyword">if</span> (req.isEvent()) &#123;</span><br><span class="line">                ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);</span><br><span class="line">                data = decodeEventData(channel, in);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                DecodeableRpcInvocation inv;</span><br><span class="line">                <span class="comment">// 同样判断是否反序列化要放在io线程，默认是false</span></span><br><span class="line">                <span class="keyword">if</span> (channel.getUrl().getParameter(DECODE_IN_IO_THREAD_KEY, DEFAULT_DECODE_IN_IO_THREAD)) &#123;</span><br><span class="line">                    inv = <span class="keyword">new</span> DecodeableRpcInvocation(channel, req, is, proto);</span><br><span class="line">                    inv.decode();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 最终会封装为可解码的DecodeableRpcInvocation对象</span></span><br><span class="line">                    inv = <span class="keyword">new</span> DecodeableRpcInvocation(channel, req,</span><br><span class="line">                            <span class="keyword">new</span> UnsafeByteArrayInputStream(readMessageData(is)), proto);</span><br><span class="line">                &#125;</span><br><span class="line">                data = inv;</span><br><span class="line">            &#125;</span><br><span class="line">            req.setData(data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;Decode request failed: &quot;</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// bad request</span></span><br><span class="line">            req.setBroken(<span class="keyword">true</span>);</span><br><span class="line">            req.setData(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> req;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解码完毕后，netty执行内部逻辑后最终会调用dubbo设置的NettyServerHandler.channelRead方法，然后在以此经过NettyServer.received&gt;MultiMessageHandler.received&gt;AllChannelHandler.received，从这里开始我们的io线程会把后续工作转交给biz线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AllChannelHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="comment">// 根据端口最终会获取对应线程池，默认为：fixed 200个线程</span></span><br><span class="line">    ExecutorService executor = getPreferredExecutorService(message);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 交给biz线程池 channel=NettyChannel,handler=DecodeHandler,message=Request(客户端的请求）</span></span><br><span class="line">        executor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    	<span class="keyword">if</span>(message <span class="keyword">instanceof</span> Request &amp;&amp; t <span class="keyword">instanceof</span> RejectedExecutionException)&#123;</span><br><span class="line">            sendFeedback(channel, (Request) message, t);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(message, channel, getClass() + <span class="string">&quot; error when process received event .&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就biz线程池会执行ChannelEventRunnable任务的run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state == ChannelState.RECEIVED) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 交给DecodeHandler </span></span><br><span class="line">            handler.received(channel, message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;ChannelEventRunnable handle &quot;</span> + state + <span class="string">&quot; operation error, channel is &quot;</span> + channel+ <span class="string">&quot;, message is &quot;</span> + message, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DecodeHandler会对可解码的message完成最后的解码工作，在消费者解码已经介绍过：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="comment">// 本次为request</span></span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">        decode(((Request) message).getData());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解码后交给HeaderExchangeHandler.received</span></span><br><span class="line">    handler.received(channel, message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(Object message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Decodeable) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 最终会调用DecodeableRpcInvocation.decode方法</span></span><br><span class="line">            ((Decodeable) message).decode();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;&#125; <span class="comment">// ~ end of catch</span></span><br><span class="line">    &#125; <span class="comment">// ~ end of if</span></span><br><span class="line">&#125; <span class="comment">// ~ end of method decode</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DecodeableRpcInvocation.decode</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasDecoded &amp;&amp; channel != <span class="keyword">null</span> &amp;&amp; inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            decode(channel, inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            hasDecoded = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 做最终的解码，包括反序列化和各种属性的获取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)</span><br><span class="line">            .deserialize(channel.getUrl(), input);</span><br><span class="line">    <span class="comment">// 读取dubbo版本2.0.2</span></span><br><span class="line">    String dubboVersion = in.readUTF();</span><br><span class="line">    request.setVersion(dubboVersion);</span><br><span class="line">    setAttachment(DUBBO_VERSION_KEY, dubboVersion);</span><br><span class="line">    <span class="comment">// 读取路径 org.apache.dubbo.demo.DemoService</span></span><br><span class="line">    String path = in.readUTF();</span><br><span class="line">    setAttachment(PATH_KEY, path);</span><br><span class="line">    setAttachment(VERSION_KEY, in.readUTF());</span><br><span class="line">    <span class="comment">// 方法名称 sayHello</span></span><br><span class="line">    setMethodName(in.readUTF());</span><br><span class="line">    <span class="comment">// 参数类型Ljava/lang/String;</span></span><br><span class="line">    String desc = in.readUTF();</span><br><span class="line">    setParameterTypesDesc(desc);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] args = DubboCodec.EMPTY_OBJECT_ARRAY;</span><br><span class="line">        Class&lt;?&gt;[] pts = DubboCodec.EMPTY_CLASS_ARRAY;</span><br><span class="line">        <span class="keyword">if</span> (desc.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取服务仓库，这里包含path和ServiceDescriptor的映射</span></span><br><span class="line">            ServiceRepository repository = ApplicationModel.getServiceRepository();</span><br><span class="line">            <span class="comment">// 获取目标服务信息</span></span><br><span class="line">            ServiceDescriptor serviceDescriptor = repository.lookupService(path);</span><br><span class="line">            <span class="keyword">if</span> (serviceDescriptor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取目标方法信息</span></span><br><span class="line">                MethodDescriptor methodDescriptor = serviceDescriptor.getMethod(getMethodName(), desc);</span><br><span class="line">                <span class="keyword">if</span> (methodDescriptor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pts = methodDescriptor.getParameterClasses();</span><br><span class="line">                    <span class="comment">// 设置返回类型</span></span><br><span class="line">                    <span class="keyword">this</span>.setReturnTypes(methodDescriptor.getReturnTypes());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pts == DubboCodec.EMPTY_CLASS_ARRAY) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!RpcUtils.isGenericCall(desc, getMethodName()) &amp;&amp; !RpcUtils.isEcho(desc, getMethodName())) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Service not found:&quot;</span> + path + <span class="string">&quot;, &quot;</span> + getMethodName());</span><br><span class="line">                &#125;</span><br><span class="line">                pts = ReflectUtils.desc2classArray(desc);</span><br><span class="line">            &#125;</span><br><span class="line">            args = <span class="keyword">new</span> Object[pts.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 逐个读取入参</span></span><br><span class="line">                    args[i] = in.readObject(pts[i]);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setParameterTypes(pts);</span><br><span class="line">        Map&lt;String, Object&gt; map = in.readAttachments();</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span> &amp;&amp; map.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; attachment = getObjectAttachments();</span><br><span class="line">            <span class="keyword">if</span> (attachment == <span class="keyword">null</span>) &#123;</span><br><span class="line">                attachment = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            attachment.putAll(map);</span><br><span class="line">            setObjectAttachments(attachment);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//decode argument ,may be callback </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            args[i] = decodeInvocationArgument(channel, <span class="keyword">this</span>, pts, i, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        setArguments(args);</span><br><span class="line">        <span class="comment">// org.apache.dubbo.demo.DemoService:0.0.0</span></span><br><span class="line">        String targetServiceName = buildKey((String) getAttachment(PATH_KEY),</span><br><span class="line">                getAttachment(GROUP_KEY),</span><br><span class="line">                getAttachment(VERSION_KEY));</span><br><span class="line">        setTargetServiceUniqueName(targetServiceName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(StringUtils.toString(<span class="string">&quot;Read invocation data failed.&quot;</span>, e));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (in <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">            ((Cleanable) in).cleanup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解码完毕后，下面将是通过解码后的message找到我们即将要调用的invoker。</p>
<h2 id="找到服务端的invoker"><a href="#找到服务端的invoker" class="headerlink" title="找到服务端的invoker"></a>找到服务端的invoker</h2><p>HeaderExchangeHandler.received源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">        <span class="comment">// handle request.</span></span><br><span class="line">        Request request = (Request) message;</span><br><span class="line">        <span class="keyword">if</span> (request.isEvent()) &#123;</span><br><span class="line">            handlerEvent(channel, request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.isTwoWay()) &#123;</span><br><span class="line">                <span class="comment">// 处理request</span></span><br><span class="line">                handleRequest(exchangeChannel, request);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handler.received(exchangeChannel, request.getData());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">final</span> ExchangeChannel channel, Request req)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="comment">// 封装返回对象</span></span><br><span class="line">    Response res = <span class="keyword">new</span> Response(req.getId(), req.getVersion());</span><br><span class="line">    <span class="keyword">if</span> (req.isBroken()) &#123;</span><br><span class="line">        <span class="comment">// 异常则返回bad</span></span><br><span class="line">        res.setErrorMessage(<span class="string">&quot;Fail to decode request due to: &quot;</span> + msg);</span><br><span class="line">        res.setStatus(Response.BAD_REQUEST);</span><br><span class="line">        channel.send(res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// find handler by message class.</span></span><br><span class="line">    Object msg = req.getData();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 最终会调用DubboProtocol的内部类ExchangeHandlerAdapter</span></span><br><span class="line">        CompletionStage&lt;Object&gt; future = handler.reply(channel, msg);</span><br><span class="line">        <span class="comment">// 拿到结果后，进行响应数据</span></span><br><span class="line">        future.whenComplete((appResult, t) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    res.setStatus(Response.OK);</span><br><span class="line">                    res.setResult(appResult);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">                    res.setErrorMessage(StringUtils.toString(t));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 调用nettychannel发送响应数据</span></span><br><span class="line">                channel.send(res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Send result to consumer failed, channel is &quot;</span> + channel + <span class="string">&quot;, msg is &quot;</span> + e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">        res.setErrorMessage(StringUtils.toString(e));</span><br><span class="line">        channel.send(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看下DubboProtocol$ExchangeHandlerAdapter.reply，其主要目的就是获取要调用的invoker，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">public</span> CompletableFuture&lt;Object&gt; <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">         Invocation inv = (Invocation) message;</span><br><span class="line">         Invoker&lt;?&gt; invoker = getInvoker(channel, inv);</span><br><span class="line">         <span class="comment">// need to consider backward-compatibility if it&#x27;s a callback</span></span><br><span class="line">         <span class="keyword">if</span> (Boolean.TRUE.toString().equals(inv.getObjectAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) &#123;</span><br><span class="line">             String methodsStr = invoker.getUrl().getParameters().get(<span class="string">&quot;methods&quot;</span>);</span><br><span class="line">             <span class="keyword">boolean</span> hasMethod = <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">if</span> (methodsStr == <span class="keyword">null</span> || !methodsStr.contains(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">                 hasMethod = inv.getMethodName().equals(methodsStr);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 String[] methods = methodsStr.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                 <span class="keyword">for</span> (String method : methods) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (inv.getMethodName().equals(method)) &#123;</span><br><span class="line">                         hasMethod = <span class="keyword">true</span>;</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (!hasMethod) &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());</span><br><span class="line">         <span class="comment">// 执行invoke</span></span><br><span class="line">         Result result = invoker.invoke(inv);</span><br><span class="line">         <span class="keyword">return</span> result.thenApply(Function.identity());</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="comment">// 获取invoker</span></span><br><span class="line">Invoker&lt;?&gt; getInvoker(Channel channel, Invocation inv) <span class="keyword">throws</span> RemotingException &#123;</span><br><span class="line">     <span class="keyword">boolean</span> isCallBackServiceInvoke = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">boolean</span> isStubServiceInvoke = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">int</span> port = channel.getLocalAddress().getPort();</span><br><span class="line">     String path = (String) inv.getObjectAttachments().get(PATH_KEY);</span><br><span class="line">     <span class="comment">// 根据参数组装serverKey</span></span><br><span class="line">     String serviceKey = serviceKey(</span><br><span class="line">             port,</span><br><span class="line">             path,</span><br><span class="line">             (String) inv.getObjectAttachments().get(VERSION_KEY),</span><br><span class="line">             (String) inv.getObjectAttachments().get(GROUP_KEY)</span><br><span class="line">     );</span><br><span class="line">     <span class="comment">// 通过serviceKey在导出的服务中获取服务invoker</span></span><br><span class="line">     DubboExporter&lt;?&gt; exporter = (DubboExporter&lt;?&gt;) exporterMap.get(serviceKey);</span><br><span class="line">     <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel, <span class="string">&quot;Not found exported service: &quot;</span> + serviceKey + <span class="string">&quot; in &quot;</span> + exporterMap.keySet() + <span class="string">&quot;, may be version or group mismatch &quot;</span> +</span><br><span class="line">                 <span class="string">&quot;, channel: consumer: &quot;</span> + channel.getRemoteAddress() + <span class="string">&quot; --&gt; provider: &quot;</span> + channel.getLocalAddress() + <span class="string">&quot;, message:&quot;</span> + getInvocationWithoutData(inv));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> exporter.getInvoker();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="invoker的执行"><a href="#invoker的执行" class="headerlink" title="invoker的执行"></a>invoker的执行</h2><p>invoker执行逻辑第一站就是执行ProtocolFilterWrapper下构建的过滤器链：<br>EchoFilter&gt;ClassLoaderFilter&gt;GenericFilter&gt;ContextFilter&gt;TraceFilter&gt;TimeoutFilter&gt;MonitorFilter&gt;ExceptionFilter&gt;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProtocolFilterWrapper</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    Result asyncResult;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        asyncResult = filter.invoke(next, invocation);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filter <span class="keyword">instanceof</span> ListenableFilter) &#123;</span><br><span class="line">            ListenableFilter listenableFilter = ((ListenableFilter) filter);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Filter.Listener listener = listenableFilter.listener(invocation);</span><br><span class="line">                <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    listener.onError(e, invoker, invocation);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                listenableFilter.removeListener(invocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (filter <span class="keyword">instanceof</span> Filter.Listener) &#123;</span><br><span class="line">            Filter.Listener listener = (Filter.Listener) filter;</span><br><span class="line">            listener.onError(e, invoker, invocation);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> asyncResult.whenCompleteWithContext((r, t) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (filter <span class="keyword">instanceof</span> ListenableFilter) &#123;</span><br><span class="line">            ListenableFilter listenableFilter = ((ListenableFilter) filter);</span><br><span class="line">            Filter.Listener listener = listenableFilter.listener(invocation);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        listener.onResponse(r, invoker, invocation);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        listener.onError(t, invoker, invocation);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                listenableFilter.removeListener(invocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (filter <span class="keyword">instanceof</span> Filter.Listener) &#123;</span><br><span class="line">            Filter.Listener listener = (Filter.Listener) filter;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                listener.onResponse(r, invoker, invocation);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                listener.onError(t, invoker, invocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>经过调用一系列过滤器和包装器，最终invoker会走到JavassistProxyFactory，进一步调用目标对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// JavassistProxyFactory$1，的父类AbstractProxyInvoker.invoke</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 调用的是子类的内部类</span></span><br><span class="line">         Object value = doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments());</span><br><span class="line">CompletableFuture&lt;Object&gt; future = wrapWithFuture(value);</span><br><span class="line">         CompletableFuture&lt;AppResponse&gt; appResponseFuture = future.handle((obj, t) -&gt; &#123;</span><br><span class="line">             AppResponse result = <span class="keyword">new</span> AppResponse();</span><br><span class="line">             <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (t <span class="keyword">instanceof</span> CompletionException) &#123;</span><br><span class="line">                     result.setException(t.getCause());</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     result.setException(t);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 result.setValue(obj);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> result;</span><br><span class="line">         &#125;);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> AsyncRpcResult(appResponseFuture, invocation);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">         <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e.getTargetException(), invocation);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Failed to invoke remote proxy method &quot;</span> + invocation.getMethodName() + <span class="string">&quot; to &quot;</span> + getUrl() + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 在服务导出时候，返回的invoker是内部包装类</span></span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="string">&#x27;$&#x27;</span>) &lt; <span class="number">0</span> ? proxy.getClass() : type);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>wrapper包装类最终调用类目标类proxy的目标方法sayHello，wrapper的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>到这里，服务方的目标方法执行完毕，下面将进入服务执行结果的响应逻辑分析。</p>
<h2 id="服务的响应"><a href="#服务的响应" class="headerlink" title="服务的响应"></a>服务的响应</h2><p>返回结果：”Hello dubbo, response from provider: 172.11.11.77:2808”，此结果首先在JavasisstProxyFactory中被包装为CompletableFuture对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 获取调用biz业务代码结果</span></span><br><span class="line">           Object value = doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments());</span><br><span class="line">           <span class="comment">// 包装结果对象</span></span><br><span class="line">		CompletableFuture&lt;Object&gt; future = wrapWithFuture(value);</span><br><span class="line">           <span class="comment">// 将结果包装到AppResponse对象中</span></span><br><span class="line">           CompletableFuture&lt;AppResponse&gt; appResponseFuture = future.handle((obj, t) -&gt; &#123;</span><br><span class="line">               AppResponse result = <span class="keyword">new</span> AppResponse();</span><br><span class="line">               <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (t <span class="keyword">instanceof</span> CompletionException) &#123;</span><br><span class="line">                       result.setException(t.getCause());</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       result.setException(t);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   result.setValue(obj);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;);</span><br><span class="line">           <span class="comment">// 再次包装到AsyncRpcResult中</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> AsyncRpcResult(appResponseFuture, invocation);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">           <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e.getTargetException(), invocation);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Failed to invoke remote proxy method &quot;</span> + invocation.getMethodName() + <span class="string">&quot; to &quot;</span> + getUrl() + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;Object&gt; <span class="title">wrapWithFuture</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (RpcContext.getContext().isAsyncStarted()) &#123;</span><br><span class="line">           <span class="keyword">return</span> ((AsyncContextImpl)(RpcContext.getContext().getAsyncContext())).getInternalFuture();</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> CompletableFuture) &#123;</span><br><span class="line">           <span class="keyword">return</span> (CompletableFuture&lt;Object&gt;) value;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 包装结果对象</span></span><br><span class="line">       <span class="keyword">return</span> CompletableFuture.completedFuture(value);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>返回的CompletableFuture对象经过层层回调，最后会回到HeaderExchangeHandler的handleRequest中，在获取结果后开始响应请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">final</span> ExchangeChannel channel, Request req)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">     Response res = <span class="keyword">new</span> Response(req.getId(), req.getVersion());</span><br><span class="line">     <span class="comment">// find handler by message class.</span></span><br><span class="line">     Object msg = req.getData();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 获取结果</span></span><br><span class="line">         CompletionStage&lt;Object&gt; future = handler.reply(channel, msg);</span><br><span class="line">         future.whenComplete((appResult, t) -&gt; &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     res.setStatus(Response.OK);</span><br><span class="line">                     res.setResult(appResult);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">                     res.setErrorMessage(StringUtils.toString(t));</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">// HeaderExchangeChannel 发送响应数据</span></span><br><span class="line">                 channel.send(res);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">                 logger.warn(<span class="string">&quot;Send result to consumer failed, channel is &quot;</span> + channel + <span class="string">&quot;, msg is &quot;</span> + e);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">         res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">         res.setErrorMessage(StringUtils.toString(e));</span><br><span class="line">         channel.send(res);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>HeaderExchangeChannel.send方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request</span><br><span class="line">            || message <span class="keyword">instanceof</span> Response</span><br><span class="line">            || message <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="comment">// 会调用NettyChannel发送数据</span></span><br><span class="line">        channel.send(message, sent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Request request = <span class="keyword">new</span> Request();</span><br><span class="line">        request.setVersion(Version.getProtocolVersion());</span><br><span class="line">        request.setTwoWay(<span class="keyword">false</span>);</span><br><span class="line">        request.setData(message);</span><br><span class="line">        channel.send(request, sent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NettyChannel发送数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 最终会委托给 org.jboss.netty.channel.socket.nio.NioSocketChannel 发送数据</span></span><br><span class="line">        ChannelFuture future = channel.writeAndFlush(message);</span><br><span class="line">        <span class="keyword">if</span> (sent) &#123;</span><br><span class="line">            <span class="comment">// wait timeout ms</span></span><br><span class="line">            timeout = getUrl().getPositiveParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);</span><br><span class="line">            success = future.await(timeout);</span><br><span class="line">        &#125;</span><br><span class="line">        Throwable cause = future.cause();</span><br><span class="line">        <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> cause;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        removeChannelIfDisconnected(channel);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">&quot;Failed to send message &quot;</span> + PayloadDropper.getRequestWithoutData(message) + <span class="string">&quot; to &quot;</span> + getRemoteAddress() + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，我们肯定知道，netty发送数据前会先调用编码器进行编码的：NettyCodecAdapter$InternalEncoder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Object msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        org.apache.dubbo.remoting.buffer.ChannelBuffer buffer = <span class="keyword">new</span> NettyBackedChannelBuffer(out);</span><br><span class="line">        Channel ch = ctx.channel();</span><br><span class="line">        NettyChannel channel = NettyChannel.getOrAddChannel(ch, url, handler);</span><br><span class="line">        codec.encode(channel, buffer, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终会调用DubboCodec进行编码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeResponse</span><span class="params">(Channel channel, ChannelBuffer buffer, Response res)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> savedWriteIndex = buffer.writerIndex();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取序列化 hessian2</span></span><br><span class="line">        Serialization serialization = getSerialization(channel);</span><br><span class="line">        <span class="comment">// header. 请求头</span></span><br><span class="line">        <span class="keyword">byte</span>[] header = <span class="keyword">new</span> <span class="keyword">byte</span>[HEADER_LENGTH];</span><br><span class="line">        <span class="comment">// set magic number.</span></span><br><span class="line">        Bytes.short2bytes(MAGIC, header);</span><br><span class="line">        <span class="comment">// set request and serialization flag.</span></span><br><span class="line">        header[<span class="number">2</span>] = serialization.getContentTypeId();</span><br><span class="line">        <span class="keyword">if</span> (res.isHeartbeat()) &#123;</span><br><span class="line">            header[<span class="number">2</span>] |= FLAG_EVENT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// set response status.</span></span><br><span class="line">        <span class="keyword">byte</span> status = res.getStatus();</span><br><span class="line">        header[<span class="number">3</span>] = status;</span><br><span class="line">        <span class="comment">// set request id.</span></span><br><span class="line">        Bytes.long2bytes(res.getId(), header, <span class="number">4</span>);</span><br><span class="line">        </span><br><span class="line">        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);</span><br><span class="line">        ChannelBufferOutputStream bos = <span class="keyword">new</span> ChannelBufferOutputStream(buffer);</span><br><span class="line">        <span class="comment">// 对响应数据进行序列化，此时是在io线程</span></span><br><span class="line">        ObjectOutput out = serialization.serialize(channel.getUrl(), bos);</span><br><span class="line">        <span class="comment">// encode response data or error message.</span></span><br><span class="line">        <span class="keyword">if</span> (status == Response.OK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.isHeartbeat()) &#123;</span><br><span class="line">                encodeEventData(channel, out, res.getResult());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 序列化入结果和版本号</span></span><br><span class="line">                encodeResponseData(channel, out, res.getResult(), res.getVersion());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out.writeUTF(res.getErrorMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        out.flushBuffer();</span><br><span class="line">        <span class="keyword">if</span> (out <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">            ((Cleanable) out).cleanup();</span><br><span class="line">        &#125;</span><br><span class="line">        bos.flush();</span><br><span class="line">        bos.close();</span><br><span class="line">        <span class="keyword">int</span> len = bos.writtenBytes();</span><br><span class="line">        <span class="comment">// 检测长度</span></span><br><span class="line">        checkPayload(channel, len);</span><br><span class="line">        Bytes.int2bytes(len, header, <span class="number">12</span>);</span><br><span class="line">        <span class="comment">// write</span></span><br><span class="line">        buffer.writerIndex(savedWriteIndex);</span><br><span class="line">        buffer.writeBytes(header); <span class="comment">// write header.</span></span><br><span class="line">        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，服务端的响应分析结束。<br><img src="https://raw.githubusercontent.com/mvilplss/note/master/image/Dubbo%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B_images/d3b6790e.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇文章从消费者调用到服务端响应整个过程走了一遍，整个过程相对比较复杂。其中涉及到了路由，集群容错，负载均衡，过滤器责任链，监听器，异步转同步，biz线程和io线程的互转，请求的发送和响应结果匹配，协议的编码解码，对象的序列化和反序列化等等。<br>本文目的是对整个调用过程的熟悉，涉及多个重要点只是简单提下，在今后的文章中会进行补充。</p>
<blockquote>
<p>边看源码边写本文，其中有以下几个想法：</p>
</blockquote>
<ol>
<li>dubbo为了减少IO线程的阻塞，把工作尽量交给了biz线程，但是消费端的请求对象序列化和服务端的响应对象序列化依然绑定在IO上的，最为高性能之称，此处应该可以进一步优化。</li>
<li>服务降级，熔断，限流还很简陋。</li>
<li>路由不够好用。</li>
<li>协议不支持根据请求包的大小进行自动适配最合适的协议。</li>
</ol>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh/docs/v2.7/dev/source/service-invoking-process/">http://dubbo.apache.org/zh/docs/v2.7/dev/source/service-invoking-process/</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/meilong_whpu/article/details/72178447">https://blog.csdn.net/meilong_whpu/article/details/72178447</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2020/12/03/ElasticSearch%E5%88%9D%E6%8E%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/03/ElasticSearch%E5%88%9D%E6%8E%A2/" class="post-title-link" itemprop="url">ElasticSearch初探</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-03 00:00:00" itemprop="dateCreated datePublished" datetime="2020-12-03T00:00:00+08:00">2020-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:03" itemprop="dateModified" datetime="2022-07-05T22:46:03+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">开发技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ElasticSearch搭建单机应用"><a href="#ElasticSearch搭建单机应用" class="headerlink" title="ElasticSearch搭建单机应用"></a>ElasticSearch搭建单机应用</h1><h2 id="下载解压"><a href="#下载解压" class="headerlink" title="下载解压"></a>下载解压</h2><p>进入官网，下载安装最新的版：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/targz.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/targz.html</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.12.1-linux-x86_64.tar.gz</span><br><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.12.1-linux-x86_64.tar.gz.sha512</span><br><span class="line">shasum -a 512 -c elasticsearch-7.12.1-linux-x86_64.tar.gz.sha512 </span><br><span class="line">tar -xzf elasticsearch-7.12.1-linux-x86_64.tar.gz</span><br><span class="line">cd elasticsearch-7.12.1/</span><br></pre></td></tr></table></figure>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch</span><br></pre></td></tr></table></figure>
<p>启动异常1：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">org.elasticsearch.bootstrap.StartupException: java.lang.RuntimeException: can not run elasticsearch as root</span><br><span class="line">	at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:163) ~[elasticsearch-7.12.1.jar:7.12.1]</span><br><span class="line">	at org.elasticsearch.bootstrap.Elasticsearch.execute(Elasticsearch.java:150) ~[elasticsearch-7.12.1.jar:7.12.1]</span><br><span class="line">	at org.elasticsearch.cli.EnvironmentAwareCommand.execute(EnvironmentAwareCommand.java:75) ~[elasticsearch-7.12.1.jar:7.12.1]</span><br><span class="line">	at org.elasticsearch.cli.Command.mainWithoutErrorHandling(Command.java:116) ~[elasticsearch-cli-7.12.1.jar:7.12.1]</span><br><span class="line">	at org.elasticsearch.cli.Command.main(Command.java:79) ~[elasticsearch-cli-7.12.1.jar:7.12.1]</span><br><span class="line">	at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:115) ~[elasticsearch-7.12.1.jar:7.12.1]</span><br><span class="line">	at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:81) ~[elasticsearch-7.12.1.jar:7.12.1]</span><br><span class="line">Caused by: java.lang.RuntimeException: can not run elasticsearch as root</span><br><span class="line">	at org.elasticsearch.bootstrap.Bootstrap.initializeNatives(Bootstrap.java:101) ~[elasticsearch-7.12.1.jar:7.12.1]</span><br><span class="line">	at org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:168) ~[elasticsearch-7.12.1.jar:7.12.1]</span><br><span class="line">	at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:397) ~[elasticsearch-7.12.1.jar:7.12.1]</span><br><span class="line">	at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:159) ~[elasticsearch-7.12.1.jar:7.12.1]</span><br></pre></td></tr></table></figure>
<p>因为elasticsearch不能使用root账户启动，因此我们需要创建个账户进行启动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加elastic用户，并将文件放到elastic用户目录下</span></span><br><span class="line">useradd elastic</span><br><span class="line">mv elasticsearch-7.12.1 /home/elastic</span><br><span class="line">cd /home/elastic</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 授权目录权限给elastic用户</span></span><br><span class="line">su root</span><br><span class="line">chown -R elastic:elastic elasticsearch-7.12.1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换为elastic用户再次启动</span></span><br><span class="line">su elastic</span><br><span class="line">cd elasticsearch-7.12.1/</span><br><span class="line"></span><br><span class="line">./bin/elasticsearch</span><br></pre></td></tr></table></figure>
<p>启动异常2：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</span><br></pre></td></tr></table></figure>
<p>root用户修改配置limit.cnf配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/security/limits.conf </span><br></pre></td></tr></table></figure>
<p>增加以下两行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*               soft    nofile          65536</span><br><span class="line">*               hard    nofile          65536</span><br></pre></td></tr></table></figure>

<p><em>重启Linux系统</em> 再次启动，测试是否成功</p>
<blockquote>
<p>如果还有问题请参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/happyzxs/article/details/89156068">https://blog.csdn.net/happyzxs/article/details/89156068</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">curl localhost:9200</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;apple&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;vsP40XZ7S06aM1DEcl2ibw&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;7.12.1&quot;,</span><br><span class="line">    &quot;build_flavor&quot; : &quot;default&quot;,</span><br><span class="line">    &quot;build_type&quot; : &quot;tar&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;3186837139b9c6b6d23c3200870651f10d3343b7&quot;,</span><br><span class="line">    &quot;build_date&quot; : &quot;2020-04-20T20:56:39.040728659Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;8.8.0&quot;,</span><br><span class="line">    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,</span><br><span class="line">    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>为了快速入门，我们参考《ElasticSearch权威指南》上的示例，创建三个用户，然后对三个用户进行查询统计等操作。<br>使用之前我们要了解ElasticSearch也是一个数据库，分为索引，类型，文档，属性和关系型数据库对比关系如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; Columns</span><br><span class="line">Elasticsearch -&gt; Indices -&gt; Types -&gt; Documents -&gt; Fields</span><br></pre></td></tr></table></figure>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">PUT http://localhost:9200/db_test/user/1</span><br><span class="line">&#123;</span><br><span class="line">	&quot;first_name&quot;:&quot;John&quot;,</span><br><span class="line">	&quot;last_name&quot;:&quot;Smith&quot;,</span><br><span class="line">	&quot;age&quot;:25,</span><br><span class="line">	&quot;about&quot;:&quot;i love to go rock climbing&quot;,</span><br><span class="line">	&quot;interests&quot;:[&quot;sports&quot;,&quot;music&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回</span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;_index&quot;: &quot;db_test&quot;,</span><br><span class="line">    &quot;_type&quot;: &quot;user&quot;,</span><br><span class="line">    &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;_version&quot;: 1,</span><br><span class="line">    &quot;result&quot;: &quot;created&quot;,</span><br><span class="line">    &quot;_shards&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 2,</span><br><span class="line">        &quot;successful&quot;: 1,</span><br><span class="line">        &quot;failed&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;_seq_no&quot;: 0,</span><br><span class="line">    &quot;_primary_term&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>db_test</code>为索引（数据库），<code>user</code>为类型（表），<code>1</code>为文档的id。<br>接着我们再创建两个用户</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PUT http://localhost:9200/db_test/user/2</span><br><span class="line">&#123;</span><br><span class="line">	&quot;first_name&quot;:&quot;Jane&quot;,</span><br><span class="line">	&quot;last_name&quot;:&quot;Smith&quot;,</span><br><span class="line">	&quot;age&quot;:32,</span><br><span class="line">	&quot;about&quot;:&quot;i like to collect rock albums&quot;,</span><br><span class="line">	&quot;interests&quot;:[&quot;music&quot;]</span><br><span class="line">&#125;</span><br><span class="line">PUT http://localhost:9200/db_test/user/3</span><br><span class="line">&#123;</span><br><span class="line">	&quot;first_name&quot;:&quot;Douglas&quot;,</span><br><span class="line">	&quot;last_name&quot;:&quot;Fir&quot;,</span><br><span class="line">	&quot;age&quot;:35,</span><br><span class="line">	&quot;about&quot;:&quot;i like to build cabinets&quot;,</span><br><span class="line">	&quot;interests&quot;:[&quot;forestry&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询索引"><a href="#查询索引" class="headerlink" title="查询索引"></a>查询索引</h3><h4 id="查询所有索引"><a href="#查询所有索引" class="headerlink" title="查询所有索引"></a>查询所有索引</h4><p>GET <a target="_blank" rel="noopener" href="http://v11:9200/db_test/user/_search">http://v11:9200/db_test/user/_search</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;took&quot;: 420,</span><br><span class="line">    &quot;timed_out&quot;: false,</span><br><span class="line">    &quot;_shards&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 1,</span><br><span class="line">        &quot;successful&quot;: 1,</span><br><span class="line">        &quot;skipped&quot;: 0,</span><br><span class="line">        &quot;failed&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;hits&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: &#123;</span><br><span class="line">            &quot;value&quot;: 3,</span><br><span class="line">            &quot;relation&quot;: &quot;eq&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;max_score&quot;: 1.0,</span><br><span class="line">        &quot;hits&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;_index&quot;: &quot;db_test&quot;,</span><br><span class="line">                &quot;_type&quot;: &quot;user&quot;,</span><br><span class="line">                &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;_score&quot;: 1.0,</span><br><span class="line">                &quot;_source&quot;: &#123;</span><br><span class="line">                    &quot;first_name&quot;: &quot;John&quot;,</span><br><span class="line">                    &quot;last_name&quot;: &quot;Smith&quot;,</span><br><span class="line">                    &quot;age&quot;: 25,</span><br><span class="line">                    &quot;about&quot;: &quot;i love to go rock climbing&quot;,</span><br><span class="line">                    &quot;interests&quot;: [</span><br><span class="line">                        &quot;sports&quot;,</span><br><span class="line">                        &quot;music&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;_index&quot;: &quot;db_test&quot;,</span><br><span class="line">                &quot;_type&quot;: &quot;user&quot;,</span><br><span class="line">                &quot;_id&quot;: &quot;2&quot;,</span><br><span class="line">                &quot;_score&quot;: 1.0,</span><br><span class="line">                &quot;_source&quot;: &#123;</span><br><span class="line">                    &quot;first_name&quot;: &quot;Jane&quot;,</span><br><span class="line">                    &quot;last_name&quot;: &quot;Smith&quot;,</span><br><span class="line">                    &quot;age&quot;: 32,</span><br><span class="line">                    &quot;about&quot;: &quot;i like to collect rock albums&quot;,</span><br><span class="line">                    &quot;interests&quot;: [</span><br><span class="line">                        &quot;music&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;_index&quot;: &quot;db_test&quot;,</span><br><span class="line">                &quot;_type&quot;: &quot;user&quot;,</span><br><span class="line">                &quot;_id&quot;: &quot;3&quot;,</span><br><span class="line">                &quot;_score&quot;: 1.0,</span><br><span class="line">                &quot;_source&quot;: &#123;</span><br><span class="line">                    &quot;first_name&quot;: &quot;Douglas&quot;,</span><br><span class="line">                    &quot;last_name&quot;: &quot;Fir&quot;,</span><br><span class="line">                    &quot;age&quot;: 35,</span><br><span class="line">                    &quot;about&quot;: &quot;i like to build cabinets&quot;,</span><br><span class="line">                    &quot;interests&quot;: [</span><br><span class="line">                        &quot;forestry&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="根据ID查询索引"><a href="#根据ID查询索引" class="headerlink" title="根据ID查询索引"></a>根据ID查询索引</h4><p>GET <a target="_blank" rel="noopener" href="http://v11:9200/db_test/user/2">http://v11:9200/db_test/user/2</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_index&quot;: &quot;db_test&quot;,</span><br><span class="line">    &quot;_type&quot;: &quot;user&quot;,</span><br><span class="line">    &quot;_id&quot;: &quot;2&quot;,</span><br><span class="line">    &quot;_version&quot;: 1,</span><br><span class="line">    &quot;_seq_no&quot;: 4,</span><br><span class="line">    &quot;_primary_term&quot;: 1,</span><br><span class="line">    &quot;found&quot;: true,</span><br><span class="line">    &quot;_source&quot;: &#123;</span><br><span class="line">        &quot;first_name&quot;: &quot;Jane&quot;,</span><br><span class="line">        &quot;last_name&quot;: &quot;Smith&quot;,</span><br><span class="line">        &quot;age&quot;: 32,</span><br><span class="line">        &quot;about&quot;: &quot;i like to collect rock albums&quot;,</span><br><span class="line">        &quot;interests&quot;: [</span><br><span class="line">            &quot;music&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="根据某个属性查询索引"><a href="#根据某个属性查询索引" class="headerlink" title="根据某个属性查询索引"></a>根据某个属性查询索引</h4><p>GET <a target="_blank" rel="noopener" href="http://v11:9200/db_test/user/_search?q=last_name:Smith">http://v11:9200/db_test/user/_search?q=last_name:Smith</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;took&quot;: 2,</span><br><span class="line">    &quot;timed_out&quot;: false,</span><br><span class="line">    &quot;_shards&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 1,</span><br><span class="line">        &quot;successful&quot;: 1,</span><br><span class="line">        &quot;skipped&quot;: 0,</span><br><span class="line">        &quot;failed&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;hits&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: &#123;</span><br><span class="line">            &quot;value&quot;: 2,</span><br><span class="line">            &quot;relation&quot;: &quot;eq&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;max_score&quot;: 0.44183272,</span><br><span class="line">        &quot;hits&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;_index&quot;: &quot;db_test&quot;,</span><br><span class="line">                &quot;_type&quot;: &quot;user&quot;,</span><br><span class="line">                &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;_score&quot;: 0.44183272,</span><br><span class="line">                &quot;_source&quot;: &#123;</span><br><span class="line">                    &quot;first_name&quot;: &quot;John&quot;,</span><br><span class="line">                    &quot;last_name&quot;: &quot;Smith&quot;,</span><br><span class="line">                    &quot;age&quot;: 25,</span><br><span class="line">                    &quot;about&quot;: &quot;i love to go rock climbing&quot;,</span><br><span class="line">                    &quot;interests&quot;: [</span><br><span class="line">                        &quot;sports&quot;,</span><br><span class="line">                        &quot;music&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;_index&quot;: &quot;db_test&quot;,</span><br><span class="line">                &quot;_type&quot;: &quot;user&quot;,</span><br><span class="line">                &quot;_id&quot;: &quot;2&quot;,</span><br><span class="line">                &quot;_score&quot;: 0.44183272,</span><br><span class="line">                &quot;_source&quot;: &#123;</span><br><span class="line">                    &quot;first_name&quot;: &quot;Jane&quot;,</span><br><span class="line">                    &quot;last_name&quot;: &quot;Smith&quot;,</span><br><span class="line">                    &quot;age&quot;: 32,</span><br><span class="line">                    &quot;about&quot;: &quot;i like to collect rock albums&quot;,</span><br><span class="line">                    &quot;interests&quot;: [</span><br><span class="line">                        &quot;music&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用DSL语句查询"><a href="#使用DSL语句查询" class="headerlink" title="使用DSL语句查询"></a>使用DSL语句查询</h4><p>GET <a target="_blank" rel="noopener" href="http://v11:9200/db_test/user/_search">http://v11:9200/db_test/user/_search</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">            &quot;last_name&quot;: &quot;Smith&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;took&quot;: 4,</span><br><span class="line">    &quot;timed_out&quot;: false,</span><br><span class="line">    &quot;_shards&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 1,</span><br><span class="line">        &quot;successful&quot;: 1,</span><br><span class="line">        &quot;skipped&quot;: 0,</span><br><span class="line">        &quot;failed&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;hits&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: &#123;</span><br><span class="line">            &quot;value&quot;: 2,</span><br><span class="line">            &quot;relation&quot;: &quot;eq&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;max_score&quot;: 0.44183272,</span><br><span class="line">        &quot;hits&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;_index&quot;: &quot;db_test&quot;,</span><br><span class="line">                &quot;_type&quot;: &quot;user&quot;,</span><br><span class="line">                &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;_score&quot;: 0.44183272,</span><br><span class="line">                &quot;_source&quot;: &#123;</span><br><span class="line">                    &quot;first_name&quot;: &quot;John&quot;,</span><br><span class="line">                    &quot;last_name&quot;: &quot;Smith&quot;,</span><br><span class="line">                    &quot;age&quot;: 25,</span><br><span class="line">                    &quot;about&quot;: &quot;i love to go rock climbing&quot;,</span><br><span class="line">                    &quot;interests&quot;: [</span><br><span class="line">                        &quot;sports&quot;,</span><br><span class="line">                        &quot;music&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;_index&quot;: &quot;db_test&quot;,</span><br><span class="line">                &quot;_type&quot;: &quot;user&quot;,</span><br><span class="line">                &quot;_id&quot;: &quot;2&quot;,</span><br><span class="line">                &quot;_score&quot;: 0.44183272,</span><br><span class="line">                &quot;_source&quot;: &#123;</span><br><span class="line">                    &quot;first_name&quot;: &quot;Jane&quot;,</span><br><span class="line">                    &quot;last_name&quot;: &quot;Smith&quot;,</span><br><span class="line">                    &quot;age&quot;: 32,</span><br><span class="line">                    &quot;about&quot;: &quot;i like to collect rock albums&quot;,</span><br><span class="line">                    &quot;interests&quot;: [</span><br><span class="line">                        &quot;music&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h4><p>GET <a target="_blank" rel="noopener" href="http://v11:9200/db_test/user/_search">http://v11:9200/db_test/user/_search</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">            &quot;must&quot;: &#123;</span><br><span class="line">                &quot;match&quot; : &#123;</span><br><span class="line">                    &quot;last_name&quot; : &quot;smith&quot; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;filter&quot;: &#123;</span><br><span class="line">                &quot;range&quot; : &#123;</span><br><span class="line">                    &quot;age&quot; : &#123; &quot;gt&quot; : 30 &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;took&quot;: 50,</span><br><span class="line">    &quot;timed_out&quot;: false,</span><br><span class="line">    &quot;_shards&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 1,</span><br><span class="line">        &quot;successful&quot;: 1,</span><br><span class="line">        &quot;skipped&quot;: 0,</span><br><span class="line">        &quot;failed&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;hits&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: &#123;</span><br><span class="line">            &quot;value&quot;: 1,</span><br><span class="line">            &quot;relation&quot;: &quot;eq&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;max_score&quot;: 0.4700036,</span><br><span class="line">        &quot;hits&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;_index&quot;: &quot;db_test&quot;,</span><br><span class="line">                &quot;_type&quot;: &quot;user&quot;,</span><br><span class="line">                &quot;_id&quot;: &quot;2&quot;,</span><br><span class="line">                &quot;_score&quot;: 0.4700036,</span><br><span class="line">                &quot;_source&quot;: &#123;</span><br><span class="line">                    &quot;first_name&quot;: &quot;Jane&quot;,</span><br><span class="line">                    &quot;last_name&quot;: &quot;Smith&quot;,</span><br><span class="line">                    &quot;age&quot;: 32,</span><br><span class="line">                    &quot;about&quot;: &quot;i like to collect rock albums&quot;,</span><br><span class="line">                    &quot;interests&quot;: [</span><br><span class="line">                        &quot;music&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h4><p>到目前为止搜索都很简单:简单的名字，通过年龄筛选。让我们尝试一种更高级的搜索，全文搜索——一种传统数据库很难现的功能。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET http://v11:9200/db_test/user/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">            &quot;about&quot;: &quot;rock climbing&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;took&quot;: 24,</span><br><span class="line">    &quot;timed_out&quot;: false,</span><br><span class="line">    &quot;_shards&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 1,</span><br><span class="line">        &quot;successful&quot;: 1,</span><br><span class="line">        &quot;skipped&quot;: 0,</span><br><span class="line">        &quot;failed&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;hits&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: &#123;</span><br><span class="line">            &quot;value&quot;: 2,</span><br><span class="line">            &quot;relation&quot;: &quot;eq&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;max_score&quot;: 1.4167401,</span><br><span class="line">        &quot;hits&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;_index&quot;: &quot;db_test&quot;,</span><br><span class="line">                &quot;_type&quot;: &quot;user&quot;,</span><br><span class="line">                &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;_score&quot;: 1.4167401,</span><br><span class="line">                &quot;_source&quot;: &#123;</span><br><span class="line">                    &quot;first_name&quot;: &quot;John&quot;,</span><br><span class="line">                    &quot;last_name&quot;: &quot;Smith&quot;,</span><br><span class="line">                    &quot;age&quot;: 25,</span><br><span class="line">                    &quot;about&quot;: &quot;i love to go rock climbing&quot;,</span><br><span class="line">                    &quot;interests&quot;: [</span><br><span class="line">                        &quot;sports&quot;,</span><br><span class="line">                        &quot;music&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;_index&quot;: &quot;db_test&quot;,</span><br><span class="line">                &quot;_type&quot;: &quot;user&quot;,</span><br><span class="line">                &quot;_id&quot;: &quot;2&quot;,</span><br><span class="line">                &quot;_score&quot;: 0.4589591,</span><br><span class="line">                &quot;_source&quot;: &#123;</span><br><span class="line">                    &quot;first_name&quot;: &quot;Jane&quot;,</span><br><span class="line">                    &quot;last_name&quot;: &quot;Smith&quot;,</span><br><span class="line">                    &quot;age&quot;: 32,</span><br><span class="line">                    &quot;about&quot;: &quot;i like to collect rock albums&quot;,</span><br><span class="line">                    &quot;interests&quot;: [</span><br><span class="line">                        &quot;music&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以看到我们使用与之前一致的 match 查询搜索 about 字段中的”rock climbing”，我们会得到两个匹配文档，这是因为搜索引擎进行搜索时候进行了分词，然后根据分词结果查询出来结果，然后根据匹配度评分进行倒叙排列。</p>
<h4 id="短语查询"><a href="#短语查询" class="headerlink" title="短语查询"></a>短语查询</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET http://v11:9200/db_test/user/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match_phrase&quot;: &#123;</span><br><span class="line">            &quot;about&quot;: &quot;rock climbing&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>毫无疑问，返回包含短语的文档：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;took&quot;: 23,</span><br><span class="line">    &quot;timed_out&quot;: false,</span><br><span class="line">    &quot;_shards&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 1,</span><br><span class="line">        &quot;successful&quot;: 1,</span><br><span class="line">        &quot;skipped&quot;: 0,</span><br><span class="line">        &quot;failed&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;hits&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: &#123;</span><br><span class="line">            &quot;value&quot;: 1,</span><br><span class="line">            &quot;relation&quot;: &quot;eq&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;max_score&quot;: 1.4167401,</span><br><span class="line">        &quot;hits&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;_index&quot;: &quot;db_test&quot;,</span><br><span class="line">                &quot;_type&quot;: &quot;user&quot;,</span><br><span class="line">                &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;_score&quot;: 1.4167401,</span><br><span class="line">                &quot;_source&quot;: &#123;</span><br><span class="line">                    &quot;first_name&quot;: &quot;John&quot;,</span><br><span class="line">                    &quot;last_name&quot;: &quot;Smith&quot;,</span><br><span class="line">                    &quot;age&quot;: 25,</span><br><span class="line">                    &quot;about&quot;: &quot;i love to go rock climbing&quot;,</span><br><span class="line">                    &quot;interests&quot;: [</span><br><span class="line">                        &quot;sports&quot;,</span><br><span class="line">                        &quot;music&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="高亮我们的搜索"><a href="#高亮我们的搜索" class="headerlink" title="高亮我们的搜索"></a>高亮我们的搜索</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET http://v11:9200/db_test/user/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match_phrase&quot;: &#123;</span><br><span class="line">            &quot;about&quot;: &quot;rock climbing&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;highlight&quot;: &#123;</span><br><span class="line">        &quot;fields&quot;: &#123;</span><br><span class="line">            &quot;about&quot;: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回带有高亮标示的结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;took&quot;: 83,</span><br><span class="line">    &quot;timed_out&quot;: false,</span><br><span class="line">    &quot;_shards&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 1,</span><br><span class="line">        &quot;successful&quot;: 1,</span><br><span class="line">        &quot;skipped&quot;: 0,</span><br><span class="line">        &quot;failed&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;hits&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: &#123;</span><br><span class="line">            &quot;value&quot;: 1,</span><br><span class="line">            &quot;relation&quot;: &quot;eq&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;max_score&quot;: 1.4167401,</span><br><span class="line">        &quot;hits&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;_index&quot;: &quot;db_test&quot;,</span><br><span class="line">                &quot;_type&quot;: &quot;user&quot;,</span><br><span class="line">                &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;_score&quot;: 1.4167401,</span><br><span class="line">                &quot;_source&quot;: &#123;</span><br><span class="line">                    &quot;first_name&quot;: &quot;John&quot;,</span><br><span class="line">                    &quot;last_name&quot;: &quot;Smith&quot;,</span><br><span class="line">                    &quot;age&quot;: 25,</span><br><span class="line">                    &quot;about&quot;: &quot;i love to go rock climbing&quot;,</span><br><span class="line">                    &quot;interests&quot;: [</span><br><span class="line">                        &quot;sports&quot;,</span><br><span class="line">                        &quot;music&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;highlight&quot;: &#123;</span><br><span class="line">                    &quot;about&quot;: [</span><br><span class="line">                        &quot;i love to go &lt;em&gt;rock&lt;/em&gt; &lt;em&gt;climbing&lt;/em&gt;&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="覆盖更新索引"><a href="#覆盖更新索引" class="headerlink" title="覆盖更新索引"></a>覆盖更新索引</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT http://v11:9200/db_test/user/2</span><br><span class="line">&#123;</span><br><span class="line">    &quot;first_name&quot;: &quot;Jane&quot;,</span><br><span class="line">    &quot;last_name&quot;: &quot;Smith&quot;,</span><br><span class="line">    &quot;age&quot;: 18,</span><br><span class="line">    &quot;about&quot;: &quot;i like to collect rock albums&quot;,</span><br><span class="line">    &quot;interests&quot;: [</span><br><span class="line">        &quot;music&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新操作会递增索引的版本’_version’，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_index&quot;: &quot;db_test&quot;,</span><br><span class="line">    &quot;_type&quot;: &quot;user&quot;,</span><br><span class="line">    &quot;_id&quot;: &quot;2&quot;,</span><br><span class="line">    &quot;_version&quot;: 2,</span><br><span class="line">    &quot;result&quot;: &quot;updated&quot;,</span><br><span class="line">    &quot;_shards&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 2,</span><br><span class="line">        &quot;successful&quot;: 1,</span><br><span class="line">        &quot;failed&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;_seq_no&quot;: 6,</span><br><span class="line">    &quot;_primary_term&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="局部更新"><a href="#局部更新" class="headerlink" title="局部更新"></a>局部更新</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST http://v11:9200/db_test/user/3/_update</span><br><span class="line">&#123;</span><br><span class="line">	&quot;doc&quot;:&#123;</span><br><span class="line">        &quot;about&quot;:&quot;i love coding&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>局部更新结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_index&quot;: &quot;db_test&quot;,</span><br><span class="line">    &quot;_type&quot;: &quot;user&quot;,</span><br><span class="line">    &quot;_id&quot;: &quot;3&quot;,</span><br><span class="line">    &quot;_version&quot;: 2,</span><br><span class="line">    &quot;result&quot;: &quot;updated&quot;,</span><br><span class="line">    &quot;_shards&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 2,</span><br><span class="line">        &quot;successful&quot;: 1,</span><br><span class="line">        &quot;failed&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;_seq_no&quot;: 8,</span><br><span class="line">    &quot;_primary_term&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE http://v11:9200/db_test/user/2</span><br></pre></td></tr></table></figure>
<p>删除索引ElasticSearch不会立即删除此索引的，他会升级他的版本号，并标记删除：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_index&quot;: &quot;db_test&quot;,</span><br><span class="line">    &quot;_type&quot;: &quot;user&quot;,</span><br><span class="line">    &quot;_id&quot;: &quot;2&quot;,</span><br><span class="line">    &quot;_version&quot;: 3,</span><br><span class="line">    &quot;result&quot;: &quot;deleted&quot;,</span><br><span class="line">    &quot;_shards&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 2,</span><br><span class="line">        &quot;successful&quot;: 1,</span><br><span class="line">        &quot;failed&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;_seq_no&quot;: 7,</span><br><span class="line">    &quot;_primary_term&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2020/12/03/Dubbo%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/03/Dubbo%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8/" class="post-title-link" itemprop="url">Dubbo服务的引用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-03 00:00:00" itemprop="dateCreated datePublished" datetime="2020-12-03T00:00:00+08:00">2020-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:03" itemprop="dateModified" datetime="2022-07-05T22:46:03+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">开发技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我们可以通过两种方式引用远程服务。第一种是使用服务直连的方式引用服务，第二种方式是基于注册中心进行引用。服务直连的方式仅适合在调试或测试服务的场景下使用，不适合在线上环境使用。因此，本文我将重点分析通过注册中心引用服务的过程。从注册中心中获取服务配置只是服务引用过程中的一环，除此之外，服务消费者还需要经历 Invoker 创建、代理类创建等步骤。</p>
<h2 id="服务的引用"><a href="#服务的引用" class="headerlink" title="服务的引用"></a>服务的引用</h2><h3 id="引用示例"><a href="#引用示例" class="headerlink" title="引用示例"></a>引用示例</h3><p>为了研究方便研究源码引用过程，我们通过api引用方式进行研究，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ReferenceConfig&lt;DemoService&gt; reference = <span class="keyword">new</span> ReferenceConfig&lt;&gt;();</span><br><span class="line">    reference.setApplication(<span class="keyword">new</span> ApplicationConfig(<span class="string">&quot;dubbo-demo-api-consumer&quot;</span>));</span><br><span class="line">    reference.setRegistry(<span class="keyword">new</span> RegistryConfig(<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>));</span><br><span class="line">    reference.setInterface(DemoService.class);</span><br><span class="line">    DemoService service = reference.get();</span><br><span class="line">    String message = service.sayHello(<span class="string">&quot;dubbo&quot;</span>);</span><br><span class="line">    System.out.println(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="配置参数收集和组装"><a href="#配置参数收集和组装" class="headerlink" title="配置参数收集和组装"></a>配置参数收集和组装</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ref == <span class="keyword">null</span>) &#123;</span><br><span class="line">        init();<span class="comment">// 初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bootstrap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        bootstrap = DubboBootstrap.getInstance();</span><br><span class="line">        bootstrap.init();</span><br><span class="line">    &#125;</span><br><span class="line">    checkAndUpdateSubConfigs();</span><br><span class="line">    checkStubAndLocal(interfaceClass);</span><br><span class="line">    ConfigValidationUtils.checkMock(interfaceClass, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(SIDE_KEY, CONSUMER_SIDE);<span class="comment">// 设置side为消费端</span></span><br><span class="line">    ReferenceConfigBase.appendRuntimeParameters(map);</span><br><span class="line">    <span class="keyword">if</span> (!ProtocolUtils.isGeneric(generic)) &#123;</span><br><span class="line">        String revision = Version.getVersion(interfaceClass, version);</span><br><span class="line">        <span class="keyword">if</span> (revision != <span class="keyword">null</span> &amp;&amp; revision.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            map.put(REVISION_KEY, revision);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">        <span class="keyword">if</span> (methods.length == <span class="number">0</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;No method found in service interface &quot;</span> + interfaceClass.getName());</span><br><span class="line">            map.put(METHODS_KEY, ANY_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(METHODS_KEY, StringUtils.join(<span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), COMMA_SEPARATOR));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(INTERFACE_KEY, interfaceName);</span><br><span class="line">    AbstractConfig.appendParameters(map, getMetrics());</span><br><span class="line">    AbstractConfig.appendParameters(map, getApplication());</span><br><span class="line">    AbstractConfig.appendParameters(map, getModule());</span><br><span class="line">    AbstractConfig.appendParameters(map, consumer);</span><br><span class="line">    AbstractConfig.appendParameters(map, <span class="keyword">this</span>);</span><br><span class="line">    Map&lt;String, AsyncMethodInfo&gt; attributes = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(getMethods())) &#123;</span><br><span class="line">        attributes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (MethodConfig methodConfig : getMethods()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String hostToRegistry = ConfigUtils.getSystemProperty(DUBBO_IP_TO_REGISTRY);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(hostToRegistry)) &#123;</span><br><span class="line">        hostToRegistry = NetUtils.getLocalHost();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isInvalidLocalHost(hostToRegistry)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Specified invalid registry ip from property:&quot;</span> + DUBBO_IP_TO_REGISTRY + <span class="string">&quot;, value:&quot;</span> + hostToRegistry);</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(REGISTER_IP_KEY, hostToRegistry);</span><br><span class="line">    serviceMetadata.getAttachments().putAll(map);</span><br><span class="line">    <span class="comment">// 根据收集的参数创建客户端服务代理类</span></span><br><span class="line">    ref = createProxy(map);</span><br><span class="line">    serviceMetadata.setTarget(ref);</span><br><span class="line">    serviceMetadata.addAttribute(PROXY_CLASS_REF, ref);</span><br><span class="line">    ConsumerModel consumerModel = repository.lookupReferredService(serviceMetadata.getServiceKey());</span><br><span class="line">    consumerModel.setProxyObject(ref);</span><br><span class="line">    <span class="comment">// 注入配置的属性</span></span><br><span class="line">    consumerModel.init(attributes);</span><br><span class="line">    initialized = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// dispatch a ReferenceConfigInitializedEvent since 2.7.4 </span></span><br><span class="line">    <span class="comment">// 转发一个引用配置已经初始化事件</span></span><br><span class="line">    dispatch(<span class="keyword">new</span> ReferenceConfigInitializedEvent(<span class="keyword">this</span>, invoker));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上源码逻辑主要是对消费者配置的收集和封装到一个map中，下面将根据map进行创建代理。</p>
<h4 id="获取注册中心地址"><a href="#获取注册中心地址" class="headerlink" title="获取注册中心地址"></a>获取注册中心地址</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createProxy</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldJvmRefer(map)) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        urls.clear();</span><br><span class="line">        <span class="comment">// 用户指定url时候，直接使用</span></span><br><span class="line">        <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; url.length() &gt; <span class="number">0</span>) &#123; <span class="comment">// user specified URL, could be peer-to-peer address, or register center&#x27;s address.</span></span><br><span class="line">            String[] us = SEMICOLON_SPLIT_PATTERN.split(url);</span><br><span class="line">            <span class="keyword">if</span> (us != <span class="keyword">null</span> &amp;&amp; us.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String u : us) &#123;</span><br><span class="line">                    URL url = URL.valueOf(u);</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isEmpty(url.getPath())) &#123;</span><br><span class="line">                        url = url.setPath(interfaceName);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (UrlUtils.isRegistry(url)) &#123;</span><br><span class="line">                        urls.add(url.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        urls.add(ClusterUtils.mergeUrl(url, map));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        	<span class="comment">// assemble URL from register center&#x27;s configuration</span></span><br><span class="line">            <span class="comment">// if protocols not injvm checkRegistry</span></span><br><span class="line">            <span class="keyword">if</span> (!LOCAL_PROTOCOL.equalsIgnoreCase(getProtocol())) &#123;</span><br><span class="line">                checkRegistry();</span><br><span class="line">                List&lt;URL&gt; us = ConfigValidationUtils.loadRegistries(<span class="keyword">this</span>, <span class="keyword">false</span>);<span class="comment">// 组装注册中心URL</span></span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isNotEmpty(us)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (URL u : us) &#123;</span><br><span class="line">                        URL monitorUrl = ConfigValidationUtils.loadMonitor(<span class="keyword">this</span>, u);</span><br><span class="line">                        <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            map.put(MONITOR_KEY, URL.encode(monitorUrl.toFullString()));</span><br><span class="line">                        &#125;</span><br><span class="line">                        urls.add(u.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (urls.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No such any registry to reference &quot;</span> + interfaceName + <span class="string">&quot; on the consumer &quot;</span> + NetUtils.getLocalHost() + <span class="string">&quot; use dubbo version &quot;</span> + Version.getVersion() + <span class="string">&quot;, please config &lt;dubbo:registry address=\&quot;...\&quot; /&gt; to your spring config.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (urls.size() == <span class="number">1</span>) &#123; <span class="comment">// 1个注册中心</span></span><br><span class="line">        	<span class="comment">// 根据协议接口获取协议扩展点，此处和服务导出类似，获取为：ProtocolFilterWrapper&gt;ProtocolListenerWrapper&gt;RegistryProtocol</span></span><br><span class="line">            invoker = REF_PROTOCOL.refer(interfaceClass, urls.get(<span class="number">0</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;Invoker&lt;?&gt;&gt; invokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;?&gt;&gt;();</span><br><span class="line">            URL registryURL = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">                invokers.add(REF_PROTOCOL.refer(interfaceClass, url));</span><br><span class="line">                <span class="keyword">if</span> (UrlUtils.isRegistry(url)) &#123;</span><br><span class="line">                    registryURL = url; <span class="comment">// use last registry url</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (registryURL != <span class="keyword">null</span>) &#123; <span class="comment">// registry url is available</span></span><br><span class="line">                <span class="comment">// for multi-subscription scenario, use &#x27;zone-aware&#x27; policy by default</span></span><br><span class="line">                String cluster = registryURL.getParameter(CLUSTER_KEY, ZoneAwareCluster.NAME);</span><br><span class="line">                <span class="comment">// The invoker wrap sequence would be: ZoneAwareClusterInvoker(StaticDirectory) -&gt; FailoverClusterInvoker(RegistryDirectory, routing happens here) -&gt; Invoker</span></span><br><span class="line">                invoker = Cluster.getCluster(cluster, <span class="keyword">false</span>).join(<span class="keyword">new</span> StaticDirectory(registryURL, invokers));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// not a registry url, must be direct invoke.</span></span><br><span class="line">                String cluster = CollectionUtils.isNotEmpty(invokers)</span><br><span class="line">                        ? (invokers.get(<span class="number">0</span>).getUrl() != <span class="keyword">null</span> ? invokers.get(<span class="number">0</span>).getUrl().getParameter(CLUSTER_KEY, ZoneAwareCluster.NAME) : Cluster.DEFAULT)</span><br><span class="line">                        : Cluster.DEFAULT;</span><br><span class="line">                invoker = Cluster.getCluster(cluster).join(<span class="keyword">new</span> StaticDirectory(invokers));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldCheck() &amp;&amp; !invoker.isAvailable()) &#123;</span><br><span class="line">        invoker.destroy();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// create service proxy 通过javassist把封装好的invoker再次封装到被调用接口的代理类中供应用调用 7⃣️</span></span><br><span class="line">    <span class="keyword">return</span> (T) PROXY_FACTORY.getProxy(invoker, ProtocolUtils.isGeneric(generic));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="获取register对象"><a href="#获取register对象" class="headerlink" title="获取register对象"></a>获取register对象</h4><p>获取注册中心的<code>register</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProtocolFilterWrapper 传递给ProtocolListenerWrapper</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (UrlUtils.isRegistry(url)) &#123;</span><br><span class="line">           <span class="keyword">return</span> protocol.refer(type, url);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> buildInvokerChain(protocol.refer(type, url), REFERENCE_FILTER_KEY, CommonConstants.CONSUMER);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// ProtocolListenerWrapper 传递给RegistryProtocol</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UrlUtils.isRegistry(url)) &#123;</span><br><span class="line">        <span class="keyword">return</span> protocol.refer(type, url);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListenerInvokerWrapper&lt;T&gt;(protocol.refer(type, url),</span><br><span class="line">            Collections.unmodifiableList(</span><br><span class="line">                    ExtensionLoader.getExtensionLoader(InvokerListener.class)</span><br><span class="line">                            .getActivateExtension(url, INVOKER_LISTENER_KEY)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RegistryProtocol </span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">   	<span class="comment">// 获取注册中心URL</span></span><br><span class="line">       url = getRegistryUrl(url);</span><br><span class="line">       <span class="comment">// 获取注册中心对象(ListenerRegistryWrapper实例)</span></span><br><span class="line">       Registry registry = registryFactory.getRegistry(url); <span class="comment">// 0⃣️</span></span><br><span class="line">       <span class="keyword">if</span> (RegistryService.class.equals(type)) &#123;</span><br><span class="line">       	<span class="comment">// 构造invoker 2⃣️</span></span><br><span class="line">           <span class="keyword">return</span> proxyFactory.getInvoker((T) registry, type, url);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// group=&quot;a,b&quot; or group=&quot;*&quot;</span></span><br><span class="line">       Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));</span><br><span class="line">       String group = qs.get(GROUP_KEY);</span><br><span class="line">       <span class="keyword">if</span> (group != <span class="keyword">null</span> &amp;&amp; group.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((COMMA_SPLIT_PATTERN.split(group)).length &gt; <span class="number">1</span> || <span class="string">&quot;*&quot;</span>.equals(group)) &#123;</span><br><span class="line">               <span class="keyword">return</span> doRefer(Cluster.getCluster(MergeableCluster.NAME), registry, type, url);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 获取容错集群MockClusterWrapper 3⃣️</span></span><br><span class="line">       Cluster cluster = Cluster.getCluster(qs.get(CLUSTER_KEY));</span><br><span class="line">       <span class="comment">// 获取invoker4⃣️</span></span><br><span class="line">       <span class="keyword">return</span> doRefer(cluster, registry, type, url);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上述0⃣️位置<code>registryFactory</code> 为扩展器加载到的对象：RegistryFactoryWrapper&gt;ZookeeperRegistryFactory，最终获取到一个创建链接后的注册中心客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegistryFactoryWrapper</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Registry <span class="title">getRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ListenerRegistryWrapper(registryFactory.getRegistry(url),<span class="comment">//1⃣️</span></span><br><span class="line">               Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(RegistryServiceListener.class)</span><br><span class="line">                       .getActivateExtension(url, <span class="string">&quot;registry.listeners&quot;</span>)));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 1⃣️ZookeeperRegistryFactory.super()</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Registry <span class="title">getRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">   	<span class="comment">// 获取注册中心地址</span></span><br><span class="line">       url = URLBuilder.from(url)</span><br><span class="line">               .setPath(RegistryService.class.getName())</span><br><span class="line">               .addParameter(INTERFACE_KEY, RegistryService.class.getName())</span><br><span class="line">               .removeParameters(EXPORT_KEY, REFER_KEY)</span><br><span class="line">               .build();</span><br><span class="line">       <span class="comment">// 获取缓存key</span></span><br><span class="line">       String key = createRegistryCacheKey(url);</span><br><span class="line">       <span class="comment">// Lock the registry access process to ensure a single instance of the registry</span></span><br><span class="line">       LOCK.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Registry registry = REGISTRIES.get(key);</span><br><span class="line">           <span class="keyword">if</span> (registry != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> registry;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//create registry by spi/ioc 创建一个registry</span></span><br><span class="line">           registry = createRegistry(url);</span><br><span class="line">           <span class="comment">// 缓存注册中心</span></span><br><span class="line">           REGISTRIES.put(key, registry);</span><br><span class="line">           <span class="keyword">return</span> registry;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// Release the lock</span></span><br><span class="line">           LOCK.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// ZookeeperRegistryFactory</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Registry <span class="title">createRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ZookeeperRegistry(url, zookeeperTransporter);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 最终通过zookeeperTransporter获取到已链接的zk客户端</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ZookeeperRegistry</span><span class="params">(URL url, ZookeeperTransporter zookeeperTransporter)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(url);</span><br><span class="line">       <span class="keyword">if</span> (url.isAnyHost()) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;registry address == null&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       String group = url.getParameter(GROUP_KEY, DEFAULT_ROOT);</span><br><span class="line">       <span class="keyword">if</span> (!group.startsWith(PATH_SEPARATOR)) &#123;</span><br><span class="line">           group = PATH_SEPARATOR + group;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">this</span>.root = group;</span><br><span class="line">       zkClient = zookeeperTransporter.connect(url);</span><br><span class="line">       zkClient.addStateListener((state) -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (state == StateListener.RECONNECTED) &#123;</span><br><span class="line">               ZookeeperRegistry.<span class="keyword">this</span>.fetchLatestAddresses();</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == StateListener.NEW_SESSION_CREATED) &#123;</span><br><span class="line">               logger.warn(<span class="string">&quot;Trying to re-register urls and re-subscribe listeners of this instance to registry...&quot;</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   ZookeeperRegistry.<span class="keyword">this</span>.recover();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                   logger.error(e.getMessage(), e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="通过register订阅服务"><a href="#通过register订阅服务" class="headerlink" title="通过register订阅服务"></a>通过register订阅服务</h4><p>在上述代码中获取到了注册中心对象，下面将进行服务的订阅<br>在上面代码3⃣️<code>Cluster cluster = Cluster.getCluster(qs.get(CLUSTER_KEY));</code>可知，获取invoker前，要先获取容错集群：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cluster 获取容错集群，默认为failover：失败后重试</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> Cluster <span class="title">getCluster</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> getCluster(name, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> Cluster <span class="title">getCluster</span><span class="params">(String name, <span class="keyword">boolean</span> wrap)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">           name = Cluster.DEFAULT;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 最终返回扩展对象为：FailoverCluster</span></span><br><span class="line">       <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(Cluster.class).getExtension(name, wrap);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码4⃣️中<code>doRefer(cluster, registry, type, url)</code>获取容错集群后继续创建invoker：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doRefer</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 先创建注册表，在创建注册表时候，会自动new ConsumerConfigurationListener()，同时会初始化规则配置动态监听器，用来监听路由规则的变化</span></span><br><span class="line">    RegistryDirectory&lt;T&gt; directory = <span class="keyword">new</span> RegistryDirectory&lt;T&gt;(type, url);</span><br><span class="line">    directory.setRegistry(registry);</span><br><span class="line">    <span class="comment">// 设置协议自适应扩展对象</span></span><br><span class="line">    directory.setProtocol(protocol);</span><br><span class="line">    <span class="comment">// all attributes of REFER_KEY</span></span><br><span class="line">    Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(directory.getConsumerUrl().getParameters());</span><br><span class="line">    URL subscribeUrl = <span class="keyword">new</span> URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), <span class="number">0</span>, type.getName(), parameters);</span><br><span class="line">    <span class="keyword">if</span> (directory.isShouldRegister()) &#123;</span><br><span class="line">        directory.setRegisteredConsumerUrl(subscribeUrl);</span><br><span class="line">        registry.register(directory.getRegisteredConsumerUrl());<span class="comment">// 注册消费者到注册中心，类似服务的注册地址在zk的创建</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过spi获取自动激活的路由扩展点：MockInvokersSelector，TagRouter，AppRouter，ServiceRouter </span></span><br><span class="line">    directory.buildRouterChain(subscribeUrl);</span><br><span class="line">    <span class="comment">// 获取zk中的服务地址，并注册zk并监听服务地址的变化 5⃣️</span></span><br><span class="line">    directory.subscribe(toSubscribeUrl(subscribeUrl));</span><br><span class="line">    <span class="comment">// 进一步获取invoker 6⃣️</span></span><br><span class="line">    Invoker&lt;T&gt; invoker = cluster.join(directory);</span><br><span class="line">    <span class="comment">// 获取协议注册监听</span></span><br><span class="line">    List&lt;RegistryProtocolListener&gt; listeners = findRegistryProtocolListeners(url);</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(listeners)) &#123;</span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有监听器，则调用监听器通知refer完毕</span></span><br><span class="line">    RegistryInvokerWrapper&lt;T&gt; registryInvokerWrapper = <span class="keyword">new</span> RegistryInvokerWrapper&lt;&gt;(directory, cluster, invoker);</span><br><span class="line">    <span class="keyword">for</span> (RegistryProtocolListener listener : listeners) &#123;</span><br><span class="line">        listener.onRefer(<span class="keyword">this</span>, registryInvokerWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> registryInvokerWrapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码5⃣️地方订阅注册中心，详细代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先RegistryDirectory增加一些订阅监听器后，委托register进行订阅</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">       setConsumerUrl(url);</span><br><span class="line">       CONSUMER_CONFIGURATION_LISTENER.addNotifyListener(<span class="keyword">this</span>);</span><br><span class="line">       serviceConfigurationListener = <span class="keyword">new</span> ReferenceConfigurationListener(<span class="keyword">this</span>, url);</span><br><span class="line">       registry.subscribe(url, <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// FailbackRegistry订阅服务包装,订阅失败则尝试从缓存中获取服务列表，如果是启动过程中订阅失败，则直接抛出异常</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url, NotifyListener listener)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.subscribe(url, listener);</span><br><span class="line">       removeFailedSubscribed(url, listener);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// Sending a subscription request to the server side</span></span><br><span class="line">           doSubscribe(url, listener);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           Throwable t = e;</span><br><span class="line">           List&lt;URL&gt; urls = getCacheUrls(url);</span><br><span class="line">           <span class="keyword">if</span> (CollectionUtils.isNotEmpty(urls)) &#123;</span><br><span class="line">               notify(url, listener, urls);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// If the startup detection is opened, the Exception is thrown directly.</span></span><br><span class="line">               <span class="keyword">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                       &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>);</span><br><span class="line">               <span class="keyword">boolean</span> skipFailback = t <span class="keyword">instanceof</span> SkipFailbackWrapperException;</span><br><span class="line">               <span class="keyword">if</span> (check || skipFailback) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (skipFailback) &#123;</span><br><span class="line">                       t = t.getCause();</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to subscribe &quot;</span> + url + <span class="string">&quot;, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           addFailedSubscribed(url, listener);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// ZookeeperRegistry 订阅服务</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSubscribe</span><span class="params">(<span class="keyword">final</span> URL url, <span class="keyword">final</span> NotifyListener listener)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">       	<span class="comment">// 判断是否订阅所有服务</span></span><br><span class="line">           <span class="keyword">if</span> (ANY_VALUE.equals(url.getServiceInterface())) &#123;</span><br><span class="line">               String root = toRootPath();</span><br><span class="line">               ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.computeIfAbsent(url, k -&gt; <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">               ChildListener zkListener = listeners.computeIfAbsent(listener, k -&gt; (parentPath, currentChilds) -&gt; &#123;</span><br><span class="line">                   <span class="keyword">for</span> (String child : currentChilds) &#123;</span><br><span class="line">                       child = URL.decode(child);</span><br><span class="line">                       <span class="keyword">if</span> (!anyServices.contains(child)) &#123;</span><br><span class="line">                           anyServices.add(child);</span><br><span class="line">                           subscribe(url.setPath(child).addParameters(INTERFACE_KEY, child,</span><br><span class="line">                                   Constants.CHECK_KEY, String.valueOf(<span class="keyword">false</span>)), k);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">               zkClient.create(root, <span class="keyword">false</span>);</span><br><span class="line">               List&lt;String&gt; services = zkClient.addChildListener(root, zkListener);</span><br><span class="line">               <span class="keyword">if</span> (CollectionUtils.isNotEmpty(services)) &#123;</span><br><span class="line">                   <span class="keyword">for</span> (String service : services) &#123;</span><br><span class="line">                       service = URL.decode(service);</span><br><span class="line">                       anyServices.add(service);</span><br><span class="line">                       subscribe(url.setPath(service).addParameters(INTERFACE_KEY, service,</span><br><span class="line">                               Constants.CHECK_KEY, String.valueOf(<span class="keyword">false</span>)), listener);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           <span class="comment">// 订阅指定服务（常用）</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">               <span class="keyword">for</span> (String path : toCategoriesPath(url)) &#123;</span><br><span class="line">                   ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.computeIfAbsent(url, k -&gt; <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">                   ChildListener zkListener = listeners.computeIfAbsent(listener, k -&gt; (parentPath, currentChilds) -&gt; ZookeeperRegistry.<span class="keyword">this</span>.notify(url, k, toUrlsWithEmpty(url, parentPath, currentChilds)));</span><br><span class="line">                   zkClient.create(path, <span class="keyword">false</span>);<span class="comment">// 此处为何再此创建provider的节点？</span></span><br><span class="line">                   List&lt;String&gt; children = zkClient.addChildListener(path, zkListener);<span class="comment">// 获取服务提供地址和注册zk监听器</span></span><br><span class="line">                   <span class="keyword">if</span> (children != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       urls.addAll(toUrlsWithEmpty(url, path, children));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 通知服务地址变化</span></span><br><span class="line">               notify(url, listener, urls);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Failed to subscribe &quot;</span> + url + <span class="string">&quot; to zookeeper &quot;</span> + getUrl() + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// AbstractRegistry 通知服务地址变化</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(URL url, NotifyListener listener, List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// keep every provider&#x27;s category.</span></span><br><span class="line">       Map&lt;String, List&lt;URL&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (URL u : urls) &#123;</span><br><span class="line">           <span class="keyword">if</span> (UrlUtils.isMatch(url, u)) &#123;</span><br><span class="line">               String category = u.getParameter(CATEGORY_KEY, DEFAULT_CATEGORY);</span><br><span class="line">               List&lt;URL&gt; categoryList = result.computeIfAbsent(category, k -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">               categoryList.add(u);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (result.size() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       Map&lt;String, List&lt;URL&gt;&gt; categoryNotified = notified.computeIfAbsent(url, u -&gt; <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">       <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;URL&gt;&gt; entry : result.entrySet()) &#123;</span><br><span class="line">           String category = entry.getKey();</span><br><span class="line">           List&lt;URL&gt; categoryList = entry.getValue();</span><br><span class="line">           categoryNotified.put(category, categoryList);</span><br><span class="line">           listener.notify(categoryList);</span><br><span class="line">           <span class="comment">// We will update our cache file after each notification.</span></span><br><span class="line">           <span class="comment">// When our Registry has a subscribe failure due to network jitter, we can return at least the existing cache URL.</span></span><br><span class="line">           saveProperties(url);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 保存服务列表到缓存和文件</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveProperties</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           StringBuilder buf = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">           Map&lt;String, List&lt;URL&gt;&gt; categoryNotified = notified.get(url);</span><br><span class="line">           <span class="keyword">if</span> (categoryNotified != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">for</span> (List&lt;URL&gt; us : categoryNotified.values()) &#123;</span><br><span class="line">                   <span class="keyword">for</span> (URL u : us) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (buf.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                           buf.append(URL_SEPARATOR);</span><br><span class="line">                       &#125;</span><br><span class="line">                       buf.append(u.toFullString());</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 保存配置对象中</span></span><br><span class="line">           properties.setProperty(url.getServiceKey(), buf.toString());</span><br><span class="line">           <span class="keyword">long</span> version = lastCacheChanged.incrementAndGet();</span><br><span class="line">           <span class="comment">// 根据版本来决定是否保存服务列表</span></span><br><span class="line">           <span class="keyword">if</span> (syncSaveFile) &#123;</span><br><span class="line">               doSaveProperties(version);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               registryCacheExecutor.execute(<span class="keyword">new</span> SaveProperties(version));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">           logger.warn(t.getMessage(), t);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>到这里，我们从注册中心获取了服务提供者的地址列表，下面我们将进一步创建invoker</p>
<h4 id="创建invoker"><a href="#创建invoker" class="headerlink" title="创建invoker"></a>创建invoker</h4><p>由上面代码5⃣️我们获取到了一个容错集群，通过容错集群，在6⃣️<code>Invoker&lt;T&gt; invoker = cluster.join(directory)</code>处我们进一步获取invoker:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MockClusterWrapper.join</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">   	<span class="comment">// FailoverCluster.join</span></span><br><span class="line">   	Invoker invoker = <span class="keyword">this</span>.cluster.join(directory);</span><br><span class="line">   	<span class="comment">// 返回invoker</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> MockClusterInvoker&lt;T&gt;(directory,invoker);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//FailoverCluster.join</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">   	AbstractClusterInvoker cluster = doJoin(directory); <span class="comment">// （1）</span></span><br><span class="line">       <span class="keyword">return</span> buildClusterInterceptors(cluster, directory.getUrl().getParameter(REFERENCE_INTERCEPTOR_KEY));<span class="comment">// （2）</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 上面（1）doJoin返回FailoverClusterInvoker</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">AbstractClusterInvoker&lt;T&gt; <span class="title">doJoin</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> FailoverClusterInvoker&lt;&gt;(directory);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 上面（2）构造集群cluster拦截器，消费端加载自动激活扩展点ConsumerContextClusterInterceptor拦截器，主要是为了设置RpcContext各项ThreadLocal参数</span></span><br><span class="line">   <span class="keyword">private</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">buildClusterInterceptors</span><span class="params">(AbstractClusterInvoker&lt;T&gt; clusterInvoker, String key)</span> </span>&#123;</span><br><span class="line">       AbstractClusterInvoker&lt;T&gt; last = clusterInvoker;</span><br><span class="line">       List&lt;ClusterInterceptor&gt; interceptors = ExtensionLoader.getExtensionLoader(ClusterInterceptor.class).getActivateExtension(clusterInvoker.getUrl(), key);</span><br><span class="line">       <span class="keyword">if</span> (!interceptors.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = interceptors.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">               <span class="keyword">final</span> ClusterInterceptor interceptor = interceptors.get(i);</span><br><span class="line">               <span class="keyword">final</span> AbstractClusterInvoker&lt;T&gt; next = last;</span><br><span class="line">               last = <span class="keyword">new</span> InterceptorInvokerNode&lt;&gt;(clusterInvoker, interceptor, next);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> last;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="对最终invoker进行代理"><a href="#对最终invoker进行代理" class="headerlink" title="对最终invoker进行代理"></a>对最终invoker进行代理</h4><p>由代码7⃣️<code>PROXY_FACTORY.getProxy(invoker, ProtocolUtils.isGeneric(generic))</code>可知，代理类是通过PROXY_FACTORY获取的，而PROXY_FACTORY是通过SPI获取，如果没有指定proxy的key，默认为javassist：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavassistProxyFactory</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (T) Proxy.getProxy(interfaces).newInstance(<span class="keyword">new</span> InvokerInvocationHandler(invoker));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Proxy通过interfaces创建代理类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Proxy <span class="title">getProxy</span><span class="params">(Class&lt;?&gt;... ics)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 先获取类加载器</span></span><br><span class="line">    <span class="keyword">return</span> getProxy(ClassUtils.getClassLoader(Proxy.class), ics);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建代理类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Proxy <span class="title">getProxy</span><span class="params">(ClassLoader cl, Class&lt;?&gt;... ics)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ics.length; i++) &#123;</span><br><span class="line">        String itf = ics[i].getName();</span><br><span class="line">        Class&lt;?&gt; tmp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tmp = Class.forName(itf, <span class="keyword">false</span>, cl);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(itf).append(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// use interface class name list as key.</span></span><br><span class="line">    String key = sb.toString();</span><br><span class="line">    <span class="comment">// get cache by class loader.</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, Object&gt; cache;</span><br><span class="line">    <span class="keyword">synchronized</span> (PROXY_CACHE_MAP) &#123;</span><br><span class="line">        cache = PROXY_CACHE_MAP.computeIfAbsent(cl, k -&gt; <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    Proxy proxy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (cache) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            Object value = cache.get(key);</span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Reference&lt;?&gt;) &#123;</span><br><span class="line">                proxy = (Proxy) ((Reference&lt;?&gt;) value).get();</span><br><span class="line">                <span class="keyword">if</span> (proxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> proxy;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (value == PENDING_GENERATION_MARKER) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cache.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cache.put(key, PENDING_GENERATION_MARKER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> id = PROXY_CLASS_COUNTER.getAndIncrement();</span><br><span class="line">    String pkg = <span class="keyword">null</span>;</span><br><span class="line">    ClassGenerator ccp = <span class="keyword">null</span>, ccm = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ccp = ClassGenerator.newInstance(cl);</span><br><span class="line">        Set&lt;String&gt; worked = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        List&lt;Method&gt; methods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ics.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(ics[i].getModifiers())) &#123;</span><br><span class="line">                String npkg = ics[i].getPackage().getName();</span><br><span class="line">                <span class="keyword">if</span> (pkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pkg = npkg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ccp.addInterface(ics[i]);</span><br><span class="line">            <span class="keyword">for</span> (Method method : ics[i].getMethods()) &#123;</span><br><span class="line">                String desc = ReflectUtils.getDesc(method);</span><br><span class="line">                <span class="keyword">if</span> (worked.contains(desc) || Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ics[i].isInterface() &amp;&amp; Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                worked.add(desc);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> ix = methods.size();</span><br><span class="line">                Class&lt;?&gt; rt = method.getReturnType();</span><br><span class="line">                Class&lt;?&gt;[] pts = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">                StringBuilder code = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Object[] args = new Object[&quot;</span>).append(pts.length).append(<span class="string">&quot;];&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pts.length; j++) &#123;</span><br><span class="line">                    code.append(<span class="string">&quot; args[&quot;</span>).append(j).append(<span class="string">&quot;] = ($w)$&quot;</span>).append(j + <span class="number">1</span>).append(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                code.append(<span class="string">&quot; Object ret = handler.invoke(this, methods[&quot;</span>).append(ix).append(<span class="string">&quot;], args);&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (!Void.TYPE.equals(rt)) &#123;</span><br><span class="line">                    code.append(<span class="string">&quot; return &quot;</span>).append(asArgument(rt, <span class="string">&quot;ret&quot;</span>)).append(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                methods.add(method);</span><br><span class="line">                ccp.addMethod(method.getName(), method.getModifiers(), rt, pts, method.getExceptionTypes(), code.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pkg = PACKAGE_NAME;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// create ProxyInstance class.</span></span><br><span class="line">        String pcn = pkg + <span class="string">&quot;.proxy&quot;</span> + id;</span><br><span class="line">        ccp.setClassName(pcn);</span><br><span class="line">        ccp.addField(<span class="string">&quot;public static java.lang.reflect.Method[] methods;&quot;</span>);</span><br><span class="line">        ccp.addField(<span class="string">&quot;private &quot;</span> + InvocationHandler.class.getName() + <span class="string">&quot; handler;&quot;</span>);</span><br><span class="line">        ccp.addConstructor(Modifier.PUBLIC, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;InvocationHandler.class&#125;, <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>], <span class="string">&quot;handler=$1;&quot;</span>);</span><br><span class="line">        ccp.addDefaultConstructor();</span><br><span class="line">        Class&lt;?&gt; clazz = ccp.toClass();</span><br><span class="line">        clazz.getField(<span class="string">&quot;methods&quot;</span>).set(<span class="keyword">null</span>, methods.toArray(<span class="keyword">new</span> Method[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">// create Proxy class.</span></span><br><span class="line">        String fcn = Proxy.class.getName() + id;</span><br><span class="line">        ccm = ClassGenerator.newInstance(cl);</span><br><span class="line">        ccm.setClassName(fcn);</span><br><span class="line">        ccm.addDefaultConstructor();</span><br><span class="line">        ccm.setSuperClass(Proxy.class);</span><br><span class="line">        ccm.addMethod(<span class="string">&quot;public Object newInstance(&quot;</span> + InvocationHandler.class.getName() + <span class="string">&quot; h)&#123; return new &quot;</span> + pcn + <span class="string">&quot;($1); &#125;&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; pc = ccm.toClass();</span><br><span class="line">        proxy = (Proxy) pc.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// release ClassGenerator</span></span><br><span class="line">        <span class="keyword">if</span> (ccp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ccp.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ccm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ccm.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (cache) &#123;</span><br><span class="line">            <span class="keyword">if</span> (proxy == <span class="keyword">null</span>) &#123;</span><br><span class="line">                cache.remove(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cache.put(key, <span class="keyword">new</span> WeakReference&lt;Proxy&gt;(proxy));</span><br><span class="line">            &#125;</span><br><span class="line">            cache.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码通过javasisst技术获取到一个代理类，然后下面再对代理对象构造器注入一个增强器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(InvokerInvocationHandler.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Invoker&lt;?&gt; invoker;</span><br><span class="line">    <span class="keyword">private</span> ConsumerModel consumerModel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvokerInvocationHandler</span><span class="params">(Invoker&lt;?&gt; handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.invoker = handler;</span><br><span class="line">        String serviceKey = invoker.getUrl().getServiceKey();</span><br><span class="line">        <span class="keyword">if</span> (serviceKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.consumerModel = ApplicationModel.getConsumerModel(serviceKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span><span class="comment">// 消费者接口代理类拦截方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(invoker, args);</span><br><span class="line">        &#125;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        <span class="keyword">if</span> (parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;toString&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> invoker.toString();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;$destroy&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">                invoker.destroy();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;hashCode&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> invoker.hashCode();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span> &amp;&amp; <span class="string">&quot;equals&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.equals(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// RPC会话类，包括rpc调用的方法，参数，返回值等属性</span></span><br><span class="line">        RpcInvocation rpcInvocation = <span class="keyword">new</span> RpcInvocation(method, invoker.getInterface().getName(), args);</span><br><span class="line">        String serviceKey = invoker.getUrl().getServiceKey();</span><br><span class="line">        rpcInvocation.setTargetServiceUniqueName(serviceKey);</span><br><span class="line">        <span class="keyword">if</span> (consumerModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            rpcInvocation.put(Constants.CONSUMER_MODEL, consumerModel);</span><br><span class="line">            rpcInvocation.put(Constants.METHOD_MODEL, consumerModel.getMethodModel(method));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(rpcInvocation).recreate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终我们获取到refer，经过反编译如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">proxy0</span> <span class="keyword">implements</span> <span class="title">ClassGenerator</span>.<span class="title">DC</span>, <span class="title">Destroyable</span>, <span class="title">EchoService</span>, <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Method[] methods;</span><br><span class="line">    <span class="keyword">private</span> InvocationHandler handler;</span><br><span class="line">    <span class="comment">// 调用sayHello，最终会委托给InvokerInvocationHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        Object[] arrobject = <span class="keyword">new</span> Object[]&#123;string&#125;;</span><br><span class="line">        Object object = <span class="keyword">this</span>.handler.invoke(<span class="keyword">this</span>, methods[<span class="number">0</span>], arrobject);</span><br><span class="line">        <span class="keyword">return</span> (String)object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture <span class="title">sayHelloAsync</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        Object[] arrobject = <span class="keyword">new</span> Object[]&#123;string&#125;;</span><br><span class="line">        Object object = <span class="keyword">this</span>.handler.invoke(<span class="keyword">this</span>, methods[<span class="number">1</span>], arrobject);</span><br><span class="line">        <span class="keyword">return</span> (CompletableFuture)object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object $echo(Object object) &#123;</span><br><span class="line">        Object[] arrobject = <span class="keyword">new</span> Object[]&#123;object&#125;;</span><br><span class="line">        Object object2 = <span class="keyword">this</span>.handler.invoke(<span class="keyword">this</span>, methods[<span class="number">2</span>], arrobject);</span><br><span class="line">        <span class="keyword">return</span> object2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> $destroy() &#123;</span><br><span class="line">        Object[] arrobject = <span class="keyword">new</span> Object[]&#123;&#125;;</span><br><span class="line">        Object object = <span class="keyword">this</span>.handler.invoke(<span class="keyword">this</span>, methods[<span class="number">3</span>], arrobject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxy0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxy0</span><span class="params">(InvocationHandler invocationHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = invocationHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h4><p>至此，我们对整个消费端的引用源码已经分析完毕，引用流程大致如下：</p>
<ul>
<li>首先对消费端的配置进行收集和组装</li>
<li>获取和连接注册中心</li>
<li>向注册中心注册消费者和订阅服务</li>
<li>根据集群和注册表创建invoker</li>
<li>最后对invoker进行动态代理，实现目标接口</li>
</ul>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ul>
<li><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh/docs/v2.7/dev/source/refer-service/">http://dubbo.apache.org/zh/docs/v2.7/dev/source/refer-service/</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">三行</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
