<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"mvilplss.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="一行知,二行理,三行本">
<meta property="og:type" content="website">
<meta property="og:title" content="三行">
<meta property="og:url" content="http://mvilplss.github.io/page/2/index.html">
<meta property="og:site_name" content="三行">
<meta property="og:description" content="一行知,二行理,三行本">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="三行">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://mvilplss.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>三行</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">三行</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">一行知,二行理,三行本</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">三行</p>
  <div class="site-description" itemprop="description">一行知,二行理,三行本</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2020/11/29/Dubbo%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%AF%BC%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/29/Dubbo%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%AF%BC%E5%87%BA/" class="post-title-link" itemprop="url">Dubbo的服务导出</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-29 00:00:00" itemprop="dateCreated datePublished" datetime="2020-11-29T00:00:00+08:00">2020-11-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:03" itemprop="dateModified" datetime="2022-07-05T22:46:03+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">开发技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Dubbo 服务导出过程始于 Spring 容器发布刷新事件，Dubbo 在接收到事件后，会立即执行服务导出逻辑。也可以通过api直接执行export进行导出。整个逻辑大致可分为三个部分，第一部分是前置工作，主要用于检查参数，组装 URL。第二部分是导出服务，包含导出服务到本地 (JVM)，和导出服务到远程两个过程。第三部分是向注册中心注册服务，用于服务发现。<br>为了方便研究源码，我们通过api直接导出服务。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>api方式导出源码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ServiceConfig&lt;DemoServiceImpl&gt; service = <span class="keyword">new</span> ServiceConfig&lt;&gt;();</span><br><span class="line">    service.setProtocol(<span class="keyword">new</span> ProtocolConfig(<span class="string">&quot;dubbo&quot;</span>));</span><br><span class="line">    service.setInterface(DemoService.class);</span><br><span class="line">    service.setRef(<span class="keyword">new</span> DemoServiceImpl());</span><br><span class="line">    service.setApplication(<span class="keyword">new</span> ApplicationConfig(<span class="string">&quot;dubbo-demo-api-provider&quot;</span>));</span><br><span class="line">    service.setRegistry(<span class="keyword">new</span> RegistryConfig(<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>));</span><br><span class="line">    service.export();<span class="comment">// 执行导出逻辑</span></span><br><span class="line">    <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>).await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dubbo源码"><a href="#dubbo源码" class="headerlink" title="dubbo源码"></a>dubbo源码</h3><h4 id="发布服务前准备"><a href="#发布服务前准备" class="headerlink" title="发布服务前准备"></a>发布服务前准备</h4><p>导出服务分为延迟导出和立即导出，最后发布导出事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 延迟导出</span></span><br><span class="line">    <span class="keyword">if</span> (shouldDelay()) &#123;</span><br><span class="line">        DELAY_EXPORT_EXECUTOR.schedule(<span class="keyword">this</span>::doExport, getDelay(), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 立即导出</span></span><br><span class="line">        doExport();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发布导出事件</span></span><br><span class="line">    exported();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doExport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    doExportUrls();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先把要导出的服务注册到服务仓库，然后根据多个协议进行循环导出</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 扩展一个服务仓库ServiceRepository，存储所有服务信息</span></span><br><span class="line">    ServiceRepository repository = ApplicationModel.getServiceRepository();</span><br><span class="line">    <span class="comment">// 注册服务</span></span><br><span class="line">    ServiceDescriptor serviceDescriptor = repository.registerService(getInterfaceClass());</span><br><span class="line">    <span class="comment">// 把服务注册到提供者缓存中</span></span><br><span class="line">    repository.registerProvider(</span><br><span class="line">            getUniqueServiceName(),</span><br><span class="line">            ref,</span><br><span class="line">            serviceDescriptor,</span><br><span class="line">            <span class="keyword">this</span>,</span><br><span class="line">            serviceMetadata</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 获取注册中心的URL</span></span><br><span class="line">    List&lt;URL&gt; registryURLs = ConfigValidationUtils.loadRegistries(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">        String pathKey = URL.buildKey(getContextPath(protocolConfig)</span><br><span class="line">                .map(p -&gt; p + <span class="string">&quot;/&quot;</span> + path)</span><br><span class="line">                .orElse(path), group, version);</span><br><span class="line">        <span class="comment">// In case user specified path, register service one more time to map it to path.</span></span><br><span class="line">        <span class="comment">// 再次注册，防止用户特殊名称路径</span></span><br><span class="line">        repository.registerService(pathKey, interfaceClass);</span><br><span class="line">        <span class="comment">// TODO, uncomment this line once service key is unified</span></span><br><span class="line">        serviceMetadata.setServiceKey(pathKey);</span><br><span class="line">        <span class="comment">// 导出其中一个协议的服务</span></span><br><span class="line">        doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="收集配置信息组装URL"><a href="#收集配置信息组装URL" class="headerlink" title="收集配置信息组装URL"></a>收集配置信息组装URL</h4><p>下面的方法比较长，主要是收集配置信息，组装URL</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line">    String name = protocolConfig.getName();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">        name = DUBBO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 收集参数到map，方便用来生成URL</span></span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(SIDE_KEY, PROVIDER_SIDE);</span><br><span class="line">    ServiceConfig.appendRuntimeParameters(map);</span><br><span class="line">    AbstractConfig.appendParameters(map, getMetrics());</span><br><span class="line">    AbstractConfig.appendParameters(map, getApplication());</span><br><span class="line">    AbstractConfig.appendParameters(map, getModule());</span><br><span class="line">    AbstractConfig.appendParameters(map, provider);</span><br><span class="line">    AbstractConfig.appendParameters(map, protocolConfig);</span><br><span class="line">    AbstractConfig.appendParameters(map, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 收集方法上的各种配置参数</span></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(getMethods())) &#123;</span><br><span class="line">        <span class="keyword">for</span> (MethodConfig method : getMethods()) &#123;</span><br><span class="line">            AbstractConfig.appendParameters(map, method, method.getName());</span><br><span class="line">            String retryKey = method.getName() + <span class="string">&quot;.retry&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(retryKey)) &#123;</span><br><span class="line">                String retryValue = map.remove(retryKey);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;false&quot;</span>.equals(retryValue)) &#123;</span><br><span class="line">                    map.put(method.getName() + <span class="string">&quot;.retries&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125; <span class="comment">// end of methods for</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ProtocolUtils.isGeneric(generic)) &#123;</span><br><span class="line">        map.put(GENERIC_KEY, generic);</span><br><span class="line">        map.put(METHODS_KEY, ANY_VALUE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String revision = Version.getVersion(interfaceClass, version);</span><br><span class="line">        <span class="keyword">if</span> (revision != <span class="keyword">null</span> &amp;&amp; revision.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            map.put(REVISION_KEY, revision);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">        <span class="keyword">if</span> (methods.length == <span class="number">0</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;No method found in service interface &quot;</span> + interfaceClass.getName());</span><br><span class="line">            map.put(METHODS_KEY, ANY_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(METHODS_KEY, StringUtils.join(<span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), <span class="string">&quot;,&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ConfigUtils.isEmpty(token) &amp;&amp; provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        token = provider.getToken();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ConfigUtils.isEmpty(token)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ConfigUtils.isDefault(token)) &#123;</span><br><span class="line">            <span class="comment">// 默认token为uuic</span></span><br><span class="line">            map.put(TOKEN_KEY, UUID.randomUUID().toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(TOKEN_KEY, token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//init serviceMetadata attachments</span></span><br><span class="line">    serviceMetadata.getAttachments().putAll(map);</span><br><span class="line">    <span class="comment">// export service</span></span><br><span class="line">    <span class="comment">// 获取当前服务所在机器的ip和端口配置</span></span><br><span class="line">    String host = findConfigedHosts(protocolConfig, registryURLs, map);</span><br><span class="line">    Integer port = findConfigedPorts(protocolConfig, name, map);</span><br><span class="line">    <span class="comment">// 根据map的参数生成一个可以导出的参数</span></span><br><span class="line">    URL url = <span class="keyword">new</span> URL(name, host, port, getContextPath(protocolConfig).map(p -&gt; p + <span class="string">&quot;/&quot;</span> + path).orElse(path), map);</span><br><span class="line">    <span class="comment">// You can customize Configurator to append extra parameters</span></span><br><span class="line">    <span class="keyword">if</span> (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">            .hasExtension(url.getProtocol())) &#123;</span><br><span class="line">        url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">                .getExtension(url.getProtocol()).getConfigurator(url).configure(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String scope = url.getParameter(SCOPE_KEY);</span><br><span class="line">    <span class="comment">// don&#x27;t export when none is configured</span></span><br><span class="line">    <span class="keyword">if</span> (!SCOPE_NONE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">        <span class="comment">// export to local if the config is not remote (export to remote only when config is remote)</span></span><br><span class="line">        <span class="keyword">if</span> (!SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">            exportLocal(url);                <span class="comment">// 默认导出本地</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// export to remote if the config is not local (export to local only when config is local)</span></span><br><span class="line">        <span class="keyword">if</span> (!SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(registryURLs)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                    <span class="comment">// For providers, this is used to enable custom proxy to generate invoker</span></span><br><span class="line">                    String proxy = url.getParameter(PROXY_KEY);</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotEmpty(proxy)) &#123;</span><br><span class="line">                        registryURL = registryURL.addParameter(PROXY_KEY, proxy);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 注册协议+导出服务协议</span></span><br><span class="line">                    URL registryURLWithExportUrl = registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString());</span><br><span class="line">                    <span class="comment">// ProxyFactory自适应扩展点根据URL的proxy的值选择代理工厂，然后创建一个ref的代理对象，并设置URL属性，默认使用javassist</span></span><br><span class="line">                    Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, registryURLWithExportUrl);</span><br><span class="line">                    <span class="comment">// Protocol自适应扩展点根据协议值选择rpc协议，默认是dubbo协议，但是协议接口有个包装类ProtocolFilterWrapper和ProtocolListenerWrapper，因此会返回包装类</span></span><br><span class="line">                    <span class="comment">// 真正调用的是ProtocolFilterWrapper.export</span></span><br><span class="line">                    <span class="comment">// 先链接注册中心，再导出服务</span></span><br><span class="line">                    DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line">                    Exporter&lt;?&gt; exporter = PROTOCOL.export(wrapperInvoker);</span><br><span class="line">                    exporters.add(exporter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.urls.add(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="服务的导出"><a href="#服务的导出" class="headerlink" title="服务的导出"></a>服务的导出</h4><p>服务的导出核心就是<code>Exporter&lt;?&gt; exporter = PROTOCOL.export(wrapperInvoker);</code>，其中PROTOCOL是通过扩展加载器获取的<code>private static final Protocol PROTOCOL = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</code>，要分析导出逻辑就要先分析PROTOCOL的真实身份。<br>下面是获取到PROTOCOL对象的class源码，从源码可以看出，最终会通过wrapperInvoker的Ulr中的protocol参数来决定加载哪个协议。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Protocol</span>$<span class="title">Adaptive</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exporter <span class="title">export</span><span class="params">(Invoker invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        String string;</span><br><span class="line">        URL uRL = invoker.getUrl();</span><br><span class="line">        String string2 = string = uRL.getProtocol() == <span class="keyword">null</span> ? <span class="string">&quot;dubbo&quot;</span> : uRL.getProtocol();</span><br><span class="line">        <span class="comment">// 根据协议名称获取目标扩展点，</span></span><br><span class="line">        Protocol protocol = (Protocol)ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(string);</span><br><span class="line">        <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dubbo支持多个协议，详细见Protocol的SPI配置：</p>
<ul>
<li><p>filter=org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper</p>
</li>
<li><p>listener=org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper</p>
</li>
<li><p>dubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol</p>
</li>
<li><p>hessian=org.apache.dubbo.rpc.protocol.hessian.HessianProtocol</p>
</li>
<li><p>http=org.apache.dubbo.rpc.protocol.http.HttpProtocol</p>
</li>
<li><p>injvm=org.apache.dubbo.rpc.protocol.injvm.InjvmProtocol</p>
</li>
<li><p>registry=org.apache.dubbo.registry.integration.RegistryProtocol</p>
</li>
<li><p>service-discovery-registry=org.apache.dubbo.registry.client.ServiceDiscoveryRegistryProtocol</p>
</li>
<li><p>…<br>由于url = registry://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-demo-api-provider&amp;dubbo=2.0.2&amp;export=dubbo://xxxxxx，因此会获取名字为registry的扩展点RegistryProtocol，<br>其中Protocol有两个Wrapper（ProtocolFilterWrapper，ProtocolListenerWrapper），那么通过自适应加载器获取到的PROTOCOL是排序最靠前的ProtocolFilterWrapper对象，执行export顺序如下：<br>ProtocolFilterWrapper.export() 》ProtocolListenerWrapper.export() 》 RegistryProtocol.export()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProtocolFilterWrapper</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UrlUtils.isRegistry(invoker.getUrl())) &#123;<span class="comment">// 如果是registry继续往下传递</span></span><br><span class="line">        <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> protocol.export(buildInvokerChain(invoker, SERVICE_FILTER_KEY, CommonConstants.PROVIDER));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ProtocolListenerWrapper</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UrlUtils.isRegistry(invoker.getUrl())) &#123;<span class="comment">// 如果是registry继续往下传递</span></span><br><span class="line">        <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListenerExporterWrapper&lt;T&gt;(protocol.export(invoker),</span><br><span class="line">            Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener.class)</span><br><span class="line">                    .getActivateExtension(invoker.getUrl(), EXPORTER_LISTENER_KEY)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RegistryProtocol</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">    URL providerUrl = getProviderUrl(originInvoker);</span><br><span class="line">    <span class="comment">//export invoker 真正开始导出服务</span></span><br><span class="line">    <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker, providerUrl);</span><br><span class="line">    <span class="comment">// url to registry</span></span><br><span class="line">    <span class="comment">// 创建和链接注册中心</span></span><br><span class="line">    <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">    <span class="keyword">final</span> URL registeredProviderUrl = getUrlToRegistry(providerUrl, registryUrl);</span><br><span class="line">    <span class="comment">// decide if we need to delay publish</span></span><br><span class="line">    <span class="keyword">boolean</span> register = providerUrl.getParameter(REGISTER_KEY, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (register) &#123;</span><br><span class="line">        register(registryUrl, registeredProviderUrl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// register stated url on provider model</span></span><br><span class="line">    registerStatedUrl(registryUrl, registeredProviderUrl, register);</span><br><span class="line">    exporter.setRegisterUrl(registeredProviderUrl);</span><br><span class="line">    exporter.setSubscribeUrl(overrideSubscribeUrl);</span><br><span class="line">    <span class="comment">// 通知协议导出后监听器</span></span><br><span class="line">    notifyExport(exporter);</span><br><span class="line">    <span class="comment">//Ensure that a new exporter instance is returned every time export</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DestroyableExporter&lt;&gt;(exporter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>导出服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">ExporterChangeableWrapper&lt;T&gt; <span class="title">doLocalExport</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker, URL providerUrl)</span> </span>&#123;</span><br><span class="line">    String key = getCacheKey(originInvoker);</span><br><span class="line">    <span class="keyword">return</span> (ExporterChangeableWrapper&lt;T&gt;) bounds.computeIfAbsent(key, s -&gt; &#123;</span><br><span class="line">        Invoker&lt;?&gt; invokerDelegate = <span class="keyword">new</span> InvokerDelegate&lt;&gt;(originInvoker, providerUrl);</span><br><span class="line">        <span class="comment">// 此时的invoker的url协议为dubbo，那么protocol的实例对象就是对应者DubboProtocol</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExporterChangeableWrapper&lt;&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegate), originInvoker);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>导出服务时候和上面导出协议类似，第一个protocol实例就是ProtocolFilterWrapper，执行顺序为：<br>ProtocolFilterWrapper.export() 》ProtocolListenerWrapper.export() 》 DubboProtocol.export()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProtocolFilterWrapper</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (UrlUtils.isRegistry(invoker.getUrl())) &#123;</span><br><span class="line">            <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 非注册协议，建立过滤器调用链</span></span><br><span class="line">        <span class="keyword">return</span> protocol.export(buildInvokerChain(invoker, SERVICE_FILTER_KEY, CommonConstants.PROVIDER));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ProtocolListenerWrapper</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (UrlUtils.isRegistry(invoker.getUrl())) &#123;</span><br><span class="line">            <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 非注册协议，调用导出监听器exported方法（此处感觉有点早）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListenerExporterWrapper&lt;T&gt;(protocol.export(invoker),</span><br><span class="line">                Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener.class)</span><br><span class="line">                        .getActivateExtension(invoker.getUrl(), EXPORTER_LISTENER_KEY)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// DubboProtocol 执行真正的导出</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        URL url = invoker.getUrl();</span><br><span class="line">        <span class="comment">// export service.</span></span><br><span class="line">        String key = serviceKey(url);<span class="comment">// org.apache.dubbo.demo.DemoService:20880</span></span><br><span class="line">        DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">        exporterMap.put(key, exporter);<span class="comment">// 缓存</span></span><br><span class="line">        <span class="comment">// 开启服务并导出</span></span><br><span class="line">        openServer(url);</span><br><span class="line">        optimizeSerialization(url);</span><br><span class="line">        <span class="keyword">return</span> exporter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// find server.</span></span><br><span class="line">        String key = url.getAddress();<span class="comment">// 192.168.32.216:20880</span></span><br><span class="line">        <span class="keyword">boolean</span> isServer = url.getParameter(IS_SERVER_KEY, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">            ProtocolServer server = serverMap.get(key);</span><br><span class="line">            <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    server = serverMap.get(key);</span><br><span class="line">                    <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 创建服务</span></span><br><span class="line">                        serverMap.put(key, createServer(url));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> ProtocolServer <span class="title">createServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        url = URLBuilder.from(url)</span><br><span class="line">                .addParameterIfAbsent(CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString())</span><br><span class="line">                .addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT))</span><br><span class="line">                .addParameter(CODEC_KEY, DubboCodec.NAME)</span><br><span class="line">                .build();</span><br><span class="line">        String str = url.getParameter(SERVER_KEY, DEFAULT_REMOTING_SERVER);<span class="comment">// 默认netty</span></span><br><span class="line">        <span class="comment">// 判断协议是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Unsupported server type: &quot;</span> + str + <span class="string">&quot;, url: &quot;</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        ExchangeServer server;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用交换机发起绑定服务</span></span><br><span class="line">            <span class="comment">// requestHandler 就是当服务被调用时候的处理逻辑</span></span><br><span class="line">            server = Exchangers.bind(url, requestHandler);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Fail to start server(url: &quot;</span> + url + <span class="string">&quot;) &quot;</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回服务</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DubboProtocolServer(server);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>过滤器调用链的创建细节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">buildInvokerChain</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; invoker, String key, String group)</span> </span>&#123;</span><br><span class="line">    Invoker&lt;T&gt; last = invoker;</span><br><span class="line">    <span class="comment">// 根据url和key及分组获取所有过滤器</span></span><br><span class="line">    List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);</span><br><span class="line">    <span class="comment">// 将过滤器封装为Invoker，并形成一个调用链</span></span><br><span class="line">    <span class="keyword">if</span> (!filters.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = filters.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">final</span> Filter filter = filters.get(i);</span><br><span class="line">            <span class="keyword">final</span> Invoker&lt;T&gt; next = last;</span><br><span class="line">            last = <span class="keyword">new</span> Invoker&lt;T&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">                    Result asyncResult;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        asyncResult = filter.invoke(next, invocation);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (filter <span class="keyword">instanceof</span> ListenableFilter) &#123;</span><br><span class="line">                            ListenableFilter listenableFilter = ((ListenableFilter) filter);</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                Filter.Listener listener = listenableFilter.listener(invocation);</span><br><span class="line">                                <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    listener.onError(e, invoker, invocation);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                listenableFilter.removeListener(invocation);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (filter <span class="keyword">instanceof</span> Filter.Listener) &#123;</span><br><span class="line">                            Filter.Listener listener = (Filter.Listener) filter;</span><br><span class="line">                            listener.onError(e, invoker, invocation);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个调用链的大致源码如下，通过next链接下一个，调用者调用invoker传入下一个调用者next：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invoker在FilterChainMaker中的匿名类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterChainMaker_1</span> <span class="keyword">implements</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> InvokerFilter filter;</span><br><span class="line">    <span class="keyword">final</span> Invoker next;</span><br><span class="line"></span><br><span class="line">    FilterChainMaker_1(InvokerFilter invokerFilter, Invoker invoker) &#123;</span><br><span class="line">        <span class="keyword">this</span>.filter = invokerFilter;</span><br><span class="line">        <span class="keyword">this</span>.next = invoker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">invoke</span><span class="params">(String doing)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.filter.invoke(<span class="keyword">this</span>.next, doing);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="绑定服务"><a href="#绑定服务" class="headerlink" title="绑定服务"></a>绑定服务</h4><p>打开和创建一个服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    String key = url.getAddress();<span class="comment">// org.apache.dubbo.demo.DemoService:20880</span></span><br><span class="line">    <span class="keyword">boolean</span> isServer = url.getParameter(IS_SERVER_KEY, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">        ProtocolServer server = serverMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 防止重复绑定</span></span><br><span class="line">                server = serverMap.get(key);</span><br><span class="line">                <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 创建一个服务</span></span><br><span class="line">                    serverMap.put(key, createServer(url));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            server.reset(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ProtocolServer <span class="title">createServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 完善url，设置必要参数</span></span><br><span class="line">    url = URLBuilder.from(url)</span><br><span class="line">            .addParameterIfAbsent(CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString())</span><br><span class="line">            .addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT))</span><br><span class="line">            .addParameter(CODEC_KEY, DubboCodec.NAME)</span><br><span class="line">            .build();</span><br><span class="line">    String str = url.getParameter(SERVER_KEY, DEFAULT_REMOTING_SERVER);<span class="comment">// 默认netty</span></span><br><span class="line">    ExchangeServer server;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 绑定服务</span></span><br><span class="line">        server = Exchangers.bind(url, requestHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemotingException e) &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DubboProtocolServer(server);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Exchangers.bind(url, requestHandler)</code>，将服务绑定到某个网络服务上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Exchangers</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;handler == null&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class="string">&quot;exchange&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> getExchanger(url).bind(url, handler);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Exchanger <span class="title">getExchanger</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 交换器是header（头部交换器，协议在头部），返回HeaderExchanger</span></span><br><span class="line">     String type = url.getParameter(Constants.EXCHANGER_KEY, Constants.DEFAULT_EXCHANGER);</span><br><span class="line">     <span class="keyword">return</span> getExchanger(type);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//HeaderExchanger.bind();</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">     <span class="comment">// 创建头部交换处理器</span></span><br><span class="line">     HeaderExchangeHandler headerExchangeHandler = <span class="keyword">new</span> HeaderExchangeHandler(handler);</span><br><span class="line">     <span class="comment">// 解码处理器</span></span><br><span class="line">     DecodeHandler decodeHandler = <span class="keyword">new</span> DecodeHandler(headerExchangeHandler);</span><br><span class="line">     <span class="comment">// 解码器绑定到网络传输器上</span></span><br><span class="line">     RemotingServer remotingServer = Transporters.bind(url, decodeHandler);</span><br><span class="line">     <span class="comment">// 创建交换服务，并将远程服务注入</span></span><br><span class="line">     HeaderExchangeServer headerExchangeServer = <span class="keyword">new</span> HeaderExchangeServer(remotingServer);</span><br><span class="line">     <span class="keyword">return</span> headerExchangeServer;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><code>Transporters.bind(url, decodeHandler)</code>，绑定地址和解码器到某个网络服务上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RemotingServer <span class="title">bind</span><span class="params">(URL url, ChannelHandler... handlers)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handlers == <span class="keyword">null</span> || handlers.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;handlers == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ChannelHandler handler;</span><br><span class="line">    <span class="keyword">if</span> (handlers.length == <span class="number">1</span>) &#123;</span><br><span class="line">        handler = handlers[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handler = <span class="keyword">new</span> ChannelHandlerDispatcher(handlers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取网络传输器，绑定地址和解码器</span></span><br><span class="line">    <span class="keyword">return</span> getTransporter().bind(url, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取网络传输器自动适应扩展，根据url上的Server_key=netty可知为：NettyServer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Transporter <span class="title">getTransporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(Transporter.class).getAdaptiveExtension();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// NettyServer</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RemotingServer <span class="title">bind</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NettyServer(url, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// NettyServer.super</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractServer</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(url, handler);</span><br><span class="line">    localAddress = getUrl().toInetSocketAddress();</span><br><span class="line">    String bindIp = getUrl().getParameter(Constants.BIND_IP_KEY, getUrl().getHost());</span><br><span class="line">    <span class="keyword">int</span> bindPort = getUrl().getParameter(Constants.BIND_PORT_KEY, getUrl().getPort());</span><br><span class="line">    <span class="keyword">if</span> (url.getParameter(ANYHOST_KEY, <span class="keyword">false</span>) || NetUtils.isInvalidLocalHost(bindIp)) &#123;</span><br><span class="line">        bindIp = ANYHOST_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    bindAddress = <span class="keyword">new</span> InetSocketAddress(bindIp, bindPort);</span><br><span class="line">    <span class="keyword">this</span>.accepts = url.getParameter(ACCEPTS_KEY, DEFAULT_ACCEPTS);</span><br><span class="line">    <span class="keyword">this</span>.idleTimeout = url.getParameter(IDLE_TIMEOUT_KEY, DEFAULT_IDLE_TIMEOUT);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 开启网络服务</span></span><br><span class="line">        doOpen();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    executor = executorRepository.createExecutorIfAbsent(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处的逻辑就是把服务的处理器绑定到某个网络端口上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    NettyHelper.setNettyLoggerFactory();</span><br><span class="line">    ExecutorService boss = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">&quot;NettyServerBoss&quot;</span>, <span class="keyword">true</span>));</span><br><span class="line">    ExecutorService worker = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">&quot;NettyServerWorker&quot;</span>, <span class="keyword">true</span>));</span><br><span class="line">    ChannelFactory channelFactory = <span class="keyword">new</span> NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));</span><br><span class="line">    bootstrap = <span class="keyword">new</span> ServerBootstrap(channelFactory);</span><br><span class="line">    <span class="keyword">final</span> NettyHandler nettyHandler = <span class="keyword">new</span> NettyHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">    channels = nettyHandler.getChannels();</span><br><span class="line">    bootstrap.setOption(<span class="string">&quot;child.tcpNoDelay&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">    bootstrap.setOption(<span class="string">&quot;backlog&quot;</span>, getUrl().getPositiveParameter(BACKLOG_KEY, Constants.DEFAULT_BACKLOG));</span><br><span class="line">    bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line">        <span class="comment">// 设置通道的rpc解码，编码，和处理器</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ChannelPipeline <span class="title">getPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class="keyword">this</span>);</span><br><span class="line">            ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, adapter.getDecoder());</span><br><span class="line">            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, adapter.getEncoder());</span><br><span class="line">            pipeline.addLast(<span class="string">&quot;handler&quot;</span>, nettyHandler);</span><br><span class="line">            <span class="keyword">return</span> pipeline;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// netty服务绑定到某个端口上</span></span><br><span class="line">    channel = bootstrap.bind(getBindAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，服务已经绑定到某个网络传输服务的端口上。下面将介绍服务是如何注册到某个注册中心的。</p>
<h4 id="服务的注册"><a href="#服务的注册" class="headerlink" title="服务的注册"></a>服务的注册</h4><p>在上面服务导出后，需要注册到注册中心，注册方式如下，我们以zookeeper为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegistryProtocol</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//export invoker 真正开始导出服务</span></span><br><span class="line">    <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker, providerUrl);</span><br><span class="line">    <span class="comment">// url to registry</span></span><br><span class="line">    <span class="comment">// 根据spi创建和链接注册中心获取的是ListenerRegistryWrapper</span></span><br><span class="line">    <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">    <span class="keyword">final</span> URL registeredProviderUrl = getUrlToRegistry(providerUrl, registryUrl);</span><br><span class="line">    <span class="comment">// decide if we need to delay publish</span></span><br><span class="line">    <span class="keyword">boolean</span> register = providerUrl.getParameter(REGISTER_KEY, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (register) &#123;</span><br><span class="line">        register(registryUrl, registeredProviderUrl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// register stated url on provider model</span></span><br><span class="line">    registerStatedUrl(registryUrl, registeredProviderUrl, register);</span><br><span class="line">    exporter.setRegisterUrl(registeredProviderUrl);</span><br><span class="line">    exporter.setSubscribeUrl(overrideSubscribeUrl);</span><br><span class="line">    <span class="comment">// 通知协议导出后监听器</span></span><br><span class="line">    notifyExport(exporter);</span><br><span class="line">    <span class="comment">//Ensure that a new exporter instance is returned every time export</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DestroyableExporter&lt;&gt;(exporter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL registryUrl, URL registeredProviderUrl)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此处根据spi获取的是ListenerRegistryWrapper</span></span><br><span class="line">    Registry registry = registryFactory.getRegistry(registryUrl);</span><br><span class="line">    registry.register(registeredProviderUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ListenerRegistryWrapper的register为的是注册后通知注册监听器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用ZookeeperRegistry.的父类的register方法</span></span><br><span class="line">            registry.register(url);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 通知注册监听器</span></span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(listeners)) &#123;</span><br><span class="line">                RuntimeException exception = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (RegistryServiceListener listener : listeners) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            listener.onRegister(url);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (RuntimeException t) &#123;</span><br><span class="line">                            logger.error(t.getMessage(), t);</span><br><span class="line">                            exception = t;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> exception;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用ZookeeperRegistry的父类FailbackRegistry的register方法，最终调用到自身的doRegister方法，通过zk客户端向zookeeper中创建持久节点（dubbo/xx.service.xxx/provider/)和临时节点(rpc请求协议地址dubbo://xxx.xxx)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZookeeperRegistry</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        zkClient.create(toUrlPath(url), url.getParameter(DYNAMIC_KEY, <span class="keyword">true</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Failed to register &quot;</span> + url + <span class="string">&quot; to zookeeper &quot;</span> + getUrl() + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ZookeeperClient</span></span><br><span class="line"><span class="comment">// 创建zk节点，注册服务</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(String path, <span class="keyword">boolean</span> ephemeral)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ephemeral) &#123;</span><br><span class="line">        <span class="keyword">if</span>(persistentExistNodePath.contains(path))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (checkExists(path)) &#123;</span><br><span class="line">            persistentExistNodePath.add(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = path.lastIndexOf(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 递归创建上级持久路径</span></span><br><span class="line">        create(path.substring(<span class="number">0</span>, i), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ephemeral) &#123;</span><br><span class="line">        <span class="comment">// 创建临时协议</span></span><br><span class="line">        createEphemeral(path);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createPersistent(path);</span><br><span class="line">        persistentExistNodePath.add(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="服务注册后逻辑"><a href="#服务注册后逻辑" class="headerlink" title="服务注册后逻辑"></a>服务注册后逻辑</h4><p>通知注册协议监听器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegistryProtocol</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">notifyExport</span><span class="params">(ExporterChangeableWrapper&lt;T&gt; exporter)</span> </span>&#123;</span><br><span class="line">    List&lt;RegistryProtocolListener&gt; listeners = ExtensionLoader.getExtensionLoader(RegistryProtocolListener.class)</span><br><span class="line">            .getActivateExtension(exporter.getOriginInvoker().getUrl(), <span class="string">&quot;registry.protocol.listener&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(listeners)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (RegistryProtocolListener listener : listeners) &#123;</span><br><span class="line">            listener.onExport(<span class="keyword">this</span>, exporter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发布服务已导出事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServiceConfig</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exported</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dispatch a ServiceConfigExportedEvent since 2.7.4</span></span><br><span class="line">    dispatch(<span class="keyword">new</span> ServiceConfigExportedEvent(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">    EventDispatcher.getDefaultExtension().dispatch(event);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractEventDispatcher</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">    Executor executor = getExecutor();</span><br><span class="line">    <span class="comment">// execute in sequential or parallel execution model</span></span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        sortedListeners(entry -&gt; entry.getKey().isAssignableFrom(event.getClass()))</span><br><span class="line">                .forEach(listener -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (listener <span class="keyword">instanceof</span> ConditionalEventListener) &#123;</span><br><span class="line">                        ConditionalEventListener predicateEventListener = (ConditionalEventListener) listener;</span><br><span class="line">                        <span class="keyword">if</span> (!predicateEventListener.accept(event)) &#123; <span class="comment">// No accept</span></span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Handle the event</span></span><br><span class="line">                    listener.onEvent(event);</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里整个服务的导出和注册就结束了。</p>
<h4 id="大致的流程总结"><a href="#大致的流程总结" class="headerlink" title="大致的流程总结"></a>大致的流程总结</h4></li>
</ul>
<ol>
<li>获取和组装配置参数，并将参数组装为要导出的服务URL和协议URL</li>
<li>根据注册中心的Url的协议register://，获取RegistryProtocol扩展点，连接注册中心</li>
<li>再次根据服务的Url的协议dubbo://,获取DubboProtocol扩展点，然后将服务绑定到netty服务上完成服务导出</li>
<li>根据注册中心的客户端在zookeeper中创建服务节点，完成服务注册</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh/docs/v2.7/dev/source/export-service/">http://dubbo.apache.org/zh/docs/v2.7/dev/source/export-service/</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2020/11/22/Dubbo%E7%9A%84SPI%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/22/Dubbo%E7%9A%84SPI%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Dubbo的SPI分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-22 00:00:00" itemprop="dateCreated datePublished" datetime="2020-11-22T00:00:00+08:00">2020-11-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:03" itemprop="dateModified" datetime="2022-07-05T22:46:03+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">开发技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。SPI 机制在第三方框架中也有所应用，比如 Dubbo 就是通过 SPI 机制加载所有的组件。不过，Dubbo 并未使用 Java 原生的 SPI 机制，而是对其进行了增强，使其能够更好的满足需求。</p>
<h2 id="普通SPI"><a href="#普通SPI" class="headerlink" title="普通SPI"></a>普通SPI</h2><h3 id="Java-SPI-示例"><a href="#Java-SPI-示例" class="headerlink" title="Java SPI 示例"></a>Java SPI 示例</h3><h4 id="定义接口和实现类"><a href="#定义接口和实现类" class="headerlink" title="定义接口和实现类"></a>定义接口和实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnimalHoo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hoo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatHoo</span> <span class="keyword">implements</span> <span class="title">AnimalHoo</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;喵喵...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogHoo</span> <span class="keyword">implements</span> <span class="title">AnimalHoo</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汪汪...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定义spi配置"><a href="#定义spi配置" class="headerlink" title="定义spi配置"></a>定义spi配置</h4><p>在resources/META-INF/services目录下增加spi配置文件，文件名称为接口的全限定名：<code>org.apache.dubbo.demo.spi.AnimalHoo</code>，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.apache.dubbo.demo.spi.CatHoo</span><br><span class="line">org.apache.dubbo.demo.spi.DogHoo</span><br></pre></td></tr></table></figure>
<h4 id="执行测试代码"><a href="#执行测试代码" class="headerlink" title="执行测试代码"></a>执行测试代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboSpiTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_java_spi</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServiceLoader&lt;AnimalHoo&gt; animalHoos = ServiceLoader.load(AnimalHoo.class);</span><br><span class="line">        animalHoos.forEach(animalHoo -&gt; &#123;</span><br><span class="line">            animalHoo.hoo();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">喵喵...</span><br><span class="line">汪汪...</span><br></pre></td></tr></table></figure>
<h3 id="dubbo-spi-示例"><a href="#dubbo-spi-示例" class="headerlink" title="dubbo spi 示例"></a>dubbo spi 示例</h3><h4 id="接口和实现类"><a href="#接口和实现类" class="headerlink" title="接口和实现类"></a>接口和实现类</h4><p>接口和Java的spi实现方式多了注解<code>@SPI</code>，value为默认的扩展实现类名称</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;cat&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnimalHoo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hoo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatHoo</span> <span class="keyword">implements</span> <span class="title">AnimalHoo</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;喵喵...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogHoo</span> <span class="keyword">implements</span> <span class="title">AnimalHoo</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汪汪...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>和Java Spi配置类似在resources/META-INF/dubbo目录下增加spi配置文件，文件名称为接口的全限定名：<code>org.apache.dubbo.demo.spi.AnimalHoo</code>，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat&#x3D;org.apache.dubbo.demo.spi.CatHoo</span><br><span class="line">dog&#x3D;org.apache.dubbo.demo.spi.DogHoo</span><br></pre></td></tr></table></figure>
<h4 id="执行测试代码-1"><a href="#执行测试代码-1" class="headerlink" title="执行测试代码"></a>执行测试代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboSpiTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_dubbo_spi</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExtensionLoader&lt;AnimalHoo&gt; extensionLoader = ExtensionLoader.getExtensionLoader(AnimalHoo.class);</span><br><span class="line">        AnimalHoo defaultExtension = extensionLoader.getDefaultExtension();</span><br><span class="line">        defaultExtension.hoo();</span><br><span class="line">        AnimalHoo cat = extensionLoader.getExtension(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">        cat.hoo();</span><br><span class="line">        AnimalHoo dog = extensionLoader.getExtension(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">        dog.hoo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">喵喵...</span><br><span class="line">喵喵...</span><br><span class="line">汪汪...</span><br></pre></td></tr></table></figure>
<h2 id="dubbo-SPI-源码分析"><a href="#dubbo-SPI-源码分析" class="headerlink" title="dubbo SPI 源码分析"></a>dubbo SPI 源码分析</h2><h4 id="获取扩展加载器"><a href="#获取扩展加载器" class="headerlink" title="获取扩展加载器"></a>获取扩展加载器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ExtensionLoader&lt;T&gt; <span class="title">getExtensionLoader</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 试着从缓存中获取扩展加载器</span></span><br><span class="line">       ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">       <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 获取不到时候，初始化一个扩展加载器</span></span><br><span class="line">           EXTENSION_LOADERS.putIfAbsent(type, <span class="keyword">new</span> ExtensionLoader&lt;T&gt;(type));</span><br><span class="line">           loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> loader;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 其中objectFactory的类型是在new ExtensionLoader时候通过自适应扩展获取的，下面会详细介绍自适应扩展</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">ExtensionLoader</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.type = type;</span><br><span class="line">       objectFactory = (type == ExtensionFactory.class ? <span class="keyword">null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="通过扩展加载器获取扩展对象"><a href="#通过扩展加载器获取扩展对象" class="headerlink" title="通过扩展加载器获取扩展对象"></a>通过扩展加载器获取扩展对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取扩展对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getExtension(name, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getExtension</span><span class="params">(String name, <span class="keyword">boolean</span> wrap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 试着从缓存中获取扩展对象的持有者，如果缓存中没有则创建一个</span></span><br><span class="line">    <span class="keyword">final</span> Holder&lt;Object&gt; holder = getOrCreateHolder(name);</span><br><span class="line">    Object instance = holder.get();</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">            instance = holder.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建扩展对象</span></span><br><span class="line">                instance = createExtension(name, wrap);</span><br><span class="line">                holder.set(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name, <span class="keyword">boolean</span> wrap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据扩展对象名称获取类</span></span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过放射进行初始化，然后放入到缓存中</span></span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩展对象属性注入</span></span><br><span class="line">        injectExtension(instance);</span><br><span class="line">        <span class="comment">// 获取包装类</span></span><br><span class="line">        <span class="keyword">if</span> (wrap) &#123;</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; wrapperClassesList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (cachedWrapperClasses != <span class="keyword">null</span>) &#123;</span><br><span class="line">                wrapperClassesList.addAll(cachedWrapperClasses);</span><br><span class="line">                wrapperClassesList.sort(WrapperComparator.COMPARATOR);</span><br><span class="line">                Collections.reverse(wrapperClassesList);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(wrapperClassesList)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClassesList) &#123;</span><br><span class="line">                    Wrapper wrapper = wrapperClass.getAnnotation(Wrapper.class);</span><br><span class="line">                    <span class="keyword">if</span> (wrapper == <span class="keyword">null</span></span><br><span class="line">                            || (ArrayUtils.contains(wrapper.matches(), name) &amp;&amp; !ArrayUtils.contains(wrapper.mismatches(), name))) &#123;</span><br><span class="line">                        <span class="comment">// 如果是包装类，则对包装类进行注入此扩展对象，然后返回包装类对象</span></span><br><span class="line">                        <span class="comment">// 多个包装对象根据排序从小到大成为一个调用链</span></span><br><span class="line">                        instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  如果扩展类实现类Lifecycle接口，则会调用initialize方法进行初始化</span></span><br><span class="line">        initExtension(instance);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取扩展类</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">    <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">            classes = cachedClasses.get();</span><br><span class="line">            <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 加载所有扩展类放置缓存中</span></span><br><span class="line">                classes = loadExtensionClasses();</span><br><span class="line">                cachedClasses.set(classes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加载所有扩展类</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (LoadingStrategy strategy : strategies) &#123;</span><br><span class="line">        loadDirectory(extensionClasses, strategy.directory(), type.getName(), strategy.preferExtensionClassLoader(), strategy.overridden(), strategy.excludedPackages());</span><br><span class="line">        <span class="comment">// 向后兼容，更改路径再加载一次</span></span><br><span class="line">        loadDirectory(extensionClasses, strategy.directory(), type.getName().replace(<span class="string">&quot;org.apache&quot;</span>, <span class="string">&quot;com.alibaba&quot;</span>), strategy.preferExtensionClassLoader(), strategy.overridden(), strategy.excludedPackages());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> extensionClasses;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加载策略的获取</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LoadingStrategy[] loadLoadingStrategies() &#123;</span><br><span class="line">    <span class="comment">//  这里用到到的是Java spi的加载方法，会加载到三个策略对象，每个策略对象对应一个配置目录</span></span><br><span class="line">    <span class="comment">//org.apache.dubbo.common.extension.DubboInternalLoadingStrategy</span></span><br><span class="line">    <span class="comment">//org.apache.dubbo.common.extension.DubboLoadingStrategy</span></span><br><span class="line">    <span class="comment">//org.apache.dubbo.common.extension.ServicesLoadingStrategy</span></span><br><span class="line">    <span class="keyword">return</span> stream(ServiceLoader.load(LoadingStrategy.class).spliterator(), <span class="keyword">false</span>)</span><br><span class="line">            .sorted()</span><br><span class="line">            .toArray(LoadingStrategy[]::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载扩展的文件目录</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadDirectory</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir, String type,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> extensionLoaderClassLoaderFirst, <span class="keyword">boolean</span> overridden, String... excludedPackages)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 约定的地址 /META-INFO/dubbo/+type</span></span><br><span class="line">    String fileName = dir + type;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Enumeration&lt;java.net.URL&gt; urls = <span class="keyword">null</span>;</span><br><span class="line">        ClassLoader classLoader = findClassLoader();</span><br><span class="line">        urls = classLoader.getResources(fileName);</span><br><span class="line">        <span class="keyword">if</span> (urls != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">                java.net.URL resourceURL = urls.nextElement();</span><br><span class="line">                <span class="comment">// 根据文件路径获取加载资源</span></span><br><span class="line">                loadResource(extensionClasses, classLoader, resourceURL, overridden, excludedPackages);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加载扩展类资源</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadResource</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, ClassLoader classLoader,</span></span></span><br><span class="line"><span class="function"><span class="params">                          java.net.URL resourceURL, <span class="keyword">boolean</span> overridden, String... excludedPackages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(resourceURL.openStream(), StandardCharsets.UTF_8))) &#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> ci = line.indexOf(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    line = line.substring(<span class="number">0</span>, ci);</span><br><span class="line">                &#125;</span><br><span class="line">                line = line.trim();</span><br><span class="line">                <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String name = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> i = line.indexOf(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            name = line.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">                            line = line.substring(i + <span class="number">1</span>).trim();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span> &amp;&amp; !isExcluded(line, excludedPackages)) &#123;</span><br><span class="line">                            <span class="comment">// 获取class对象</span></span><br><span class="line">                            loadClass(extensionClasses, resourceURL, Class.forName(line, <span class="keyword">true</span>, classLoader), name, overridden);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        IllegalStateException e = <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to load extension class (interface: &quot;</span> + type + <span class="string">&quot;, class line: &quot;</span> + line + <span class="string">&quot;) in &quot;</span> + resourceURL + <span class="string">&quot;, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">                        exceptions.put(line, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Exception occurred when loading extension class (interface: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;, class file: &quot;</span> + resourceURL + <span class="string">&quot;) in &quot;</span> + resourceURL, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将扩展class根据注解进行分类缓存</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadClass</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> overridden)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class="line">            <span class="comment">// 缓存自适应扩展类</span></span><br><span class="line">            cacheAdaptiveClass(clazz, overridden);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWrapperClass(clazz)) &#123;</span><br><span class="line">            <span class="comment">// 缓存包装类</span></span><br><span class="line">            cacheWrapperClass(clazz);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clazz.getConstructor();</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">                name = findAnnotationName(clazz);</span><br><span class="line">                <span class="keyword">if</span> (name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No such extension name for the class &quot;</span> + clazz.getName() + <span class="string">&quot; in the config &quot;</span> + resourceURL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] names = NAME_SEPARATOR.split(name);</span><br><span class="line">            <span class="keyword">if</span> (ArrayUtils.isNotEmpty(names)) &#123;</span><br><span class="line">                <span class="comment">// 缓存激活类</span></span><br><span class="line">                cacheActivateClass(clazz, names[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">for</span> (String n : names) &#123;</span><br><span class="line">                    <span class="comment">// 缓存普通扩展点</span></span><br><span class="line">                    cacheName(clazz, n);</span><br><span class="line">                    saveInExtensionClass(extensionClasses, clazz, n, overridden);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展对象注入自适应属性或spring的bean</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">injectExtension</span><span class="params">(T instance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (objectFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isSetter(method)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String property = getSetterProperty(method);</span><br><span class="line">                Object object = objectFactory.getExtension(pt, property);</span><br><span class="line">                <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    method.invoke(instance, object);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="扩展类执行流程总结"><a href="#扩展类执行流程总结" class="headerlink" title="扩展类执行流程总结"></a>扩展类执行流程总结</h4><p>上面通过代码执行过程介绍了一个完整的基本的获取扩展对象的，基本流程如下：</p>
<ol>
<li>ExtensionLoader.getExtensionLoader获取扩展加载器，先尝试在缓存中获取，否则进行new一个对象并缓存起来</li>
<li>调用getExtension通过名称获取扩展对象，先尝试从缓存获取，否则创建一个扩展对象</li>
<li>先从缓存中获取中获取扩展对象类，如果类缓存不存在则进行加载类缓存<ul>
<li>加载扩展类前先获取加载策略集合，然后循环策略执行loadDirectory方法</li>
<li>最终调用loadResource方法，通过类资源加载器获取spi扩展配置文件，然后解析文件的实现类全限定名称，通过Class.forName加载到jvm中</li>
<li>然后在对每个class根据注解和构造方法进行分别缓存到自适应类缓存（类上@Adaptive）、自动激活类缓存、普通扩展类缓存，包装类（根据构造函数判断）</li>
</ul>
</li>
<li>通过class类型尝试从内存中获取扩展对象，否则进行通过反射进行初始化对象</li>
<li>然后根据扩展类是否有setter方法尝试注入扩展对象</li>
<li>判断此类是否有包装类，如果有则对通过包装类的构造器注入此对象，然后返回此包装类对象</li>
<li>再根据扩展类是否实现了Lifecycle接口来调用initialize方法进行自定义初始化</li>
<li>最后设置对象到holder缓存并返回扩展对象</li>
</ol>
<h2 id="dubbo自适应SPI扩展"><a href="#dubbo自适应SPI扩展" class="headerlink" title="dubbo自适应SPI扩展"></a>dubbo自适应SPI扩展</h2><p>在 Dubbo 中，很多拓展都是通过 SPI 机制进行加载的，比如 Protocol、Cluster、LoadBalance 等。有时，有些拓展并不想在框架启动阶段被加载，而是希望在拓展方法被调用时，根据运行时参数进行加载。Dubbo 通过自适应拓展机制很好的解决了。自适应拓展机制的实现逻辑比较复杂，首先 Dubbo 会为拓展接口生成具有代理功能的代码。然后通过 javassist 或 jdk 编译这段代码，得到 Class 类。最后再通过反射创建代理类，当调用自适应类的方法时候，代理类会根据传入的参数自动获取一个对象。</p>
<h3 id="自适应spi示例"><a href="#自适应spi示例" class="headerlink" title="自适应spi示例"></a>自适应spi示例</h3><h4 id="定义接口和实现类-1"><a href="#定义接口和实现类-1" class="headerlink" title="定义接口和实现类"></a>定义接口和实现类</h4><p>模拟dubbo的负载均衡自适应实现方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Balance</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Adaptive(&quot;loadbalance&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">(URL url)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashBalance</span> <span class="keyword">implements</span> <span class="title">Balance</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一致性负载均衡&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomBalance</span> <span class="keyword">implements</span> <span class="title">Balance</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是随机负载均衡&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h4><p>和Java Spi配置类似在resources/META-INF/dubbo目录下增加spi配置文件，文件名称为接口的全限定名：<code>org.apache.dubbo.demo.spi.Balance</code>，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">consistent&#x3D;org.apache.dubbo.demo.spi.ConsistentHashBalance</span><br><span class="line">random&#x3D;org.apache.dubbo.demo.spi.RandomBalance</span><br></pre></td></tr></table></figure>
<h4 id="执行测试代码-2"><a href="#执行测试代码-2" class="headerlink" title="执行测试代码"></a>执行测试代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_dubbo_spi_adaptive</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ExtensionLoader&lt;Balance&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Balance.class);</span><br><span class="line">    Balance balance = extensionLoader.getAdaptiveExtension();</span><br><span class="line">    balance.select(URL.valueOf(<span class="string">&quot;dubbo://xxx.xxx.Xx?loadbalance=consistent&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我是一致性负载均衡</span><br></pre></td></tr></table></figure>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>第一步同样先获取类扩展加载器，这里不在重复介绍。<br>然后获取自适应扩展对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取自适应对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object instance = cachedAdaptiveInstance.get();</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">            instance = cachedAdaptiveInstance.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 创建自适应对象</span></span><br><span class="line">                    instance = createAdaptiveExtension();</span><br><span class="line">                    cachedAdaptiveInstance.set(instance);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建自适应对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; adaptiveExtensionClass = getAdaptiveExtensionClass();</span><br><span class="line">        Object o = adaptiveExtensionClass.newInstance();</span><br><span class="line">        <span class="comment">// 注入扩展对象</span></span><br><span class="line">        <span class="keyword">return</span> injectExtension((T) o);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取扩展对象类</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">    <span class="comment">// 上面已经介绍过，加载所有SPI类，然后分门别类的进行缓存</span></span><br><span class="line">    getExtensionClasses();</span><br><span class="line">    <span class="comment">// 判断是否有缓存</span></span><br><span class="line">    <span class="keyword">if</span> (cachedAdaptiveClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cachedAdaptiveClass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个自适应类</span></span><br><span class="line">    <span class="keyword">return</span> cachedAdaptiveClass = createAdaptiveExtensionClass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建自适应类</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class="line">    <span class="comment">// 调用自适应代码生成器生成自适器java代码</span></span><br><span class="line">    String code = <span class="keyword">new</span> AdaptiveClassCodeGenerator(type, cachedDefaultName).generate();</span><br><span class="line">    ClassLoader classLoader = findClassLoader();</span><br><span class="line">    <span class="comment">// 获取自适应编译器</span></span><br><span class="line">    org.apache.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class="line">    <span class="comment">// 对生成的自适应java代码进行编译和加载</span></span><br><span class="line">    <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成自适应器的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Balance</span>$<span class="title">Adaptive</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Balance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(URL uRL)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uRL == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        URL uRL2 = uRL;</span><br><span class="line">        String string = uRL2.getParameter(<span class="string">&quot;loadbalance&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (string == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="keyword">new</span> StringBuffer().append(<span class="string">&quot;Failed to get extension (org.apache.dubbo.demo.spi.Balance) name from url (&quot;</span>).append(uRL2.toString()).append(<span class="string">&quot;) use keys([loadbalance])&quot;</span>).toString());</span><br><span class="line">        &#125;</span><br><span class="line">        Balance balance = (Balance)ExtensionLoader.getExtensionLoader(Balance.class).getExtension(string);</span><br><span class="line">        balance.select(uRL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由源码可以看出，自适应扩展其实就是在普通扩展基础上对接口生成了一个代理类，由代理类根据入参进行判断执行某个实现类的同名方法。</p>
<h4 id="自适应扩展执行流程总结"><a href="#自适应扩展执行流程总结" class="headerlink" title="自适应扩展执行流程总结"></a>自适应扩展执行流程总结</h4><ol>
<li>同样先调用ExtensionLoader.getExtensionLoader获取扩展加载器，先尝试在缓存中获取，否则进行new一个对象并缓存起来</li>
<li>调用getAdaptiveExtension获取自适应扩展对象，先尝试从缓存获取，否则创建一个扩展对象</li>
<li>先执行getExtensionClasses加载和缓存所有类<ul>
<li>加载扩展类前先获取加载策略集合，然后循环策略执行loadDirectory方法</li>
<li>最终调用loadResource方法，通过类资源加载器获取spi扩展配置文件，然后解析文件的实现类全限定名称，通过Class.forName加载到jvm中</li>
<li>然后在对每个class根据注解和构造方法进行分别缓存到自适应类缓存（类上@Adaptive）、自动激活类缓存、普通扩展类缓存，包装类（根据构造函数判断）</li>
</ul>
</li>
<li>判断是否已经缓存或自适应代理类，否则生成一个自适应代理类<ul>
<li>new一个自适应代码生成器，然后生成一个自适应代理类Java模版代码</li>
<li>然后根据SPI获取自适应编译器，然后进行Java代码的编译和加载到jvm中</li>
</ul>
</li>
<li>然后根据setter方法尝试注入扩展对象</li>
<li>最后设置对象到holder缓存并返回自适应扩展代理对象<h4 id="自适应类的其他用法"><a href="#自适应类的其他用法" class="headerlink" title="自适应类的其他用法"></a>自适应类的其他用法</h4>如果某个实现类加上@Adaptive，那么这个实现类就是这个接口的自适应扩展类，无需再生成代理类，当默认生成的自适应代理类不满足我们的需求时候可以自行实现。<br>示例如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Adaptive</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BalanceAdaptive</span> <span class="keyword">implements</span> <span class="title">Balance</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果为null则默认使用random，而非抛异常</span></span><br><span class="line">        <span class="keyword">if</span> (url==<span class="keyword">null</span>)&#123;</span><br><span class="line">            Balance random = ExtensionLoader.getExtensionLoader(Balance.class).getExtension(<span class="string">&quot;random&quot;</span>);</span><br><span class="line">            random.select(url);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            String loadbalance = url.getParameter(<span class="string">&quot;loadbalance&quot;</span>);</span><br><span class="line">            Balance random = ExtensionLoader.getExtensionLoader(Balance.class).getExtension(loadbalance);</span><br><span class="line">            random.select(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="包装类型的扩展"><a href="#包装类型的扩展" class="headerlink" title="包装类型的扩展"></a>包装类型的扩展</h3><h4 id="扩展包装类示例"><a href="#扩展包装类示例" class="headerlink" title="扩展包装类示例"></a>扩展包装类示例</h4>假如我们要对某个接口下的扩展类进行包装，则可以对接口实现一个扩展类，示例如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatHooWrapper</span> <span class="keyword">implements</span> <span class="title">AnimalHoo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AnimalHoo animalHoo;</span><br><span class="line">    <span class="comment">// 构造方法必须固定这么写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CatHooWrapper</span><span class="params">(AnimalHoo animalHoo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.animalHoo = animalHoo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当执行此接口下的扩展类，则会执行此方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;包装类执行前&quot;</span>);</span><br><span class="line">        animalHoo.hoo();</span><br><span class="line">        System.out.println(<span class="string">&quot;包装类执行前&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name, <span class="keyword">boolean</span> wrap)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> findException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        injectExtension(instance);</span><br><span class="line">        <span class="comment">// 判断是否进行返回包装类</span></span><br><span class="line">        <span class="keyword">if</span> (wrap) &#123;</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; wrapperClassesList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// cachedWrapperClasses是在getExtensionClasses时候，根据构造函数类型已经做了缓存</span></span><br><span class="line">            <span class="comment">// 对包装类进行排序，先排序，然后倒叙，然后在下面循环的时候，保证返回正序的第一个</span></span><br><span class="line">            <span class="keyword">if</span> (cachedWrapperClasses != <span class="keyword">null</span>) &#123;</span><br><span class="line">                wrapperClassesList.addAll(cachedWrapperClasses);</span><br><span class="line">                wrapperClassesList.sort(WrapperComparator.COMPARATOR);</span><br><span class="line">                Collections.reverse(wrapperClassesList);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(wrapperClassesList)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClassesList) &#123;</span><br><span class="line">                    Wrapper wrapper = wrapperClass.getAnnotation(Wrapper.class);</span><br><span class="line">                    <span class="keyword">if</span> (wrapper == <span class="keyword">null</span></span><br><span class="line">                            || (ArrayUtils.contains(wrapper.matches(), name) &amp;&amp; !ArrayUtils.contains(wrapper.mismatches(), name))) &#123;</span><br><span class="line">                        <span class="comment">// 通过构造器注入扩展对象和实例化包装类对象</span></span><br><span class="line">                        instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        initExtension(instance);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="包装类的调用过程"><a href="#包装类的调用过程" class="headerlink" title="包装类的调用过程"></a>包装类的调用过程</h4><ol>
<li>同样先调用ExtensionLoader.getExtensionLoader获取扩展加载器，先尝试在缓存中获取，否则进行new一个对象并缓存起来</li>
<li>调用getExtension获取扩展对象，先尝试从缓存获取，否则创建一个扩展对象</li>
<li>先执行getExtensionClasses加载和缓存所有类<ul>
<li>加载扩展类前先获取加载策略集合，然后循环策略执行loadDirectory方法</li>
<li>最终调用loadResource方法，通过类资源加载器获取spi扩展配置文件，然后解析文件的实现类全限定名称，通过Class.forName加载到jvm中</li>
<li>然后在对每个class根据注解和构造方法进行分别缓存到自适应类缓存（类上@Adaptive）、自动激活类缓存、普通扩展类缓存，包装类（根据构造函数判断）缓存</li>
</ul>
</li>
<li>判断是加载包装类wrap=true<ul>
<li>判断缓存中（cachedWrapperClasses）是否有包装类</li>
<li>对包装类进行倒叙排序，然后循环通过构造函数注入扩展对象并实例化包装类，多个包装类形成调用链，返回最小的排序</li>
</ul>
</li>
<li>再根据扩展类是否实现了Lifecycle接口来调用initialize方法进行自定义初始化</li>
<li>最后设置对象到holder缓存并返回自适应扩展代理对象<blockquote>
<p>dubbo使用包装类的有ProtocolFilterWrapper（生成过滤器调用链）和ProtocolListenerWrapper。</p>
</blockquote>
</li>
</ol>
<h3 id="自动激活扩展点"><a href="#自动激活扩展点" class="headerlink" title="自动激活扩展点"></a>自动激活扩展点</h3><ul>
<li>当某些扩展点不想使用自适应同时又想通过参数获取时候可以考虑使用自动扩展方式：可以通过url中的参数名称获取。</li>
<li>当某写扩展点无论是否指定都要执行的时候可以考虑使用扩展点：无论是否指定，当获取当前接口下的扩展点时候自动加入带@Active的扩展类。</li>
<li>当通过某个参数获取一组扩展点，可以使用group来指定要获取扩展点的一组名称<h4 id="示例如下"><a href="#示例如下" class="headerlink" title="示例如下"></a>示例如下</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(URL ull)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 服务提供者分组</span></span><br><span class="line"><span class="meta">@Activate(group = &quot;provider&quot;,value = &quot;filterName&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderAccLogFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(URL ull)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProviderAccLogFilter... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Activate(group = &quot;provider&quot;,value = &quot;filterName&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderLimitFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(URL ull)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProviderLimitFilter... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消费者分组</span></span><br><span class="line"><span class="meta">@Activate(group = &quot;consumer&quot;,value = &quot;filterName&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerAccLogFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(URL ull)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConsumerAccLogFilter... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Activate(group = &quot;consumer&quot;,value = &quot;filterName&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerLimitFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(URL ull)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConsumerLimitFilter... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无名者</span></span><br><span class="line"><span class="meta">@Activate</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(URL ull)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AllFilter... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="执行测试代码-3"><a href="#执行测试代码-3" class="headerlink" title="执行测试代码"></a>执行测试代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_dubbo_spi_active</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ExtensionLoader&lt;Filter&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Filter.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;=======不指定组========&quot;</span>);</span><br><span class="line">    List&lt;Filter&gt; filters = extensionLoader.getActivateExtension(URL.valueOf(<span class="string">&quot;dubbo://xxx.xxx.Xx?filterName=allFilter,&quot;</span>), <span class="string">&quot;filterName&quot;</span>);</span><br><span class="line">    filters.forEach(filter -&gt; &#123;</span><br><span class="line">        filter.invoke(<span class="keyword">null</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;=======不指定组，用自定义key========&quot;</span>);</span><br><span class="line">    filters = extensionLoader.getActivateExtension(URL.valueOf(<span class="string">&quot;dubbo://xxx.xxx.Xx?myFilterName=providerAccLogFilter,&quot;</span>), <span class="string">&quot;myFilterName&quot;</span>);</span><br><span class="line">    filters.forEach(filter -&gt; &#123;</span><br><span class="line">        filter.invoke(<span class="keyword">null</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;========指定组=======&quot;</span>);</span><br><span class="line">    filters = extensionLoader.getActivateExtension(URL.valueOf(<span class="string">&quot;dubbo://xxx.xxx.Xx?filterName=consumerAccLogFilter&quot;</span>), <span class="string">&quot;filterName&quot;</span>,<span class="string">&quot;consumer&quot;</span>);</span><br><span class="line">    filters.forEach(filter -&gt; &#123;</span><br><span class="line">        filter.invoke(<span class="keyword">null</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;========指定组，用组外扩展名=======&quot;</span>);</span><br><span class="line">    filters = extensionLoader.getActivateExtension(URL.valueOf(<span class="string">&quot;dubbo://xxx.xxx.Xx?filterName=providerAccLogFilter&quot;</span>), <span class="string">&quot;filterName&quot;</span>,<span class="string">&quot;consumer&quot;</span>);</span><br><span class="line">    filters.forEach(filter -&gt; &#123;</span><br><span class="line">        filter.invoke(<span class="keyword">null</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;========指定组，用自定义key=======&quot;</span>);</span><br><span class="line">    filters = extensionLoader.getActivateExtension(URL.valueOf(<span class="string">&quot;dubbo://xxx.xxx.Xx?myFilterName=providerAccLogFilter,&quot;</span>), <span class="string">&quot;myFilterName&quot;</span>,<span class="string">&quot;provider&quot;</span>);</span><br><span class="line">    filters.forEach(filter -&gt; &#123;</span><br><span class="line">        filter.invoke(<span class="keyword">null</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;不指定组&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">ProviderAccLogFilter... </span><br><span class="line">ConsumerLimitFilter... </span><br><span class="line">ConsumerAccLogFilter... </span><br><span class="line">ProviderLimitFilter... </span><br><span class="line">AllFilter... </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;不指定组，用自定义key&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">AllFilter... </span><br><span class="line">ProviderAccLogFilter... </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;指定组&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">ConsumerLimitFilter... </span><br><span class="line">ConsumerAccLogFilter... </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;指定组，用组外扩展名&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">ConsumerLimitFilter... </span><br><span class="line">ConsumerAccLogFilter... </span><br><span class="line">ProviderAccLogFilter... </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;指定组，用自定义key&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">ProviderAccLogFilter... </span><br></pre></td></tr></table></figure>
由结果可以得出结论：</li>
<li>不指定组，使用默认key，加载所有扩展点</li>
<li>不指定组，使用自定义key的，只有名称匹配和不指定key的被加载</li>
<li>指定组，只加载组中的扩展点</li>
<li>指定组，指定组外的扩展点名称，则加载指定扩展点和组内扩展点</li>
<li>指定组，用自定义key则只加载组中名称匹配的扩展点<h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String[] values, String group)</span> </span>&#123;</span><br><span class="line">    List&lt;T&gt; activateExtensions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; names = values == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">0</span>) : asList(values);</span><br><span class="line">    <span class="comment">// 如果名称不包含-default的则进行加载</span></span><br><span class="line">    <span class="keyword">if</span> (!names.contains(REMOVE_VALUE_PREFIX + DEFAULT_KEY)) &#123;</span><br><span class="line">        getExtensionClasses();</span><br><span class="line">        <span class="comment">// 获取所有自动激活扩展类并循环</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : cachedActivates.entrySet()) &#123;</span><br><span class="line">            String name = entry.getKey();</span><br><span class="line">            Object activate = entry.getValue();</span><br><span class="line">            String[] activateGroup, activateValue;</span><br><span class="line">            <span class="comment">// 获取Activate注解中的配置</span></span><br><span class="line">            <span class="keyword">if</span> (activate <span class="keyword">instanceof</span> Activate) &#123;</span><br><span class="line">                activateGroup = ((Activate) activate).group();</span><br><span class="line">                activateValue = ((Activate) activate).value();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (activate <span class="keyword">instanceof</span> com.alibaba.dubbo.common.extension.Activate) &#123;</span><br><span class="line">                activateGroup = ((com.alibaba.dubbo.common.extension.Activate) activate).group();</span><br><span class="line">                activateValue = ((com.alibaba.dubbo.common.extension.Activate) activate).value();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  </span></span><br><span class="line">            <span class="keyword">if</span> (isMatchGroup(group, activateGroup)<span class="comment">// 指定组并且相同组，或则不指定组</span></span><br><span class="line">                    &amp;&amp; !names.contains(name) <span class="comment">// 指定名称不包含此扩展点名称</span></span><br><span class="line">                    &amp;&amp; !names.contains(REMOVE_VALUE_PREFIX + name)<span class="comment">// 不包含&quot;-&quot;+name</span></span><br><span class="line">                    &amp;&amp; isActive(activateValue, url)) <span class="comment">// url中包括此key</span></span><br><span class="line">                &#123;</span><br><span class="line">                activateExtensions.add(getExtension(name));<span class="comment">// 加载扩展点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 做正序排序，比如多个自动激活过滤器，先后执行就是此处控制的</span></span><br><span class="line">        activateExtensions.sort(ActivateComparator.COMPARATOR);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;T&gt; loadedExtensions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 加载指定名称的扩展点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.size(); i++) &#123;</span><br><span class="line">        String name = names.get(i);</span><br><span class="line">        <span class="keyword">if</span> (!name.startsWith(REMOVE_VALUE_PREFIX)</span><br><span class="line">                &amp;&amp; !names.contains(REMOVE_VALUE_PREFIX + name)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEFAULT_KEY.equals(name)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!loadedExtensions.isEmpty()) &#123;</span><br><span class="line">                    activateExtensions.addAll(<span class="number">0</span>, loadedExtensions);</span><br><span class="line">                    loadedExtensions.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                loadedExtensions.add(getExtension(name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!loadedExtensions.isEmpty()) &#123;</span><br><span class="line">        activateExtensions.addAll(loadedExtensions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> activateExtensions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自动激活扩展点的调用过程"><a href="#自动激活扩展点的调用过程" class="headerlink" title="自动激活扩展点的调用过程"></a>自动激活扩展点的调用过程</h4></li>
</ul>
<ol>
<li>同样先调用ExtensionLoader.getExtensionLoader获取扩展加载器，先尝试在缓存中获取，否则进行new一个对象并缓存起来</li>
<li>调用getActivateExtension获取自动激活对象集合</li>
<li>先执行getExtensionClasses加载和缓存所有类<ul>
<li>加载扩展类前先获取加载策略集合，然后循环策略执行loadDirectory方法</li>
<li>最终调用loadResource方法，通过类资源加载器获取spi扩展配置文件，然后解析文件的实现类全限定名称，通过Class.forName加载到jvm中</li>
<li>然后在对每个class根据注解和构造方法进行分别缓存到自适应类缓存（类上@Adaptive）、自动激活类缓存、普通扩展类缓存，包装类（根据构造函数判断）缓存</li>
</ul>
</li>
<li>循环当前接口的所有自动激活的类缓存<ul>
<li>获取Activate注解中的配置</li>
<li>判断是否配置组或组相同&amp;&amp;未指定此扩展名称&amp;&amp;不是开头”-“&amp;&amp;url中包含此扩展指定的key名称</li>
<li>然后加载服务条件的扩展点</li>
</ul>
</li>
<li>然后在加载指定名称的扩展点</li>
<li>最后合并所有扩展点，然后返回扩展点集合</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh/docs/v2.7/dev/source/adaptive-extension/">http://dubbo.apache.org/zh/docs/v2.7/dev/source/adaptive-extension/</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2020/11/20/Dubbo%E7%9A%84%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/20/Dubbo%E7%9A%84%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">Dubbo的简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-11-20T00:00:00+08:00">2020-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:03" itemprop="dateModified" datetime="2022-07-05T22:46:03+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">开发技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Dubbo是什么？"><a href="#Dubbo是什么？" class="headerlink" title="Dubbo是什么？"></a>Dubbo是什么？</h2><p>Apache Dubbo是一款高性能、轻量级的开源服务框架。</p>
<h2 id="开发团队"><a href="#开发团队" class="headerlink" title="开发团队"></a>开发团队</h2><p>Dubbo共有六个开发人员参与开发和测试，每一个开发人员都是很有经验，团队合作很默契，开发过程也很有节奏，有完善质量保障流程。团队组成：<br>梁飞 （开发人员/产品管理）<br>刘昊旻 （开发人员/过程管理）<br>刘超 （开发人员/用户支持）<br>李鼎 （开发人员/用户支持）<br>陈雷 （开发人员/质量保障）<br>闾刚 （开发人员/开源运维）<br><img src="https://raw.githubusercontent.com/mvilplss/note/master/image/.Dubbo%E7%9A%84%E7%AE%80%E4%BB%8B_images/9c4e1f67.png"><br>从左至右：刘超，梁飞，闾刚，陈雷，刘昊旻，李鼎</p>
<h2 id="Dubbo有哪些核心能力"><a href="#Dubbo有哪些核心能力" class="headerlink" title="Dubbo有哪些核心能力"></a>Dubbo有哪些核心能力</h2><h3 id="面向接口代理的高性能RPC调用"><a href="#面向接口代理的高性能RPC调用" class="headerlink" title="面向接口代理的高性能RPC调用"></a>面向接口代理的高性能RPC调用</h3><p>提供高性能的基于代理的远程调用能力，服务以接口为粒度，为开发者屏蔽远程调用底层细节。</p>
<h3 id="集群容错和负载均衡"><a href="#集群容错和负载均衡" class="headerlink" title="集群容错和负载均衡"></a>集群容错和负载均衡</h3><p>内置多种负载均衡策略，智能感知下游节点健康状况，显著减少调用延迟，提高系统吞吐量。</p>
<h3 id="服务自动注册和发现"><a href="#服务自动注册和发现" class="headerlink" title="服务自动注册和发现"></a>服务自动注册和发现</h3><p>支持多种注册中心服务，服务实例上下线实时感知。</p>
<h3 id="高度可扩展能力"><a href="#高度可扩展能力" class="headerlink" title="高度可扩展能力"></a>高度可扩展能力</h3><p>遵循微内核+插件的设计原则，所有核心能力如Protocol、Transport、Serialization被设计为扩展点，平等对待内置实现和第三方实现。</p>
<h3 id="运行期流量调度"><a href="#运行期流量调度" class="headerlink" title="运行期流量调度"></a>运行期流量调度</h3><p>内置条件、脚本等路由策略，通过配置不同的路由规则，轻松实现灰度发布，同机房优先等功能。</p>
<h3 id="可视化的服务治理与运维"><a href="#可视化的服务治理与运维" class="headerlink" title="可视化的服务治理与运维"></a>可视化的服务治理与运维</h3><p>提供丰富服务治理、运维工具：随时查询服务元数据、服务健康状态及调用统计，实时下发路由策略、调整配置参数。</p>
<h2 id="dubbo的框架设计"><a href="#dubbo的框架设计" class="headerlink" title="dubbo的框架设计"></a>dubbo的框架设计</h2><p><img src="https://raw.githubusercontent.com/mvilplss/note/master/image/.Dubbo%E7%9A%84%E7%AE%80%E4%BB%8B_images/7a9403f0.png"></p>
<h3 id="各层说明"><a href="#各层说明" class="headerlink" title="各层说明"></a>各层说明</h3><ul>
<li>config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li>
<li>proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory</li>
<li>registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService</li>
<li>cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance</li>
<li>monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService</li>
<li>protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</li>
<li>exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</li>
<li>transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec</li>
<li>serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool<h3 id="模块依赖关系"><a href="#模块依赖关系" class="headerlink" title="模块依赖关系"></a>模块依赖关系</h3><img src="https://raw.githubusercontent.com/mvilplss/note/master/image/.Dubbo%E7%9A%84%E7%AE%80%E4%BB%8B_images/4eb8663e.png"><h3 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h3><img src="https://raw.githubusercontent.com/mvilplss/note/master/image/.Dubbo%E7%9A%84%E7%AE%80%E4%BB%8B_images/6f2cc26e.png"><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2></li>
<li><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh/docs/v2.7/dev/design/">http://dubbo.apache.org/zh/docs/v2.7/dev/design/</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2020/11/02/Java%E7%9F%A5%E8%AF%86%E9%97%AE%E7%AD%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/02/Java%E7%9F%A5%E8%AF%86%E9%97%AE%E7%AD%94/" class="post-title-link" itemprop="url">Java知识问答(极客学习笔记)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-02 00:00:00" itemprop="dateCreated datePublished" datetime="2020-11-02T00:00:00+08:00">2020-11-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:03" itemprop="dateModified" datetime="2022-07-05T22:46:03+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">开发技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="Exception和Error有什么区别？"><a href="#Exception和Error有什么区别？" class="headerlink" title="Exception和Error有什么区别？"></a>Exception和Error有什么区别？</h2><ol>
<li>Exception和Error都是继承了Throwable类，在Java中只有Throwable类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。</li>
<li>Exception和Error体现了Java平台设计者对不同异常情况的分类。Exception是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。</li>
<li>Error是指在正常情况下，不大可能出现的情况，绝大部分的Error都会导致程序（比如JVM自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如OutOfMemoryError之类，都是Error的子类。</li>
<li>Exception又分为可检查（checked）异常和不检查（unchecked）异常，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。前面我介绍的不可查的Error，是Throwable不是Exception。<br>不检查异常就是所谓的运行时异常，类似 NullPointerException、ArrayIndexOutOfBoundsException之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。<h2 id="谈谈final、finally、-finalize有什么不同？"><a href="#谈谈final、finally、-finalize有什么不同？" class="headerlink" title="谈谈final、finally、 finalize有什么不同？"></a>谈谈final、finally、 finalize有什么不同？</h2></li>
</ol>
<ul>
<li>final可以用来修饰类、方法、变量，分别有不同的意义，final修饰的class代表不可以继承扩展，final的变量是不可以修改的，而final的方法也是不可以重写的（override）。</li>
<li>finally则是Java保证重点代码一定要被执行的一种机制。我们可以使用try-finally或者try-catch-finally来进行类似关闭JDBC连接、保证unlock锁等动作。</li>
<li>finalize是基础类java.lang.Object的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize机制现在已经不推荐使用，并且在JDK 9开始被标记为deprecated。<h2 id="强引用、软引用、弱引用、幻象引用有什么区别？"><a href="#强引用、软引用、弱引用、幻象引用有什么区别？" class="headerlink" title="强引用、软引用、弱引用、幻象引用有什么区别？"></a>强引用、软引用、弱引用、幻象引用有什么区别？</h2>不同的引用类型，主要体现的是对象不同的可达性（reachable）状态和对垃圾收集的影响。</li>
</ul>
<ol>
<li>所谓强引用（“Strong” Reference），就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略。</li>
<li>软引用（SoftReference），是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当JVM认为内存不足时，才会去试图回收软引用指向的对象。JVM会确保在抛出OutOfMemoryError之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</li>
<li>弱引用（WeakReference）并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。</li>
<li>对于幻象引用，有时候也翻译成虚引用，你不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被finalize以后，做某些事情的机制，比如，通常用来做所谓的Post-Mortem清理机制，我在专栏上一讲中介绍的Java平台自身Cleaner机制等，也有人利用幻象引用监控对象的创建和销毁。<h2 id="String、StringBuffer、StringBuilder有什么区别？"><a href="#String、StringBuffer、StringBuilder有什么区别？" class="headerlink" title="String、StringBuffer、StringBuilder有什么区别？"></a>String、StringBuffer、StringBuilder有什么区别？</h2></li>
</ol>
<ul>
<li>String是Java语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的Immutable类，被声明成为final class，所有属性也都是final的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的String对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。</li>
<li>StringBuffer是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用append或者add方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是StringBuilder。</li>
<li>StringBuilder是Java 1.5中新增的，在能力上和StringBuffer没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。<h2 id="动态代理是基于什么原理？"><a href="#动态代理是基于什么原理？" class="headerlink" title="动态代理是基于什么原理？"></a>动态代理是基于什么原理？</h2>编程语言通常有各种不同的分类角度，动态类型和静态类型就是其中一种分类角度，简单区分就是语言类型信息是在运行时检查，还是编译期检查。<br>与其近似的还有一个对比，就是所谓强类型和弱类型，就是不同类型变量赋值时，是否需要显式地（强制）进行类型转换。<br>那么，如何分类Java语言呢？通常认为，Java是静态的强类型语言，但是因为提供了类似反射等机制，也具备了部分动态类型语言的能力。<br>言归正传，今天我要问你的问题是，谈谈Java反射机制，动态代理是基于什么原理？<h2 id="int和Integer有什么区别？"><a href="#int和Integer有什么区别？" class="headerlink" title="int和Integer有什么区别？"></a>int和Integer有什么区别？</h2></li>
<li>int是我们常说的整形数字，是Java的8个原始数据类型（Primitive Types，boolean、byte 、short、char、int、float、double、long）之一。Java语言虽然号称一切都是对象，但原始数据类型是例外。</li>
<li>Integer是int对应的包装类，它有一个int类型的字段存储数据，并且提供了基本操作，比如数学运算、int和字符串之间转换等。在Java 5中，引入了自动装箱和自动拆箱功能（boxing/unboxing），Java可以根据上下文，自动进行转换，极大地简化了相关编程。<br>关于Integer的值缓存，这涉及Java 5中另一个改进。构建Integer对象的传统方式是直接调用构造器，直接new一个对象。但是根据实践，我们发现大部分数据操作都是集中在有限的、较小的数值范围，因而，在Java 5中新增了静态工厂方法valueOf，在调用它的时候会利用一个缓存机制，带来了明显的性能改进。按照Javadoc，这个值默认缓存是-128到127之间。<h2 id="对比Vector、ArrayList、LinkedList有何区别？"><a href="#对比Vector、ArrayList、LinkedList有何区别？" class="headerlink" title="对比Vector、ArrayList、LinkedList有何区别？"></a>对比Vector、ArrayList、LinkedList有何区别？</h2>这三者都是实现集合框架中的List，也就是所谓的有序集合，因此具体功能也比较近似，比如都提供按照位置进行定位、添加或者删除的操作，都提供迭代器以遍历其内容等。但因为具体的设计区别，在行为、性能、线程安全等方面，表现又有很大不同。</li>
<li>Vector是Java早期提供的线程安全的动态数组，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。</li>
<li>ArrayList是应用更加广泛的动态数组实现，它本身不是线程安全的，所以性能要好很多。与Vector近似，ArrayList也是可以根据需要调整容量，不过两者的调整逻辑有所区别，Vector在扩容时会提高1倍，而ArrayList则是增加50%。</li>
<li>LinkedList顾名思义是Java提供的双向链表，所以它不需要像上面两种那样调整容量，它也不是线程安全的。<h2 id="对比Hashtable、HashMap、TreeMap有什么不同？"><a href="#对比Hashtable、HashMap、TreeMap有什么不同？" class="headerlink" title="对比Hashtable、HashMap、TreeMap有什么不同？"></a>对比Hashtable、HashMap、TreeMap有什么不同？</h2></li>
<li>Hashtable、HashMap、TreeMap都是最常见的一些Map实现，是以键值对的形式存储和操作数据的容器类型。</li>
<li>Hashtable是早期Java类库提供的一个哈希表实现，本身是同步的，不支持null键和值，由于同步导致的性能开销，所以已经很少被推荐使用。</li>
<li>HashMap是应用更加广泛的哈希表实现，行为上大致上与HashTable一致，主要区别在于HashMap不是同步的，支持null键和值等。通常情况下，HashMap进行put或者get操作，可以达到常数时间的性能，所以它是绝大部分利用键值对存取场景的首选，比如，实现一个用户ID和用户信息对应的运行时存储结构。</li>
<li>TreeMap则是基于红黑树的一种提供顺序访问的Map，和HashMap不同，它的get、put、remove之类操作都是O（log(n)）的时间复杂度，具体顺序可以由指定的Comparator来决定，或者根据键的自然顺序来判断。<h2 id="如何保证集合是线程安全的-ConcurrentHashMap如何实现高效地线程安全"><a href="#如何保证集合是线程安全的-ConcurrentHashMap如何实现高效地线程安全" class="headerlink" title="如何保证集合是线程安全的? ConcurrentHashMap如何实现高效地线程安全"></a>如何保证集合是线程安全的? ConcurrentHashMap如何实现高效地线程安全</h2>Java提供了不同层面的线程安全支持。在传统集合框架内部，除了Hashtable等同步容器，还提供了所谓的同步包装器（Synchronized Wrapper），我们可以调用Collections工具类提供的包装方法，来获取一个同步的包装容器（如Collections.synchronizedMap），但是它们都是利用非常粗粒度的同步方式，在高并发情况下，性能比较低下。<br>另外，更加普遍的选择是利用并发包提供的线程安全容器类，它提供了：</li>
<li>各种并发容器，比如ConcurrentHashMap、CopyOnWriteArrayList。</li>
<li>各种线程安全队列（Queue/Deque），如ArrayBlockingQueue、SynchronousQueue。</li>
<li>各种有序容器的线程安全版本等。<br>具体保证线程安全的方式，包括有从简单的synchronize方式，到基于更加精细化的，比如基于分离锁实现的ConcurrentHashMap等并发实现等。具体选择要看开发的场景需求，总体来说，并发包内提供的容器通用场景，远优于早期的简单同步实现。<h2 id="Java提供了哪些IO方式？-NIO如何实现多路复用？"><a href="#Java提供了哪些IO方式？-NIO如何实现多路复用？" class="headerlink" title="Java提供了哪些IO方式？ NIO如何实现多路复用？"></a>Java提供了哪些IO方式？ NIO如何实现多路复用？</h2>Java IO方式有很多种，基于不同的IO抽象模型和交互方式，可以进行简单区分。</li>
<li>首先，传统的java.io包，它基于流模型实现，提供了我们最熟知的一些IO功能，比如File抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。<br>java.io包的好处是代码比较简单、直观，缺点则是IO效率和扩展性存在局限性，容易成为应用性能的瓶颈。<br>很多时候，人们也把java.net下面提供的部分网络API，比如Socket、ServerSocket、HttpURLConnection也归类到同步阻塞IO类库，因为网络通信同样是IO行为。</li>
<li>第二，在Java 1.4中引入了NIO框架（java.nio包），提供了Channel、Selector、Buffer等新的抽象，可以构建多路复用的、同步非阻塞IO程序，同时提供了更接近操作系统底层的高性能数据操作方式。</li>
<li>第三，在Java 7中，NIO有了进一步的改进，也就是NIO 2，引入了异步非阻塞IO方式，也有很多人叫它AIO（Asynchronous IO）。异步IO操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。<h2 id="Java有几种文件拷贝方式？哪一种最高效？"><a href="#Java有几种文件拷贝方式？哪一种最高效？" class="headerlink" title="Java有几种文件拷贝方式？哪一种最高效？"></a>Java有几种文件拷贝方式？哪一种最高效？</h2>Java有多种比较典型的文件拷贝实现方式，比如：<br>利用java.io类库，直接为源文件构建一个FileInputStream读取，然后再为目标文件构建一个FileOutputStream，完成写入工作。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void copyFileByStream(File source, File dest) throws</span><br><span class="line">        IOException &#123;</span><br><span class="line">    try (InputStream is = new FileInputStream(source);</span><br><span class="line">         OutputStream os = new FileOutputStream(dest);)&#123;</span><br><span class="line">        byte[] buffer = new byte[1024];</span><br><span class="line">        int length;</span><br><span class="line">        while ((length = is.read(buffer)) &gt; 0) &#123;</span><br><span class="line">            os.write(buffer, 0, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
或者，利用java.nio类库提供的transferTo或transferFrom方法实现。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void copyFileByChannel(File source, File dest) throws</span><br><span class="line">        IOException &#123;</span><br><span class="line">    try (FileChannel sourceChannel = new FileInputStream(source)</span><br><span class="line">            .getChannel();</span><br><span class="line">         FileChannel targetChannel = new FileOutputStream(dest).getChannel</span><br><span class="line">                 ();)&#123;</span><br><span class="line">        for (long count = sourceChannel.size() ;count&gt;0 ;) &#123;</span><br><span class="line">            long transferred = sourceChannel.transferTo(</span><br><span class="line">                    sourceChannel.position(), count, targetChannel);            sourceChannel.position(sourceChannel.position() + transferred);</span><br><span class="line">            count -= transferred;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
当然，Java标准类库本身已经提供了几种Files.copy的实现。<br>对于Copy的效率，这个其实与操作系统和配置等情况相关，总体上来说，NIO transferTo/From的方式可能更快，因为它更能利用现代操作系统底层机制，避免不必要拷贝和上下文切换。</li>
</ul>
<h2 id="谈谈接口和抽象类有什么区别？"><a href="#谈谈接口和抽象类有什么区别？" class="headerlink" title="谈谈接口和抽象类有什么区别？"></a>谈谈接口和抽象类有什么区别？</h2><p>接口和抽象类是Java面向对象设计的两个基础机制。<br>接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到API定义和实现分离的目的。接口，不能实例化；不能包含任何非常量成员，任何field都是隐含着public static final的意义；同时，没有非静态方法实现，也就是说要么是抽象方法，要么是静态方法。Java标准类库中，定义了非常多的接口，比如java.util.List。<br>抽象类是不能实例化的类，用abstract关键字修饰class，其目的主要是代码重用。除了不能实例化，形式上和一般的Java类并没有太大区别，可以有一个或者多个抽象方法，也可以没有抽象方法。抽象类大多用于抽取相关Java类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。Java标准库中，比如collection框架，很多通用部分就被抽取成为抽象类，例如java.util.AbstractList。<br>Java类实现interface使用implements关键词，继承abstract class则是使用extends关键词，我们可以参考Java标准库中的ArrayList。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">  implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进行面向对象编程，掌握基本的设计原则是必须的，我今天介绍最通用的部分，也就是所谓的S.O.L.I.D原则。</p>
<ul>
<li>单一职责（Single Responsibility），类或者对象最好是只有单一职责，在程序设计中如果发现某个类承担着多种义务，可以考虑进行拆分。</li>
<li>开闭原则（Open-Close, Open for extension, close for modification），设计要对扩展开放，对修改关闭。换句话说，程序设计应保证平滑的扩展性，尽量避免因为新增同类功能而修改已有实现，这样可以少产出些回归（regression）问题。</li>
<li>里氏替换（Liskov Substitution），这是面向对象的基本要素之一，进行继承关系抽象时，凡是可以用父类或者基类的地方，都可以用子类替换。</li>
<li>接口分离（Interface Segregation），我们在进行类和接口设计时，如果在一个接口里定义了太多方法，其子类很可能面临两难，就是只有部分方法对它是有意义的，这就破坏了程序的内聚性。<br>对于这种情况，可以通过拆分成功能单一的多个接口，将行为进行解耦。在未来维护中，如果某个接口设计有变，不会对使用其他接口的子类构成影响。</li>
<li>依赖反转（Dependency Inversion），实体应该依赖于抽象而不是实现。也就是说高层次模块，不应该依赖于低层次模块，而是应该基于抽象。实践这一原则是保证产品代码之间适当耦合度的法宝。<h2 id="谈谈你知道的设计模式？"><a href="#谈谈你知道的设计模式？" class="headerlink" title="谈谈你知道的设计模式？"></a>谈谈你知道的设计模式？</h2>大致按照模式的应用目标分类，设计模式可以分为创建型模式、结构型模式和行为型模式。</li>
<li>创建型模式，是对对象创建过程的各种问题和解决方案的总结，包括各种工厂模式（Factory、Abstract Factory）、单例模式（Singleton）、构建器模式（Builder）、原型模式（ProtoType）。</li>
<li>结构型模式，是针对软件设计结构的总结，关注于类、对象继承、组合方式的实践经验。常见的结构型模式，包括桥接模式（Bridge）、适配器模式（Adapter）、装饰者模式（Decorator）、代理模式（Proxy）、组合模式（Composite）、外观模式（Facade）、享元模式（Flyweight）等。</li>
<li>行为型模式，是从类或对象之间交互、职责划分等角度总结的模式。比较常见的行为型模式有策略模式（Strategy）、解释器模式（Interpreter）、命令模式（Command）、观察者模式（Observer）、迭代器模式（Iterator）、模板方法模式（Template Method）、访问者模式（Visitor）。</li>
</ul>
<p>Spring中使用设计模式如：</p>
<ul>
<li>BeanFactory和ApplicationContext应用了工厂模式。 </li>
<li>在Bean的创建中，Spring也为不同scope定义的对象，提供了单例和原型等模式实现。</li>
<li>我在专栏第6讲介绍的AOP领域则是使用了代理模式、装饰器模式、适配器模式等。</li>
<li>各种事件监听器，是观察者模式的典型应用。</li>
<li>类似JdbcTemplate等则是应用了模板模式。</li>
</ul>
<h1 id="Java进阶"><a href="#Java进阶" class="headerlink" title="Java进阶"></a>Java进阶</h1><h2 id="synchronized和ReentrantLock有什么区别呢？"><a href="#synchronized和ReentrantLock有什么区别呢？" class="headerlink" title="synchronized和ReentrantLock有什么区别呢？"></a>synchronized和ReentrantLock有什么区别呢？</h2><ul>
<li>synchronized是Java内建的同步机制，所以也有人称其为Intrinsic Locking，它提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里。</li>
<li>在Java 5以前，synchronized是仅有的同步手段，在代码中， synchronized可以用来修饰方法，也可以使用在特定的代码块儿上，本质上synchronized方法等同于把方法全部语句用synchronized块包起来。</li>
<li>ReentrantLock，通常翻译为再入锁，是Java 5提供的锁实现，它的语义和synchronized基本相同。再入锁通过代码直接调用lock()方法获取，代码书写也更加灵活。与此同时，ReentrantLock提供了很多实用的方法，能够实现很多synchronized无法做到的细节控制，比如可以控制fairness，也就是公平性，或者利用定义条件等。但是，编码中也需要注意，必须要明确调用unlock()方法释放，不然就会一直持有该锁。</li>
<li>synchronized和ReentrantLock的性能不能一概而论，早期版本synchronized在很多场景下性能相差较大，在后续版本进行了较多改进，在低竞争场景中表现可能优于ReentrantLock。</li>
</ul>
<p>线程安全需要保证几个基本特性：</p>
<ol>
<li>原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。</li>
<li>可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile就是负责保证可见性的。</li>
<li>有序性，是保证线程内串行语义，避免指令重排等。<h2 id="synchronized底层如何实现？什么是锁的升级、降级？"><a href="#synchronized底层如何实现？什么是锁的升级、降级？" class="headerlink" title="synchronized底层如何实现？什么是锁的升级、降级？"></a>synchronized底层如何实现？什么是锁的升级、降级？</h2>在回答这个问题前，先简单复习一下上一讲的知识点。synchronized代码块是由一对儿monitorenter/monitorexit指令实现的，Monitor对象是同步的基本实现单元。</li>
</ol>
<p>在Java 6之前，Monitor的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。</p>
<p>现代的（Oracle）JDK中，JVM对此进行了大刀阔斧地改进，提供了三种不同的Monitor实现，也就是常说的三种不同的锁：偏斜锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p>
<p>所谓锁的升级、降级，就是JVM优化synchronized运行的机制，当JVM检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。</p>
<p>当没有竞争出现时，默认会使用偏斜锁。JVM会利用CAS操作（compare and swap），在对象头上的Mark Word部分设置线程ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。</p>
<p>如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM就需要撤销（revoke）偏斜锁，并切换到轻量级锁实现。轻量级锁依赖CAS操作Mark Word来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。</p>
<p>我注意到有的观点认为Java不会进行锁降级。实际上据我所知，锁降级确实是会发生的，当JVM进入安全点（SafePoint）的时候，会检查是否有闲置的Monitor，然后试图进行降级。</p>
<ul>
<li>AQS框架美团技术介绍：<a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html</a><h2 id="一个线程两次调用start-方法会出现什么情况？"><a href="#一个线程两次调用start-方法会出现什么情况？" class="headerlink" title="一个线程两次调用start()方法会出现什么情况？"></a>一个线程两次调用start()方法会出现什么情况？</h2>Java的线程是不允许启动两次的，第二次调用必然会抛出IllegalThreadStateException，这是一种运行时异常，多次调用start被认为是编程错误。<br>关于线程生命周期的不同状态，在Java 5以后，线程状态被明确定义在其公共内部枚举类型java.lang.Thread.State中，分别是：</li>
<li>新建（NEW），表示线程被创建出来还没真正启动的状态，可以认为它是个Java内部状态。</li>
<li>就绪（RUNNABLE），表示该线程已经在JVM中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它CPU片段，在就绪队列里面排队。<br>在其他一些分析中，会额外区分一种状态RUNNING，但是从Java API的角度，并不能表示出来。</li>
<li>阻塞（BLOCKED），这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待Monitor lock。比如，线程试图通过synchronized去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。</li>
<li>等待（WAITING），表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类似notify等动作，通知消费线程可以继续工作了。Thread.join()也会令线程进入等待状态。</li>
<li>计时等待（TIMED_WAIT），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如wait或join等方法的指定超时版本，如下面示例：</li>
</ul>
<p>public final native void wait(long timeout) throws InterruptedException;<br>终止（TERMINATED），不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也有人把这个状态叫作死亡。<br>在第二次调用start()方法的时候，线程可能处于终止或者其他（非NEW）状态，但是不论如何，都是不可以再次启动的。</p>
<h2 id="什么情况下Java程序会产生死锁？如何定位、修复？"><a href="#什么情况下Java程序会产生死锁？如何定位、修复？" class="headerlink" title="什么情况下Java程序会产生死锁？如何定位、修复？"></a>什么情况下Java程序会产生死锁？如何定位、修复？</h2><ul>
<li>死锁是一种特定的程序状态，在实体之间，由于循环依赖导致彼此一直处于等待之中，没有任何个体可以继续前进。死锁不仅仅是在线程之间会发生，存在资源独占的进程之间同样也可能出现死锁。通常来说，我们大多是聚焦在多线程场景中的死锁，指两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞的状态。</li>
<li>定位死锁最常见的方式就是利用jstack等工具获取线程栈，然后定位互相之间的依赖关系，进而找到死锁。如果是比较明显的死锁，往往jstack等就能直接定位，类似JConsole甚至可以在图形界面进行有限的死锁检测。</li>
<li>如果程序运行时发生了死锁，绝大多数情况下都是无法在线解决的，只能重启、修正程序本身问题。所以，代码开发阶段互相审查，或者利用工具进行预防性排查，往往也是很重要的。<h2 id="Java并发包提供了哪些并发工具类？"><a href="#Java并发包提供了哪些并发工具类？" class="headerlink" title="Java并发包提供了哪些并发工具类？"></a>Java并发包提供了哪些并发工具类？</h2>我们通常所说的并发包也就是java.util.concurrent及其子包，集中了Java并发的各种基础工具类，具体主要包括几个方面：</li>
<li>提供了比synchronized更加高级的各种同步结构，包括CountDownLatch、CyclicBarrier、Semaphore等，可以实现更加丰富的多线程操作，比如利用Semaphore作为资源控制器，限制同时进行工作的线程数量。</li>
<li>各种线程安全的容器，比如最常见的ConcurrentHashMap、有序的ConcurrentSkipListMap，或者通过类似快照机制，实现线程安全的动态数组CopyOnWriteArrayList等。</li>
<li>各种并发队列实现，如各种BlockingQueue实现，比较典型的ArrayBlockingQueue、 SynchronousQueue或针对特定场景的PriorityBlockingQueue等。</li>
<li>强大的Executor框架，可以创建各种不同类型的线程池，调度任务运行等，绝大部分情况下，不再需要自己从头实现线程池和任务调度器。</li>
</ul>
<h2 id="并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？"><a href="#并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？" class="headerlink" title="并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？"></a>并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？</h2><p>有时候我们把并发包下面的所有容器都习惯叫作并发容器，但是严格来讲，类似ConcurrentLinkedQueue这种“Concurrent*”容器，才是真正代表并发。</p>
<p>关于问题中它们的区别：</p>
<ul>
<li>Concurrent类型基于lock-free，在常见的多线程访问场景，一般可以提供较高吞吐量。</li>
<li>而LinkedBlockingQueue内部则是基于锁，并提供了BlockingQueue的等待性方法。</li>
</ul>
<p>不知道你有没有注意到，java.util.concurrent包提供的容器（Queue、List、Set）、Map，从命名上可以大概区分为Concurrent*、CopyOnWrite和Blocking等三类，同样是线程安全容器，可以简单认为：</p>
<ul>
<li>Concurrent类型没有类似CopyOnWrite之类容器相对较重的修改开销。</li>
<li>但是，凡事都是有代价的，Concurrent往往提供了较低的遍历一致性。你可以这样理解所谓的弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历。</li>
<li>与弱一致性对应的，就是我介绍过的同步容器常见的行为“fail-fast”，也就是检测到容器在遍历过程中发生了修改，则抛出ConcurrentModificationException，不再继续遍历。</li>
<li>弱一致性的另外一个体现是，size等操作准确性是有限的，未必是100%准确。</li>
<li>与此同时，读取的性能具有一定的不确定性。</li>
</ul>
<h2 id="Java并发类库提供的线程池有哪几种？-分别有什么特点？"><a href="#Java并发类库提供的线程池有哪几种？-分别有什么特点？" class="headerlink" title="Java并发类库提供的线程池有哪几种？ 分别有什么特点？"></a>Java并发类库提供的线程池有哪几种？ 分别有什么特点？</h2><p>通常开发者都是利用Executors提供的通用线程池创建方法，去创建不同配置的线程池，主要区别在于不同的ExecutorService类型或者不同的初始参数。</p>
<p>Executors目前提供了5种不同的线程池创建配置：</p>
<ul>
<li>newCachedThreadPool()，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过60秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用SynchronousQueue作为工作队列。</li>
<li>newFixedThreadPool(int nThreads)，重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有nThreads个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目nThreads。</li>
<li>newSingleThreadExecutor()，它的特点在于工作线程数目被限制为1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。</li>
<li>newSingleThreadScheduledExecutor()和newScheduledThreadPool(int corePoolSize)，创建的是个ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。</li>
<li>newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序。<h2 id="AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？"><a href="#AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？" class="headerlink" title="AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？"></a>AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？</h2>AtomicIntger是对int类型的一个封装，提供原子性的访问和更新操作，其原子性操作的实现是基于CAS（compare-and-swap）技术。</li>
</ul>
<p>所谓CAS，表征的是一些列操作的集合，获取当前数值，进行一些运算，利用CAS指令试图进行更新。如果当前数值未变，代表没有其他线程进行并发修改，则成功更新。否则，可能出现不同的选择，要么进行重试，要么就返回一个成功或者失败的结果。</p>
<h2 id="请介绍类加载过程，什么是双亲委派模型？"><a href="#请介绍类加载过程，什么是双亲委派模型？" class="headerlink" title="请介绍类加载过程，什么是双亲委派模型？"></a>请介绍类加载过程，什么是双亲委派模型？</h2><p>一般来说，我们把Java的类加载过程分为三个主要步骤：加载、链接、初始化，具体行为在Java虚拟机规范里有非常详细的定义。</p>
<ul>
<li><p>首先是加载阶段（Loading），它是Java将字节码数据从不同的数据源读取到JVM中，并映射为JVM认可的数据结构（Class对象），这里的数据源可能是各种各样的形态，如jar文件、class文件，甚至是网络数据源等；如果输入数据不是ClassFile的结构，则会抛出ClassFormatError。<br>加载阶段是用户参与的阶段，我们可以自定义类加载器，去实现自己的类加载过程。</p>
</li>
<li><p>第二阶段是链接（Linking），这是核心的步骤，简单说是把原始的类定义信息平滑地转化入JVM运行的过程中。这里可进一步细分为三个步骤：</p>
<ul>
<li><p>验证（Verification），这是虚拟机安全的重要保障，JVM需要核验字节信息是符合Java虚拟机规范的，否则就被认为是VerifyError，这样就防止了恶意信息或者不合规的信息危害JVM的运行，验证阶段有可能触发更多class的加载。</p>
</li>
<li><p>准备（Preparation），创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的JVM指令。</p>
</li>
<li><p>解析（Resolution），在这一步会将常量池中的符号引用（symbolic reference）替换为直接引用。在Java虚拟机规范中，详细介绍了类、接口、方法和字段等各个方面的解析。</p>
</li>
</ul>
</li>
<li><p>最后是初始化阶段（initialization），这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。</p>
</li>
</ul>
<p>再来谈谈双亲委派模型，简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载Java类型。</p>
<h2 id="有哪些方法可以在运行时动态生成一个Java类"><a href="#有哪些方法可以在运行时动态生成一个Java类" class="headerlink" title="有哪些方法可以在运行时动态生成一个Java类"></a>有哪些方法可以在运行时动态生成一个Java类</h2><p>我们可以从常见的Java类来源分析，通常的开发过程是，开发者编写Java代码，调用javac编译成class文件，然后通过类加载机制载入JVM，就成为应用运行时可以使用的Java类了。</p>
<p>从上面过程得到启发，其中一个直接的方式是从源码入手，可以利用Java程序生成一段源码，然后保存到文件等，下面就只需要解决编译问题了。</p>
<p>有一种笨办法，直接用ProcessBuilder之类启动javac进程，并指定上面生成的文件作为输入，进行编译。最后，再利用类加载器，在运行时加载即可。</p>
<p>前面的方法，本质上还是在当前程序进程之外编译的，那么还有没有不这么low的办法呢？</p>
<p>你可以考虑使用Java Compiler API，这是JDK提供的标准API，里面提供了与javac对等的编译器功能，具体请参考java.compiler相关文档。</p>
<p>进一步思考，我们一直围绕Java源码编译成为JVM可以理解的字节码，换句话说，只要是符合JVM规范的字节码，不管它是如何生成的，是不是都可以被JVM加载呢？我们能不能直接生成相应的字节码，然后交给类加载器去加载呢？</p>
<p>当然也可以，不过直接去写字节码难度太大，通常我们可以利用Java字节码操纵工具和类库来实现，比如在专栏第6讲中提到的ASM、Javassist、cglib等。</p>
<h2 id="谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError"><a href="#谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError" class="headerlink" title="谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError?"></a>谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError?</h2><p>通常可以把JVM内存区域分为下面几个方面，其中，有的区域是以线程为单位，而有的区域则是整个JVM进程唯一的。</p>
<ul>
<li>首先，程序计数器（PC，Program Counter Register）。在JVM规范中，每个线程都有它自己的程序计数器，并且任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行本地方法，则是未指定值（undefined）。</li>
<li>第二，Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。<br>前面谈程序计数器时，提到了当前方法；同理，在一个时间点，对应的只会有一个活动的栈帧，通常叫作当前帧，方法所在的类叫作当前类。如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，成为新的当前帧，一直到它返回结果或者执行结束。JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈。</li>
</ul>
<p>栈帧中存储着局部变量表、操作数（operand）栈、动态链接、方法正常退出或者异常退出的定义等。</p>
<ul>
<li>第三，堆（Heap），它是Java内存管理的核心区域，用来放置Java对象实例，几乎所有创建的Java对象实例都是被直接分配在堆上。堆被所有的线程共享，在虚拟机启动时，我们指定的“Xmx”之类参数就是用来指定最大堆空间等指标。</li>
</ul>
<p>理所当然，堆也是垃圾收集器重点照顾的区域，所以堆内空间还会被不同的垃圾收集器进行进一步的细分，最有名的就是新生代、老年代的划分。</p>
<ul>
<li>第四，方法区（Method Area）。这也是所有线程共享的一块内存区域，用于存储所谓的元（Meta）数据，例如类结构信息，以及对应的运行时常量池、字段、方法代码等。<br>由于早期的Hotspot JVM实现，很多人习惯于将方法区称为永久代（Permanent Generation）。Oracle JDK 8中将永久代移除，同时增加了元数据区（Metaspace）。</li>
<li>第五，运行时常量池（Run-Time Constant Pool），这是方法区的一部分。如果仔细分析过反编译的类文件结构，你能看到版本号、字段、方法、超类、接口等各种信息，还有一项信息就是常量池。Java的常量池可以存放各种常量信息，不管是编译期生成的各种字面量，还是需要在运行时决定的符号引用，所以它比一般语言的符号表存储的信息更加宽泛。</li>
<li>第六，本地方法栈（Native Method Stack）。它和Java虚拟机栈是非常相似的，支持对本地方法的调用，也是每个线程都会创建一个。在Oracle Hotspot JVM中，本地方法栈和Java虚拟机栈是在同一块儿区域，这完全取决于技术实现的决定，并未在规范中强制。<h2 id="如何监控和诊断JVM堆内和堆外内存使用"><a href="#如何监控和诊断JVM堆内和堆外内存使用" class="headerlink" title="如何监控和诊断JVM堆内和堆外内存使用?"></a>如何监控和诊断JVM堆内和堆外内存使用?</h2>了解JVM内存的方法有很多，具体能力范围也有区别，简单总结如下：</li>
<li>可以使用综合性的图形化工具，如JConsole、VisualVM（注意，从Oracle JDK 9开始，VisualVM已经不再包含在JDK安装包中）等。这些工具具体使用起来相对比较直观，直接连接到Java进程，然后就可以在图形化界面里掌握内存使用情况。</li>
</ul>
<p>以JConsole为例，其内存页面可以显示常见的堆内存和各种堆外部分使用状态。</p>
<ul>
<li><p>也可以使用命令行工具进行运行时查询，如jstat和jmap等工具都提供了一些选项，可以查看堆、方法区等使用数据。</p>
</li>
<li><p>或者，也可以使用jmap等提供的命令，生成堆转储（Heap Dump）文件，然后利用jhat或Eclipse MAT等堆转储分析工具进行详细分析。</p>
</li>
<li><p>如果你使用的是Tomcat、Weblogic等Java EE服务器，这些服务器同样提供了内存管理相关的功能。</p>
</li>
<li><p>另外，从某种程度上来说，GC日志等输出，同样包含着丰富的信息。<br>这里有一个相对特殊的部分，就是是堆外内存中的直接内存，前面的工具基本不适用，可以使用JDK自带的Native Memory Tracking（NMT）特性，它会从JVM本地内存分配的角度进行解读。</p>
<h2 id="Java常见的垃圾收集器有哪些？"><a href="#Java常见的垃圾收集器有哪些？" class="headerlink" title="Java常见的垃圾收集器有哪些？"></a>Java常见的垃圾收集器有哪些？</h2><p>实际上，垃圾收集器（GC，Garbage Collector）是和具体JVM实现紧密相关的，不同厂商（IBM、Oracle），不同版本的JVM，提供的选择也不同。接下来，我来谈谈最主流的Oracle JDK。</p>
</li>
<li><p>Serial GC，它是最古老的垃圾收集器，“Serial”体现在其收集工作是单线程的，并且在进行垃圾收集过程中，会进入臭名昭著的“Stop-The-World”状态。当然，其单线程设计也意味着精简的GC实现，无需维护复杂的数据结构，初始化也简单，所以一直是Client模式下JVM的默认选项。<br>从年代的角度，通常将其老年代实现单独称作Serial Old，它采用了标记-整理（Mark-Compact）算法，区别于新生代的复制算法。<br>Serial GC的对应JVM参数是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC</span><br></pre></td></tr></table></figure></li>
<li><p>ParNew GC，很明显是个新生代GC实现，它实际是Serial GC的多线程版本，最常见的应用场景是配合老年代的CMS GC工作，下面是对应参数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC -XX:+UseParNewGC</span><br></pre></td></tr></table></figure></li>
<li><p>CMS（Concurrent Mark Sweep） GC，基于标记-清除（Mark-Sweep）算法，设计目标是尽量减少停顿时间，这一点对于Web等反应时间敏感的应用非常重要，一直到今天，仍然有很多系统使用CMS GC。但是，CMS采用的标记-清除算法，存在着内存碎片化问题，所以难以避免在长时间运行等情况下发生full GC，导致恶劣的停顿。另外，既然强调了并发（Concurrent），CMS会占用更多CPU资源，并和用户线程争抢。</p>
</li>
<li><p>Parallel GC，在早期JDK 8等版本中，它是server模式JVM的默认GC选择，也被称作是吞吐量优先的GC。它的算法和Serial GC比较相似，尽管实现要复杂的多，其特点是新生代和老年代GC都是并行进行的，在常见的服务器环境中更加高效。<br>开启选项是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC</span><br></pre></td></tr></table></figure>
<p>另外，Parallel GC引入了开发者友好的配置项，我们可以直接设置暂停时间或吞吐量等目标，JVM会自动进行适应性调整，例如下面参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis=value</span><br><span class="line">-XX:GCTimeRatio=N // GC时间和用户时间比例 = 1 / (N+1)</span><br></pre></td></tr></table></figure></li>
<li><p>G1 GC这是一种兼顾吞吐量和停顿时间的GC实现，是Oracle JDK 9以后的默认GC选项。G1可以直观的设定停顿时间的目标，相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</p>
</li>
<li><p>G1 GC仍然存在着年代的概念，但是其内存结构并不是简单的条带式划分，而是类似棋盘的一个个region。Region之间是复制算法，但整体上实际可看作是标记-整理（Mark-Compact）算法，可以有效地避免内存碎片，尤其是当Java堆非常大的时候，G1的优势更加明显。</p>
</li>
<li><p>G1吞吐量和停顿表现都非常不错，并且仍然在不断地完善，与此同时CMS已经在JDK 9中被标记为废弃（deprecated），所以G1 GC值得你深入掌握。</p>
<h2 id="谈谈你的GC调优思路"><a href="#谈谈你的GC调优思路" class="headerlink" title="谈谈你的GC调优思路?"></a>谈谈你的GC调优思路?</h2><p>谈到调优，这一定是针对特定场景、特定目的的事情， 对于GC调优来说，首先就需要清楚调优的目标是什么？从性能的角度看，通常关注三个方面，内存占用（footprint）、延时（latency）和吞吐量（throughput），大多数情况下调优会侧重于其中一个或者两个方面的目标，很少有情况可以兼顾三个不同的角度。当然，除了上面通常的三个方面，也可能需要考虑其他GC相关的场景，例如，OOM也可能与不合理的GC相关参数有关；或者，应用启动速度方面的需求，GC也会是个考虑的方面。</p>
</li>
</ul>
<p>基本的调优思路可以总结为：</p>
<ul>
<li>理解应用需求和问题，确定调优目标。假设，我们开发了一个应用服务，但发现偶尔会出现性能抖动，出现较长的服务停顿。评估用户可接受的响应时间和业务量，将目标简化为，希望GC暂停尽量控制在200ms以内，并且保证一定标准的吞吐量。</li>
<li>掌握JVM和GC的状态，定位具体的问题，确定真的有GC调优的必要。具体有很多方法，比如，通过jstat等工具查看GC等相关状态，可以开启GC日志，或者是利用操作系统提供的诊断工具等。例如，通过追踪GC日志，就可以查找是不是GC在特定时间发生了长时间的暂停，进而导致了应用响应不及时。</li>
<li>这里需要思考，选择的GC类型是否符合我们的应用特征，如果是，具体问题表现在哪里，是Minor GC过长，还是Mixed GC等出现异常停顿情况；如果不是，考虑切换到什么类型，如CMS和G1都是更侧重于低延迟的GC选项。</li>
<li>通过分析确定具体调整的参数或者软硬件配置。</li>
<li>验证是否达到调优目标，如果达到目标，即可以考虑结束调优；否则，重复完成分析、调整、验证这个过程。</li>
</ul>
<h2 id="Java内存模型中的happen-before是什么"><a href="#Java内存模型中的happen-before是什么" class="headerlink" title="Java内存模型中的happen-before是什么"></a>Java内存模型中的happen-before是什么</h2><p>Happen-before关系，是Java内存模型中保证多线程操作可见性的机制，也是对早期语言规范中含糊的可见性概念的一个精确定义。</p>
<p>它的具体表现形式，包括但远不止是我们直觉中的synchronized、volatile、lock操作顺序等方面，例如：</p>
<ul>
<li>线程内执行的每个操作，都保证happen-before后面的操作，这就保证了基本的程序顺序规则，这是开发者在书写程序时的基本约定。</li>
<li>对于volatile变量，对它的写操作，保证happen-before在随后对该变量的读取操作。</li>
<li>对于一个锁的解锁操作，保证happen-before加锁操作。</li>
<li>对象构建完成，保证happen-before于finalizer的开始动作。</li>
<li>甚至是类似线程内部操作的完成，保证happen-before其他Thread.join()的线程等。<br>这些happen-before关系是存在着传递性的，如果满足a happen-before b和b happen-before c，那么a happen-before c也成立。<br>前面我一直用happen-before，而不是简单说前后，是因为它不仅仅是对执行时间的保证，也包括对内存读、写操作顺序的保证。仅仅是时钟顺序上的先后，并不能保证线程交互的可见性。<h2 id="Java程序运行在Docker等容器环境有哪些新问题？"><a href="#Java程序运行在Docker等容器环境有哪些新问题？" class="headerlink" title="Java程序运行在Docker等容器环境有哪些新问题？"></a>Java程序运行在Docker等容器环境有哪些新问题？</h2>对于Java来说，Docker毕竟是一个较新的环境，例如，其内存、CPU等资源限制是通过CGroup（Control Group）实现的，早期的JDK版本（8u131之前）并不能识别这些限制，进而会导致一些基础问题：</li>
<li>如果未配置合适的JVM堆和元数据区、直接内存等参数，Java就有可能试图使用超过容器限制的内存，最终被容器OOM kill，或者自身发生OOM。</li>
<li>错误判断了可获取的CPU资源，例如，Docker限制了CPU的核数，JVM就可能设置不合适的GC并行线程数等。</li>
</ul>
<p>从应用打包、发布等角度出发，JDK自身就比较大，生成的镜像就更为臃肿，当我们的镜像非常多的时候，镜像的存储等开销就比较明显了。</p>
<p>如果考虑到微服务、Serverless等新的架构和场景，Java自身的大小、内存占用、启动速度，都存在一定局限性，因为Java早期的优化大多是针对长时间运行的大型服务器端应用。</p>
<h1 id="Java安全"><a href="#Java安全" class="headerlink" title="Java安全"></a>Java安全</h1><h2 id="你了解Java应用开发中的注入攻击吗？"><a href="#你了解Java应用开发中的注入攻击吗？" class="headerlink" title="你了解Java应用开发中的注入攻击吗？"></a>你了解Java应用开发中的注入攻击吗？</h2><p>注入式（Inject）攻击是一类非常常见的攻击方式，其基本特征是程序允许攻击者将不可信的动态内容注入到程序中，并将其执行，这就可能完全改变最初预计的执行过程，产生恶意效果。</p>
<p>下面是几种主要的注入式攻击途径，原则上提供动态执行能力的语言特性，都需要提防发生注入攻击的可能。</p>
<p>首先，就是最常见的SQL注入攻击。一个典型的场景就是Web系统的用户登录功能，根据用户输入的用户名和密码，我们需要去后端数据库核实信息。</p>
<p>假设应用逻辑是，后端程序利用界面输入动态生成类似下面的SQL，然后让JDBC执行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * from use_info where username = “input_usr_name” and password = “input_pwd”</span><br></pre></td></tr></table></figure>
<p>但是，如果我输入的input_pwd是类似下面的文本，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“ or “”=”</span><br></pre></td></tr></table></figure>
<p>那么，拼接出的SQL字符串就变成了下面的条件，OR的存在导致输入什么名字都是复合条件的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * from use_info where username = “input_usr_name” and password = “” or “” = “”</span><br></pre></td></tr></table></figure>
<p>这里只是举个简单的例子，它是利用了期望输入和可能输入之间的偏差。上面例子中，期望用户输入一个数值，但实际输入的则是SQL语句片段。类似场景可以利用注入的不同SQL语句，进行各种不同目的的攻击，甚至还可以加上“;delete xxx”之类语句，如果数据库权限控制不合理，攻击效果就可能是灾难性的。</p>
<p>第二，操作系统命令注入。Java语言提供了类似Runtime.exec(…)的API，可以用来执行特定命令，假设我们构建了一个应用，以输入文本作为参数，执行下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls –la input_file_name</span><br></pre></td></tr></table></figure>
<p>但是如果用户输入是 “input_file_name;rm –rf /*”，这就有可能出现问题了。当然，这只是个举例，Java标准类库本身进行了非常多的改进，所以类似这种编程错误，未必可以真的完成攻击，但其反映的一类场景是真实存在的。</p>
<p>第三，XML注入攻击。Java核心类库提供了全面的XML处理、转换等各种API，而XML自身是可以包含动态内容的，例如XPATH，如果使用不当，可能导致访问恶意内容。</p>
<p>还有类似LDAP等允许动态内容的协议，都是可能利用特定命令，构造注入式攻击的，包括XSS（Cross-site Scripting）攻击，虽然并不和Java直接相关，但也可能在JSP等动态页面中发生。</p>
<h2 id="如何写出安全的Java代码？"><a href="#如何写出安全的Java代码？" class="headerlink" title="如何写出安全的Java代码？"></a>如何写出安全的Java代码？</h2><p>这个问题可能有点宽泛，我们可以用特定类型的安全风险为例，如拒绝服务（DoS）攻击，分析Java开发者需要重点考虑的点。</p>
<p>DoS是一种常见的网络攻击，有人也称其为“洪水攻击”。最常见的表现是，利用大量机器发送请求，将目标网站的带宽或者其他资源耗尽，导致其无法响应正常用户的请求。</p>
<p>我认为，从Java语言的角度，更加需要重视的是程序级别的攻击，也就是利用Java、JVM或应用程序的瑕疵，进行低成本的DoS攻击，这也是想要写出安全的Java代码所必须考虑的。例如：</p>
<ul>
<li>如果使用的是早期的JDK和Applet等技术，攻击者构建合法但恶劣的程序就相对容易，例如，将其线程优先级设置为最高，做一些看起来无害但空耗资源的事情。幸运的是类似技术已经逐步退出历史舞台，在JDK 9以后，相关模块就已经被移除。</li>
<li>上一讲中提到的哈希碰撞攻击，就是个典型的例子，对方可以轻易消耗系统有限的CPU和线程资源。从这个角度思考，类似加密、解密、图形处理等计算密集型任务，都要防范被恶意滥用，以免攻击者通过直接调用或者间接触发方式，消耗系统资源。</li>
<li>利用Java构建类似上传文件或者其他接受输入的服务，需要对消耗系统内存或存储的上限有所控制，因为我们不能将系统安全依赖于用户的合理使用。其中特别注意的是涉及解压缩功能时，就需要防范Zip bomb等特定攻击。</li>
<li>另外，Java程序中需要明确释放的资源有很多种，比如文件描述符、数据库连接，甚至是再入锁，任何情况下都应该保证资源释放成功，否则即使平时能够正常运行，也可能被攻击者利用而耗尽某类资源，这也算是可能的DoS攻击来源。<br>所以可以看出，实现安全的Java代码，需要从功能设计到实现细节，都充分考虑可能的安全影响。</li>
</ul>
<h1 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h1><h2 id="后台服务出现明显“变慢”，谈谈你的诊断思路？"><a href="#后台服务出现明显“变慢”，谈谈你的诊断思路？" class="headerlink" title="后台服务出现明显“变慢”，谈谈你的诊断思路？"></a>后台服务出现明显“变慢”，谈谈你的诊断思路？</h2><p>首先，需要对这个问题进行更加清晰的定义:</p>
<ul>
<li>服务是突然变慢还是长时间运行后观察到变慢？类似问题是否重复出现？</li>
<li>“慢”的定义是什么，我能够理解是系统对其他方面的请求的反应延时变长吗?<br>第二，理清问题的症状，这更便于定位具体的原因，有以下一些思路：</li>
<li>问题可能来自于Java服务自身，也可能仅仅是受系统里其他服务的影响。初始判断可以先确认是否出现了意外的程序错误，例如检查应用本身的错误日志。<br>对于分布式系统，很多公司都会实现更加系统的日志、性能等监控系统。一些Java诊断工具也可以用于这个诊断，例如通过JFR（Java Flight Recordera&gt;），监控应用是否大量出现了某种类型的异常。</li>
<li>如果有，那么异常可能就是个突破点。<br>如果没有，可以先检查系统级别的资源等情况，监控CPU、内存等资源是否被其他进程大量占用，并且这种占用是否不符合系统正常运行状况。</li>
<li>监控Java服务自身，例如GC日志里面是否观察到Full GC等恶劣情况出现，或者是否Minor GC在变长等；利用jstat等工具，获取内存使用的统计信息也是个常用手段；利用jstack等工具检查是否出现死锁等。</li>
<li>如果还不能确定具体问题，对应用进行Profiling也是个办法，但因为它会对系统产生侵入性，如果不是非常必要，大多数情况下并不建议在生产系统进行。</li>
<li>定位了程序错误或者JVM配置的问题后，就可以采取相应的补救措施，然后验证是否解决，否则还需要重复上面部分过程。<h2 id="对比Java标准NIO类库，你知道Netty是如何实现更高性能的吗？"><a href="#对比Java标准NIO类库，你知道Netty是如何实现更高性能的吗？" class="headerlink" title="对比Java标准NIO类库，你知道Netty是如何实现更高性能的吗？"></a>对比Java标准NIO类库，你知道Netty是如何实现更高性能的吗？</h2>单独从性能角度，Netty在基础的NIO等类库之上进行了很多改进，例如：</li>
<li>更加优雅的Reactor模式实现、灵活的线程模型、利用EventLoop等创新性的机制，可以非常高效地管理成百上千的Channel。</li>
<li>充分利用了Java的Zero-Copy机制，并且从多种角度，“斤斤计较”般的降低内存分配和回收的开销。例如，使用池化的Direct Buffer等技术，在提高IO性能的同时，减少了对象的创建和销毁；利用反射等技术直接操纵SelectionKey，使用数组而不是Java容器等。</li>
<li>使用更多本地代码。例如，直接利用JNI调用Open SSL等方式，获得比Java内建SSL引擎更好的性能。</li>
<li>在通信协议、序列化等其他角度的优化。<br>总的来说，Netty并没有Java核心类库那些强烈的通用性、跨平台等各种负担，针对性能等特定目标以及Linux等特定环境，采取了一些极致的优化手段。</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>《Java核心技术I》</li>
<li>《Java虚拟机规范java SE 8》</li>
<li> Java虚拟机规范：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf">https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf</a></li>
<li>分布式事务：<a target="_blank" rel="noopener" href="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/">https://xiaomi-info.github.io/2020/01/02/distributed-transaction/</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2020/05/05/Mac%E7%BB%BF%E8%89%B2%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/05/05/Mac%E7%BB%BF%E8%89%B2%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-title-link" itemprop="url">Mac绿色安装mysql数据库</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-05 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-05T00:00:00+08:00">2020-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:03" itemprop="dateModified" datetime="2022-07-05T22:46:03+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/" itemprop="url" rel="index"><span itemprop="name">开发日常</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Mac绿色安装mysql数据库"><a href="#Mac绿色安装mysql数据库" class="headerlink" title="Mac绿色安装mysql数据库"></a>Mac绿色安装mysql数据库</h1><h2 id="下载msyql服务"><a href="#下载msyql服务" class="headerlink" title="下载msyql服务"></a>下载msyql服务</h2><p>下载地址：<a target="_blank" rel="noopener" href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a><br>选择<code>macOS 10.15 (x86, 64-bit), Compressed TAR Archive</code> 版本进行下载</p>
<h2 id="数据库安装配置"><a href="#数据库安装配置" class="headerlink" title="数据库安装配置"></a>数据库安装配置</h2><p>解压下载的mysql数据库，然后拷贝到一个你喜欢的目录下，如：/Users/atomic/.app/mysql</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 移动到目标目录下</span></span><br><span class="line">mv mysql-8.0.22-macos10.15-x86_64 /Users/atomic/.app/mysql</span><br></pre></td></tr></table></figure>
<p>修改新目录的所属用户和用户组</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R atomic:wheel /Users/atomic/.app/mysql</span><br></pre></td></tr></table></figure>

<p>*linux要创建用户组和用户，同时授权文件夹</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">groupadd mysql</span><br><span class="line">useradd -r -s /sbin/nologin -g mysql mysql -d /usr/local/mysql </span><br><span class="line">chown -R mysql .</span><br><span class="line">chgrp -R mysql .</span><br></pre></td></tr></table></figure>

<p>初始化mysql</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /Users/atomic/.app/mysql/bin</span><br><span class="line">./mysqld --initialize</span><br></pre></td></tr></table></figure>
<p>初始化后会打印初始化日志，同时也会打印出初始化后的随机密码，这是登入mysql的密码，<strong>需要记下来</strong><br><img src="https://raw.githubusercontent.com/mvilplss/note/master/image/img.png" alt="img.png"></p>
<p>修改启动脚本<code>mysql.server</code>，指定basedir和datadir的目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /Users/atomic/.app/mysql/support-files/mysql.server</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置basedir和datadir的目录</span></span><br><span class="line">basedir=/Users/atomic/.app/mysql</span><br><span class="line">datadir=/Users/atomic/.app/mysql/data</span><br></pre></td></tr></table></figure>

<h2 id="启动mysql服务"><a href="#启动mysql服务" class="headerlink" title="启动mysql服务"></a>启动mysql服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cd /Users/atomic/.app/mysql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">sudo support-files/mysql.server start</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启</span></span><br><span class="line">sudo support-files/mysql.server restart</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止</span></span><br><span class="line">sudo support-files/mysql.server stop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查 MySQL 运行状态</span></span><br><span class="line">sudo support-files/mysql.server status</span><br></pre></td></tr></table></figure>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /Users/atomic/.app/mysql/bin</span><br><span class="line">./mysql -u root -p</span><br></pre></td></tr></table></figure>
<p><your-password>（初始化时候随机生成的密码）</p>
<h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># mac 下修改密码</span><br><span class="line">SET PASSWORD &#x3D; PASSWORD(&#39;your new password&#39;);</span><br><span class="line"># linux 下修改密码</span><br><span class="line">alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;123456&#39;;</span><br><span class="line"></span><br><span class="line"># 设置密码有效期为永久</span><br><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; PASSWORD EXPIRE NEVER;</span><br><span class="line"># 刷新权限</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<h2 id="打开远程访问"><a href="#打开远程访问" class="headerlink" title="打开远程访问"></a>打开远程访问</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select host from user where user &#x3D; &#39;root&#39;;</span><br><span class="line">+-----------+</span><br><span class="line">| host      |</span><br><span class="line">+-----------+</span><br><span class="line">| localhost |</span><br><span class="line">+-----------+</span><br><span class="line">mysql&gt; update user set host &#x3D; &#39;%&#39; where user&#x3D;&#39;root&#39;;</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">mysql&gt; select host  from user where user&#x3D;&#39;root&#39;;</span><br><span class="line">+------+</span><br><span class="line">| host |</span><br><span class="line">+------+</span><br><span class="line">| %    |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果启动mysql服务的时候出现问题，先在进程中关闭与mysql有关的进程。在应用程序中打开其他找到活动监视器。关闭相关进程即可。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>更简单一种方法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/F1300684594/article/details/54647306">https://blog.csdn.net/F1300684594/article/details/54647306</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2020/01/02/Mac%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8D%E7%A7%B0%E6%9C%AC%E5%9C%B0%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/01/02/Mac%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8D%E7%A7%B0%E6%9C%AC%E5%9C%B0%E5%8C%96/" class="post-title-link" itemprop="url">Mac文件夹名称本地化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-02 00:00:00" itemprop="dateCreated datePublished" datetime="2020-01-02T00:00:00+08:00">2020-01-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:03" itemprop="dateModified" datetime="2022-07-05T22:46:03+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/" itemprop="url" rel="index"><span itemprop="name">开发日常</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Mac文件夹名称本地化"><a href="#Mac文件夹名称本地化" class="headerlink" title="Mac文件夹名称本地化"></a>Mac文件夹名称本地化</h1><p>在使用mac的时候，自带的一些文件夹如：桌面，下载，文稿等在Finder中都是中文的，但是在命令行中看到的是英文的。作为一名开发者，创建的某些文件夹需要程序访问，为了防止中文问题，就用了英文，但是在Finder看着有点别扭，就想把这些文件也设置为本地化，下面将介绍方法。</p>
<h2 id="首先关闭SPI权限"><a href="#首先关闭SPI权限" class="headerlink" title="首先关闭SPI权限"></a>首先关闭SPI权限</h2><p>重启mac电脑，长按<code>command+r</code>进入系统引导界面，在左上角菜单中找到终端，输入以下命令关闭SPI保护：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrutil disable</span><br></pre></td></tr></table></figure>
<p>如果要恢复SPI保护则执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrutil enable</span><br></pre></td></tr></table></figure>

<h2 id="文件夹本地化配置"><a href="#文件夹本地化配置" class="headerlink" title="文件夹本地化配置"></a>文件夹本地化配置</h2><p>首先创建一个英文的文件夹，已经创建的可以忽略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir Works</span><br></pre></td></tr></table></figure>
<p>开始对文件夹Works配置本地化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -uw &#x2F;</span><br><span class="line"></span><br><span class="line">cd &#x2F;System&#x2F;Library&#x2F;CoreServices&#x2F;SystemFolderLocalizations&#x2F;zh_CN.lproj</span><br><span class="line"></span><br><span class="line">sudo &#x2F;usr&#x2F;libexec&#x2F;PlistBuddy -c &quot;Add &#39;Works&#39; string &#39;工作&#39;&quot; SystemFolderLocalizations.strings</span><br><span class="line"></span><br><span class="line">cd &#x2F;System&#x2F;Library&#x2F;CoreServices&#x2F;SystemFolderLocalizations&#x2F;en.lproj</span><br><span class="line"></span><br><span class="line">sudo &#x2F;usr&#x2F;libexec&#x2F;PlistBuddy -c &quot;Add &#39;Works&#39; string &#39;Works&#39;&quot; SystemFolderLocalizations.strings</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>本地化配置好后，进入Works创建本地化标示文件 .localized 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Works</span><br><span class="line">touch .localized</span><br></pre></td></tr></table></figure>
<p>重启Finder</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill Finder</span><br></pre></td></tr></table></figure>
<p>至此我们就操作完了，正常情况下你创建的那个英文文件夹就展示为中文的了，如果没有则重启系统在观察下。<br>备注：我操作的mac os为：Catalina</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>查看某个文件夹名称是否有本地化配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;System&#x2F;Library&#x2F;CoreServices&#x2F;SystemFolderLocalizations&#x2F;zh_CN.lproj</span><br><span class="line">&#x2F;usr&#x2F;libexec&#x2F;PlistBuddy -c &#39;Print :&#39;Works&#39;&#39; SystemFolderLocalizations.strings</span><br></pre></td></tr></table></figure>

<p>如果要删除某个文件的本地化配置，操作如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;System&#x2F;Library&#x2F;CoreServices&#x2F;SystemFolderLocalizations&#x2F;zh_CN.lproj</span><br><span class="line">&#x2F;usr&#x2F;libexec&#x2F;PlistBuddy -c &quot;Delete &#39;Works&#39;&quot; SystemFolderLocalizations.strings</span><br><span class="line"></span><br><span class="line">cd &#x2F;System&#x2F;Library&#x2F;CoreServices&#x2F;SystemFolderLocalizations&#x2F;en.lproj</span><br><span class="line">&#x2F;usr&#x2F;libexec&#x2F;PlistBuddy -c &quot;Delete &#39;Works&#39;&quot; SystemFolderLocalizations.strings</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>关于 PlistBuddy 的语法，详见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/chqj_163/article/details/102590609">https://blog.csdn.net/chqj_163/article/details/102590609</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2020/01/02/raw.githubusercontent.com%20port%20443/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/01/02/raw.githubusercontent.com%20port%20443/" class="post-title-link" itemprop="url">raw.githubusercontent.com port</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-02 00:00:00" itemprop="dateCreated datePublished" datetime="2020-01-02T00:00:00+08:00">2020-01-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:03" itemprop="dateModified" datetime="2022-07-05T22:46:03+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/" itemprop="url" rel="index"><span itemprop="name">开发日常</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Failed-to-connect-to-raw-githubusercontent-com-443"><a href="#Failed-to-connect-to-raw-githubusercontent-com-443" class="headerlink" title="Failed to connect to raw.githubusercontent.com:443"></a>Failed to connect to raw.githubusercontent.com:443</h1><p>我们在执行一些通过raw.githubusercontent.com进行安装的工具时候，总是会出现如下问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused</span><br></pre></td></tr></table></figure>
<p>这里将提供两种解决方案，方案如下：</p>
<h2 id="如果你在使用科学上网"><a href="#如果你在使用科学上网" class="headerlink" title="如果你在使用科学上网"></a>如果你在使用科学上网</h2><p>如果你是科学上网，则执行下面命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 7890 和 789 需要换成你自己的端口</span><br><span class="line">export https_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:7890 http_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:7890 all_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:789</span><br></pre></td></tr></table></figure>
<p>再次执行之前连接 <a target="_blank" rel="noopener" href="http://raw.githubusercontent.com:443/">http://raw.githubusercontent.com:443</a> 被拒绝的命令应该就成功了。</p>
<h2 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h2><p>如果没有科学上网，则可以通过修改hosts来解决。<br>打开 <a target="_blank" rel="noopener" href="https://www.ipaddress.com/">https://www.ipaddress.com/</a> 输入访问不了的域名，获取对应的ip:199.232.68.133<br>然后修改host，在末尾增加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">199.232.68.133 raw.githubusercontent.com</span><br><span class="line">199.232.68.133 user-images.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars2.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars1.githubusercontent.com</span><br></pre></td></tr></table></figure>
<p>上面的IP换成你查出来的IP地址即可，修改host可参考：<a target="_blank" rel="noopener" href="https://github.com/oldj/SwitchHosts">https://github.com/oldj/SwitchHosts</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2019/09/17/Java%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/09/17/Java%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" class="post-title-link" itemprop="url">Java之动态代理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-17 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-17T00:00:00+08:00">2019-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:03" itemprop="dateModified" datetime="2022-07-05T22:46:03+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">开发技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Java之动态代理"><a href="#Java之动态代理" class="headerlink" title="Java之动态代理"></a>Java之动态代理</h2><p>动态代理是一种设计模式，通过对原对象进行包装生成代理对象，可以实现对原来对象的方法增强。比如spring的声明式事务就是使用的动态代理模式实现的。下面我们将会了解到：</p>
<ul>
<li>动态代理的实现方式。</li>
<li>jdk和cglib动态代理类的生成源码分析。</li>
<li>jdk和cglib动态代理类的执行分析。</li>
</ul>
<h2 id="动态代理类的实现方式"><a href="#动态代理类的实现方式" class="headerlink" title="动态代理类的实现方式"></a>动态代理类的实现方式</h2><p>定义一个接口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ComputerIntf &#123;</span><br><span class="line">    int add(int i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个实现类（目标类）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Computer implements ComputerIntf &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int add(int i) &#123;</span><br><span class="line">        return i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们下面通过两种方式实现上面add方法在执行计算前输出入参日志。</p>
<h3 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h3><p>通过jdk自带的api来实现动态代理：</p>
<ol>
<li>首先创建一个<code>InvocationHandler</code>的实现类，重写<code>invoke</code>方法，在方法调用前打印日志，增加带<code>ComputerIntf</code>参数构造方法，在创建handler对象时传入代理目标对象，在invoke方法中反射调用时使用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class JdkInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">    private ComputerIntf computerIntf;</span><br><span class="line"></span><br><span class="line">    public JdkInvocationHandler(ComputerIntf computerIntf) &#123;</span><br><span class="line">        this.computerIntf &#x3D; computerIntf;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; proxy 生成的代理对象</span><br><span class="line">    &#x2F;&#x2F; method 目标方法</span><br><span class="line">    &#x2F;&#x2F; args 目标方法的执行参数</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(args[0]);&#x2F;&#x2F; 打印入参</span><br><span class="line">        return method.invoke(computerIntf, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>通过<code>Proxy.newProxyInstance</code>方法创建代理类对象.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void jdkProxy() throws Exception &#123;</span><br><span class="line">	&#x2F;&#x2F; 目标对象</span><br><span class="line">	Computer computer &#x3D; new Computer();</span><br><span class="line">	&#x2F;&#x2F; 创建JdkInvocationHandler对象，并传递目标对象</span><br><span class="line">    JdkInvocationHandler jdkProxy &#x3D; new JdkInvocationHandler(computer);</span><br><span class="line">    &#x2F;&#x2F; 通过Proxy创建代理对象，分别传入：类加载器、目标对象接口数组、InvocationHandler对象。</span><br><span class="line">    &#x2F;&#x2F; *jdk代理对象是作为目标对象的接口的实现类。</span><br><span class="line">    ComputerIntf instance &#x3D; (ComputerIntf) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), Computer.class.getInterfaces(), jdkProxy);</span><br><span class="line">    instance.add(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行结果：</span><br><span class="line">入参：1</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h3><p>通过第三方包cglib来实现动态代理：</p>
<ol>
<li>首先创建一个<code>MethodInterceptor</code>的实现类，重写<code>intercept</code>方法，同样在方法调用前打印日志。增加一个静态方法<code>getProxyInstance</code>用来传递目标class和代理对象的生成。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class CglibMethodInterceptor implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;入参：&quot;+args[0]);</span><br><span class="line">        return methodProxy.invokeSuper(obj, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>通过cglib的<code>Enhancer</code>类设置父类和方法回调来创建出代理对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   @Test</span><br><span class="line">   public void cglibProxy() throws Exception &#123;</span><br><span class="line">    Enhancer enhancer &#x3D; new Enhancer();</span><br><span class="line">    &#x2F;&#x2F; *设置父类（cglib代理对象是继承目标对象，作为目标对象的子类）</span><br><span class="line">    enhancer.setSuperclass(targetClass);</span><br><span class="line">    &#x2F;&#x2F; 设置方法拦截器</span><br><span class="line">    enhancer.setCallback(new CglibMethodInterceptor());</span><br><span class="line">    &#x2F;&#x2F; 创建代理对象</span><br><span class="line">    Computer instance &#x3D; (Computer)enhancer.create();</span><br><span class="line">    instance.add(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行结果：</span><br><span class="line">入参：1    </span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="jdk和cglib动态代理类的生成源码分析"><a href="#jdk和cglib动态代理类的生成源码分析" class="headerlink" title="jdk和cglib动态代理类的生成源码分析"></a>jdk和cglib动态代理类的生成源码分析</h2><h3 id="jdk动态代理类源码分析"><a href="#jdk动态代理类源码分析" class="headerlink" title="jdk动态代理类源码分析"></a>jdk动态代理类源码分析</h3><p>首先我们看下Proxy.newProxyInstance()方法的源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader,&#x2F;&#x2F; 类加载器</span><br><span class="line">                                      Class&lt;?&gt;[] interfaces,&#x2F;&#x2F; 目标类的接口</span><br><span class="line">                                      InvocationHandler h&#x2F;&#x2F; 自定义的InvocationHandler实现类对象</span><br><span class="line">                                      )</span><br><span class="line">    throws IllegalArgumentException&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    final Class&lt;?&gt;[] intfs &#x3D; interfaces.clone();</span><br><span class="line">    final SecurityManager sm &#x3D; System.getSecurityManager();</span><br><span class="line">    if (sm !&#x3D; null) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * Look up or generate the designated proxy class.</span><br><span class="line">     *&#x2F;</span><br><span class="line">     &#x2F;&#x2F; 查询或生成指定的代理类</span><br><span class="line">    Class&lt;?&gt; cl &#x3D; getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * Invoke its constructor with the designated invocation handler.</span><br><span class="line">     *&#x2F;</span><br><span class="line">     &#x2F;&#x2F; 调用代理类的构造方法，指定handler对象</span><br><span class="line">    try &#123;</span><br><span class="line">        if (sm !&#x3D; null) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final Constructor&lt;?&gt; cons &#x3D; cl.getConstructor(constructorParams);</span><br><span class="line">        final InvocationHandler ih &#x3D; h;</span><br><span class="line">        if (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                public Void run() &#123;</span><br><span class="line">                    cons.setAccessible(true);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 通过反射实例化代理对象，传入h对象。</span><br><span class="line">        return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class="line">    &#125; catch (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">        throw new InternalError(e.toString(), e);</span><br><span class="line">    &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">        Throwable t &#x3D; e.getCause();</span><br><span class="line">        if (t instanceof RuntimeException) &#123;</span><br><span class="line">            throw (RuntimeException) t;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new InternalError(t.toString(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">        throw new InternalError(e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取代理类</span><br><span class="line">private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    if (interfaces.length &gt; 65535) &#123;&#x2F;&#x2F; 推测这个和索引计数器2个字节长度相关，2个字节最大为2^16次方为65536。</span><br><span class="line">        throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If the proxy class defined by the given loader implementing</span><br><span class="line">    &#x2F;&#x2F; the given interfaces exists, this will simply return the cached copy;</span><br><span class="line">    &#x2F;&#x2F; otherwise, it will create the proxy class via the ProxyClassFactory</span><br><span class="line">    &#x2F;&#x2F; 如果已给的加载器和接口的实现已经存在则返回缓存的副本，否则将会通过ProxyClassFactory创建代理类。</span><br><span class="line">    return proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>上面的方法主要是对代理类的构造方法传入InvocationHandler对象并返回实例，具体还要看ProxyClassFactory的apply方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; prefix for all proxy class names</span><br><span class="line">    private static final String proxyClassNamePrefix &#x3D; &quot;$Proxy&quot;;&#x2F;&#x2F; 代理类前缀</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; next number to use for generation of unique proxy class names</span><br><span class="line">    private static final AtomicLong nextUniqueNumber &#x3D; new AtomicLong();&#x2F;&#x2F; 通过原子类实现代理类的线程安全递增</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 生成代理类</span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet &#x3D; new IdentityHashMap&lt;&gt;(interfaces.length);&#x2F;&#x2F; 一致hashmap，用来判断接口重复</span><br><span class="line">        &#x2F;&#x2F; 循环检测每个接口</span><br><span class="line">        for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            &#x2F;*</span><br><span class="line">             * Verify that the class loader resolves the name of this</span><br><span class="line">             * interface to the same Class object.</span><br><span class="line">             *&#x2F;</span><br><span class="line">             &#x2F;&#x2F; 校验类名解析出来的和实际的是否一致</span><br><span class="line">            Class&lt;?&gt; interfaceClass &#x3D; null;</span><br><span class="line">            try &#123;</span><br><span class="line">                interfaceClass &#x3D; Class.forName(intf.getName(), false, loader);</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            if (interfaceClass !&#x3D; intf) &#123;</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                    intf + &quot; is not visible from class loader&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;*</span><br><span class="line">             * Verify that the Class object actually represents an</span><br><span class="line">             * interface.</span><br><span class="line">             *&#x2F;</span><br><span class="line">             &#x2F;&#x2F; 验证接口是接口 😊</span><br><span class="line">            if (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                    interfaceClass.getName() + &quot; is not an interface&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;*</span><br><span class="line">             * Verify that this interface is not a duplicate.</span><br><span class="line">             *&#x2F;</span><br><span class="line">             &#x2F;&#x2F; 验证是否有重复接口</span><br><span class="line">            if (interfaceSet.put(interfaceClass, Boolean.TRUE) !&#x3D; null) &#123;</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                    &quot;repeated interface: &quot; + interfaceClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String proxyPkg &#x3D; null;     &#x2F;&#x2F; package to define proxy class in</span><br><span class="line">        int accessFlags &#x3D; Modifier.PUBLIC | Modifier.FINAL;&#x2F;&#x2F; 设置访问标志为public final类型</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Record the package of a non-public proxy interface so that the</span><br><span class="line">         * proxy class will be defined in the same package.  Verify that</span><br><span class="line">         * all non-public proxy interfaces are in the same package.</span><br><span class="line">         *&#x2F;</span><br><span class="line">         &#x2F;&#x2F; 再次循环接口，获取非public接口，验证是否都在同一个包中，因为接口可以不用public声明，就是包中可见，如果非public出现在不同包是有问题的。</span><br><span class="line">        for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            int flags &#x3D; intf.getModifiers();</span><br><span class="line">            if (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                accessFlags &#x3D; Modifier.FINAL;&#x2F;&#x2F; 如果接口是非public，那么代理类也设为非public。</span><br><span class="line">                String name &#x3D; intf.getName();</span><br><span class="line">                int n &#x3D; name.lastIndexOf(&#39;.&#39;);</span><br><span class="line">                String pkg &#x3D; ((n &#x3D;&#x3D; -1) ? &quot;&quot; : name.substring(0, n + 1));</span><br><span class="line">                if (proxyPkg &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    proxyPkg &#x3D; pkg;</span><br><span class="line">                &#125; else if (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                    throw new IllegalArgumentException(</span><br><span class="line">                        &quot;non-public interfaces from different packages&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 设置代理类包</span><br><span class="line">        if (proxyPkg &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; if no non-public proxy interfaces, use com.sun.proxy package</span><br><span class="line">            proxyPkg &#x3D; ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Choose a name for the proxy class to generate.</span><br><span class="line">         *&#x2F;</span><br><span class="line">         &#x2F;&#x2F; 递增并生成代理类完整名称</span><br><span class="line">        long num &#x3D; nextUniqueNumber.getAndIncrement();</span><br><span class="line">        String proxyName &#x3D; proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Generate the specified proxy class.</span><br><span class="line">         *&#x2F;</span><br><span class="line">         &#x2F;&#x2F; 生成指定的代理类</span><br><span class="line">        byte[] proxyClassFile &#x3D; ProxyGenerator.generateProxyClass(</span><br><span class="line">            proxyName, interfaces, accessFlags);</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 加载类字节到jvm虚拟机中</span><br><span class="line">            return defineClass0(loader, proxyName,</span><br><span class="line">                                proxyClassFile, 0, proxyClassFile.length);</span><br><span class="line">        &#125; catch (ClassFormatError e) &#123;</span><br><span class="line">            &#x2F;*</span><br><span class="line">             * A ClassFormatError here means that (barring bugs in the</span><br><span class="line">             * proxy class generation code) there was some other</span><br><span class="line">             * invalid aspect of the arguments supplied to the proxy</span><br><span class="line">             * class creation (such as virtual machine limitations</span><br><span class="line">             * exceeded).</span><br><span class="line">             *&#x2F;</span><br><span class="line">            throw new IllegalArgumentException(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码主要是对接口的校验，代理类的名称生成和访问标志的设定，具体代理类的生成在ProxyGenerator.generateProxyClass方法中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private static final boolean saveGeneratedFiles &#x3D; (Boolean)AccessController.doPrivileged(new GetBooleanAction(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;));</span><br><span class="line"></span><br><span class="line">public static byte[] generateProxyClass(final String var0, Class&lt;?&gt;[] var1, int var2) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建代理生成器对象</span><br><span class="line">    ProxyGenerator var3 &#x3D; new ProxyGenerator(var0, var1, var2);</span><br><span class="line">    &#x2F;&#x2F; 生成代理对象</span><br><span class="line">    final byte[] var4 &#x3D; var3.generateClassFile();</span><br><span class="line">    &#x2F;&#x2F; 根据sun.misc.ProxyGenerator.saveGeneratedFiles参数来判断是否要保存生成的代理类文件，使用方法下文会演示到。</span><br><span class="line">    if (saveGeneratedFiles) &#123;</span><br><span class="line">        AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">            public Void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    int var1 &#x3D; var0.lastIndexOf(46);</span><br><span class="line">                    Path var2;</span><br><span class="line">                    if (var1 &gt; 0) &#123;</span><br><span class="line">                        Path var3 &#x3D; Paths.get(var0.substring(0, var1).replace(&#39;.&#39;, File.separatorChar));</span><br><span class="line">                        Files.createDirectories(var3);</span><br><span class="line">                        var2 &#x3D; var3.resolve(var0.substring(var1 + 1, var0.length()) + &quot;.class&quot;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        var2 &#x3D; Paths.get(var0 + &quot;.class&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Files.write(var2, var4, new OpenOption[0]);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125; catch (IOException var4x) &#123;</span><br><span class="line">                    throw new InternalError(&quot;I&#x2F;O exception saving generated file: &quot; + var4x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return var4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码通过代理类全名，接口数组，访问标志创建了一个代理类生成器，调用代理类生成器<code>generateClassFile()</code>方法最终生成代理类字节码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 生成类文件</span><br><span class="line">private byte[] generateClassFile() &#123;</span><br><span class="line">    &#x2F;&#x2F; 加入Object三个字带方法</span><br><span class="line">    this.addProxyMethod(hashCodeMethod, Object.class);</span><br><span class="line">    this.addProxyMethod(equalsMethod, Object.class);</span><br><span class="line">    this.addProxyMethod(toStringMethod, Object.class);</span><br><span class="line">    Class[] var1 &#x3D; this.interfaces;</span><br><span class="line">    int var2 &#x3D; var1.length;</span><br><span class="line"></span><br><span class="line">    int var3;</span><br><span class="line">    Class var4;</span><br><span class="line">    &#x2F;&#x2F; 循环加入目标类接口的方法</span><br><span class="line">    for(var3 &#x3D; 0; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">        var4 &#x3D; var1[var3];</span><br><span class="line">        Method[] var5 &#x3D; var4.getMethods();</span><br><span class="line">        int var6 &#x3D; var5.length;</span><br><span class="line"></span><br><span class="line">        for(int var7 &#x3D; 0; var7 &lt; var6; ++var7) &#123;</span><br><span class="line">            Method var8 &#x3D; var5[var7];</span><br><span class="line">            this.addProxyMethod(var8, var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Iterator var11 &#x3D; this.proxyMethods.values().iterator();</span><br><span class="line"></span><br><span class="line">    List var12;</span><br><span class="line">    while(var11.hasNext()) &#123;</span><br><span class="line">        var12 &#x3D; (List)var11.next();</span><br><span class="line">        checkReturnTypes(var12);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Iterator var15;</span><br><span class="line">    try &#123;</span><br><span class="line">        this.methods.add(this.generateConstructor());</span><br><span class="line">        var11 &#x3D; this.proxyMethods.values().iterator();</span><br><span class="line"></span><br><span class="line">        while(var11.hasNext()) &#123;</span><br><span class="line">            var12 &#x3D; (List)var11.next();</span><br><span class="line">            var15 &#x3D; var12.iterator();</span><br><span class="line"></span><br><span class="line">            while(var15.hasNext()) &#123;</span><br><span class="line">                ProxyGenerator.ProxyMethod var16 &#x3D; (ProxyGenerator.ProxyMethod)var15.next();</span><br><span class="line">                this.fields.add(new ProxyGenerator.FieldInfo(var16.methodFieldName, &quot;Ljava&#x2F;lang&#x2F;reflect&#x2F;Method;&quot;, 10));</span><br><span class="line">                this.methods.add(var16.generateMethod());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.methods.add(this.generateStaticInitializer());</span><br><span class="line">    &#125; catch (IOException var10) &#123;</span><br><span class="line">        throw new InternalError(&quot;unexpected I&#x2F;O Exception&quot;, var10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.methods.size() &gt; 65535) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;method limit exceeded&quot;);</span><br><span class="line">    &#125; else if (this.fields.size() &gt; 65535) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;field limit exceeded&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.cp.getClass(dotToSlash(this.className));</span><br><span class="line">        this.cp.getClass(&quot;java&#x2F;lang&#x2F;reflect&#x2F;Proxy&quot;);</span><br><span class="line">        var1 &#x3D; this.interfaces;</span><br><span class="line">        var2 &#x3D; var1.length;</span><br><span class="line"></span><br><span class="line">        for(var3 &#x3D; 0; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">            var4 &#x3D; var1[var3];</span><br><span class="line">            this.cp.getClass(dotToSlash(var4.getName()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.cp.setReadOnly();</span><br><span class="line">        ByteArrayOutputStream var13 &#x3D; new ByteArrayOutputStream();</span><br><span class="line">        DataOutputStream var14 &#x3D; new DataOutputStream(var13);</span><br><span class="line">        &#x2F;&#x2F; 拼接代理类字节码</span><br><span class="line">        try &#123;</span><br><span class="line">            var14.writeInt(-889275714);&#x2F;&#x2F; cafe babe</span><br><span class="line">            var14.writeShort(0);</span><br><span class="line">            var14.writeShort(49);</span><br><span class="line">            this.cp.write(var14);</span><br><span class="line">            var14.writeShort(this.accessFlags);</span><br><span class="line">            var14.writeShort(this.cp.getClass(dotToSlash(this.className)));</span><br><span class="line">            var14.writeShort(this.cp.getClass(&quot;java&#x2F;lang&#x2F;reflect&#x2F;Proxy&quot;));</span><br><span class="line">            var14.writeShort(this.interfaces.length);</span><br><span class="line">            Class[] var17 &#x3D; this.interfaces;</span><br><span class="line">            int var18 &#x3D; var17.length;</span><br><span class="line"></span><br><span class="line">            for(int var19 &#x3D; 0; var19 &lt; var18; ++var19) &#123;</span><br><span class="line">                Class var22 &#x3D; var17[var19];</span><br><span class="line">                var14.writeShort(this.cp.getClass(dotToSlash(var22.getName())));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var14.writeShort(this.fields.size());</span><br><span class="line">            var15 &#x3D; this.fields.iterator();</span><br><span class="line"></span><br><span class="line">            while(var15.hasNext()) &#123;</span><br><span class="line">                ProxyGenerator.FieldInfo var20 &#x3D; (ProxyGenerator.FieldInfo)var15.next();</span><br><span class="line">                var20.write(var14);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var14.writeShort(this.methods.size());</span><br><span class="line">            var15 &#x3D; this.methods.iterator();</span><br><span class="line"></span><br><span class="line">            while(var15.hasNext()) &#123;</span><br><span class="line">                ProxyGenerator.MethodInfo var21 &#x3D; (ProxyGenerator.MethodInfo)var15.next();</span><br><span class="line">                var21.write(var14);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var14.writeShort(0);</span><br><span class="line">            return var13.toByteArray();</span><br><span class="line">        &#125; catch (IOException var9) &#123;</span><br><span class="line">            throw new InternalError(&quot;unexpected I&#x2F;O Exception&quot;, var9);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于我们通过层层代码看到了代理类的生成过程，主要是使用DataOutputStream将转换过的修饰符，方法，属性等逐个按照固定长度writeShort写入到byte中（接近class字节码的拼接，不是很直观），jdk代理类的具体生成还是比较原始，下面我们对比着了解下cglib的动态代理类生成过程。</p>
<h3 id="cglib动态代理类源码分析"><a href="#cglib动态代理类源码分析" class="headerlink" title="cglib动态代理类源码分析"></a>cglib动态代理类源码分析</h3><p>首先我们通过enhancer.create()方法创建代理类，见源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public Object create() &#123;</span><br><span class="line">    classOnly &#x3D; false;</span><br><span class="line">    argumentTypes &#x3D; null;</span><br><span class="line">    return createHelper();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 创建辅助方法</span><br><span class="line">private Object createHelper() &#123;</span><br><span class="line">    preValidate();&#x2F;&#x2F; 也是先做些前置校验</span><br><span class="line">    &#x2F;&#x2F; 动态生成Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72.class类，根据下面参数来生成唯一的key对象</span><br><span class="line">    Object key &#x3D; KEY_FACTORY.newInstance((superclass !&#x3D; null) ? superclass.getName() : null,</span><br><span class="line">            ReflectUtils.getNames(interfaces),</span><br><span class="line">            filter &#x3D;&#x3D; ALL_ZERO ? null : new WeakCacheKey&lt;CallbackFilter&gt;(filter),</span><br><span class="line">            callbackTypes,</span><br><span class="line">            useFactory,</span><br><span class="line">            interceptDuringConstruction,</span><br><span class="line">            serialVersionUID);</span><br><span class="line">    this.currentKey &#x3D; key;</span><br><span class="line">    &#x2F;&#x2F; 创建代理对象</span><br><span class="line">    Object result &#x3D; super.create(key);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来执行super.create(key)，也就是AbstractClassGenerator.create方法创建代理对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">private static volatile Map&lt;ClassLoader, ClassLoaderData&gt; CACHE &#x3D; new WeakHashMap&lt;ClassLoader, ClassLoaderData&gt;();</span><br><span class="line"></span><br><span class="line">protected Object create(Object key) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ClassLoader loader &#x3D; getClassLoader();&#x2F;&#x2F; 获取类加载器，先默认的，没有则用自己的，否则就用当前线程的</span><br><span class="line">        Map&lt;ClassLoader, ClassLoaderData&gt; cache &#x3D; CACHE;</span><br><span class="line">        ClassLoaderData data &#x3D; cache.get(loader);</span><br><span class="line">        &#x2F;&#x2F; 如果为空则创建一个放入缓存</span><br><span class="line">        if (data &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized (AbstractClassGenerator.class) &#123;</span><br><span class="line">                cache &#x3D; CACHE;</span><br><span class="line">                data &#x3D; cache.get(loader);</span><br><span class="line">                if (data &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    Map&lt;ClassLoader, ClassLoaderData&gt; newCache &#x3D; new WeakHashMap&lt;ClassLoader, ClassLoaderData&gt;(cache);</span><br><span class="line">                    data &#x3D; new ClassLoaderData(loader);</span><br><span class="line">                    newCache.put(loader, data);</span><br><span class="line">                    CACHE &#x3D; newCache;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.key &#x3D; key;</span><br><span class="line">        &#x2F;&#x2F; 获取或生成代理类对象</span><br><span class="line">        Object obj &#x3D; data.get(this, getUseCache());</span><br><span class="line">        if (obj instanceof Class) &#123;</span><br><span class="line">            return firstInstance((Class) obj);</span><br><span class="line">        &#125;</span><br><span class="line">        return nextInstance(obj);</span><br><span class="line">    &#125; catch (RuntimeException e) &#123;</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; catch (Error e) &#123;</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new CodeGenerationException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected static class ClassLoaderData &#123;</span><br><span class="line">    private final Set&lt;String&gt; reservedClassNames &#x3D; new HashSet&lt;String&gt;();</span><br><span class="line">    &#x2F;&#x2F; 获取代理类，如果没有开启缓存则生成类，否则上缓存中获取或创建并加入缓存</span><br><span class="line">    public Object get(AbstractClassGenerator gen, boolean useCache) &#123;</span><br><span class="line">        if (!useCache) &#123;</span><br><span class="line">          return gen.generate(ClassLoaderData.this);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          Object cachedValue &#x3D; generatedClasses.get(gen);</span><br><span class="line">          return gen.unwrapCachedValue(cachedValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure>

<p>接着调用AbstractClassGenerator类的对象方法gen.generate(ClassLoaderData.this)创建代理类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">protected Class generate(ClassLoaderData data) &#123;</span><br><span class="line">    Class gen;</span><br><span class="line">    Object save &#x3D; CURRENT.get();</span><br><span class="line">    CURRENT.set(this);</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取加载器</span><br><span class="line">        ClassLoader classLoader &#x3D; data.getClassLoader();</span><br><span class="line">        if (classLoader &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;ClassLoader is null while trying to define class &quot; +</span><br><span class="line">                    getClassName() + &quot;. It seems that the loader has been expired from a weak reference somehow. &quot; +</span><br><span class="line">                    &quot;Please file an issue at cglib&#39;s issue tracker.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 生成代理类完整名字类似：demo.other.proxy.Computer$$EnhancerByCGLIB$$db5e966a</span><br><span class="line">        synchronized (classLoader) &#123;</span><br><span class="line">          String name &#x3D; generateClassName(data.getUniqueNamePredicate());              </span><br><span class="line">          data.reserveName(name);</span><br><span class="line">          this.setClassName(name);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果尝试加载为true则加载一次，失败了继续生成代理类，否则返回代理类</span><br><span class="line">        if (attemptLoad) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                gen &#x3D; classLoader.loadClass(getClassName());</span><br><span class="line">                return gen;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; ignore</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 生成代理类字节</span><br><span class="line">        byte[] b &#x3D; strategy.generate(this);</span><br><span class="line">        &#x2F;&#x2F; 获取代理类名称</span><br><span class="line">        String className &#x3D; ClassNameReader.getClassName(new ClassReader(b));</span><br><span class="line">        ProtectionDomain protectionDomain &#x3D; getProtectionDomain();</span><br><span class="line">        &#x2F;&#x2F; 通过类字节创建代理类</span><br><span class="line">        synchronized (classLoader) &#123; &#x2F;&#x2F; just in case 以防万一 😓</span><br><span class="line">            if (protectionDomain &#x3D;&#x3D; null) &#123;</span><br><span class="line">                gen &#x3D; ReflectUtils.defineClass(className, b, classLoader);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                gen &#x3D; ReflectUtils.defineClass(className, b, classLoader, protectionDomain);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return gen;</span><br><span class="line">    &#125; catch (RuntimeException e) &#123;</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; catch (Error e) &#123;</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new CodeGenerationException(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        CURRENT.set(save);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们看下strategy.generate(this)的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultGeneratorStrategy implements GeneratorStrategy &#123;</span><br><span class="line">    public static final DefaultGeneratorStrategy INSTANCE &#x3D; new DefaultGeneratorStrategy();</span><br><span class="line">    </span><br><span class="line">    public byte[] generate(ClassGenerator cg) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取asm的类写器</span><br><span class="line">        DebuggingClassWriter cw &#x3D; getClassVisitor();</span><br><span class="line">        &#x2F;&#x2F; 生成字节码</span><br><span class="line">        transform(cg).generateClass(cw);</span><br><span class="line">        return transform(cw.toByteArray());</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 获取asm的类写器</span><br><span class="line">    protected DebuggingClassWriter getClassVisitor() throws Exception &#123;</span><br><span class="line">      return new DebuggingClassWriter(ClassWriter.COMPUTE_FRAMES);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>通过debug我们最终跟踪到最终生成字节码的是KeyFactory.generateClass方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">public void generateClass(ClassVisitor v) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将类写器包装为类发射器 😺</span><br><span class="line">        ClassEmitter ce &#x3D; new ClassEmitter(v);</span><br><span class="line">        </span><br><span class="line">        Method newInstance &#x3D; ReflectUtils.findNewInstance(keyInterface);</span><br><span class="line">        if (!newInstance.getReturnType().equals(Object.class)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;newInstance method must return Object&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Type[] parameterTypes &#x3D; TypeUtils.getTypes(newInstance.getParameterTypes());</span><br><span class="line">        ce.begin_class(Constants.V1_8,</span><br><span class="line">                       Constants.ACC_PUBLIC,</span><br><span class="line">                       getClassName(),</span><br><span class="line">                       KEY_FACTORY,</span><br><span class="line">                       new Type[]&#123; Type.getType(keyInterface) &#125;,</span><br><span class="line">                       Constants.SOURCE_FILE);</span><br><span class="line">        EmitUtils.null_constructor(ce);</span><br><span class="line">        EmitUtils.factory_method(ce, ReflectUtils.getSignature(newInstance));</span><br><span class="line"></span><br><span class="line">        int seed &#x3D; 0;</span><br><span class="line">        CodeEmitter e &#x3D; ce.begin_method(Constants.ACC_PUBLIC,</span><br><span class="line">                                        TypeUtils.parseConstructor(parameterTypes),</span><br><span class="line">                                        null);</span><br><span class="line">        e.load_this();</span><br><span class="line">        e.super_invoke_constructor();</span><br><span class="line">        e.load_this();</span><br><span class="line">        List&lt;FieldTypeCustomizer&gt; fieldTypeCustomizers &#x3D; getCustomizers(FieldTypeCustomizer.class);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">            Type parameterType &#x3D; parameterTypes[i];</span><br><span class="line">            Type fieldType &#x3D; parameterType;</span><br><span class="line">            for (FieldTypeCustomizer customizer : fieldTypeCustomizers) &#123;</span><br><span class="line">                fieldType &#x3D; customizer.getOutType(i, fieldType);</span><br><span class="line">            &#125;</span><br><span class="line">            seed +&#x3D; fieldType.hashCode();</span><br><span class="line">            ce.declare_field(Constants.ACC_PRIVATE | Constants.ACC_FINAL,</span><br><span class="line">                             getFieldName(i),</span><br><span class="line">                             fieldType,</span><br><span class="line">                             null);</span><br><span class="line">            e.dup();</span><br><span class="line">            e.load_arg(i);</span><br><span class="line">            for (FieldTypeCustomizer customizer : fieldTypeCustomizers) &#123;</span><br><span class="line">                customizer.customize(e, i, parameterType);</span><br><span class="line">            &#125;</span><br><span class="line">            e.putfield(getFieldName(i));</span><br><span class="line">        &#125;</span><br><span class="line">        e.return_value();</span><br><span class="line">        e.end_method();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; hash code</span><br><span class="line">        e &#x3D; ce.begin_method(Constants.ACC_PUBLIC, HASH_CODE, null);</span><br><span class="line">        int hc &#x3D; (constant !&#x3D; 0) ? constant : PRIMES[(int)(Math.abs(seed) % PRIMES.length)];</span><br><span class="line">        int hm &#x3D; (multiplier !&#x3D; 0) ? multiplier : PRIMES[(int)(Math.abs(seed * 13) % PRIMES.length)];</span><br><span class="line">        e.push(hc);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">            e.load_this();</span><br><span class="line">            e.getfield(getFieldName(i));</span><br><span class="line">            EmitUtils.hash_code(e, parameterTypes[i], hm, customizers);</span><br><span class="line">        &#125;</span><br><span class="line">        e.return_value();</span><br><span class="line">        e.end_method();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; equals</span><br><span class="line">        e &#x3D; ce.begin_method(Constants.ACC_PUBLIC, EQUALS, null);</span><br><span class="line">        Label fail &#x3D; e.make_label();</span><br><span class="line">        e.load_arg(0);</span><br><span class="line">        e.instance_of_this();</span><br><span class="line">        e.if_jump(e.EQ, fail);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">            e.load_this();</span><br><span class="line">            e.getfield(getFieldName(i));</span><br><span class="line">            e.load_arg(0);</span><br><span class="line">            e.checkcast_this();</span><br><span class="line">            e.getfield(getFieldName(i));</span><br><span class="line">            EmitUtils.not_equals(e, parameterTypes[i], fail, customizers);</span><br><span class="line">        &#125;</span><br><span class="line">        e.push(1);</span><br><span class="line">        e.return_value();</span><br><span class="line">        e.mark(fail);</span><br><span class="line">        e.push(0);</span><br><span class="line">        e.return_value();</span><br><span class="line">        e.end_method();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; toString</span><br><span class="line">        e &#x3D; ce.begin_method(Constants.ACC_PUBLIC, TO_STRING, null);</span><br><span class="line">        e.new_instance(Constants.TYPE_STRING_BUFFER);</span><br><span class="line">        e.dup();</span><br><span class="line">        e.invoke_constructor(Constants.TYPE_STRING_BUFFER);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">            if (i &gt; 0) &#123;</span><br><span class="line">                e.push(&quot;, &quot;);</span><br><span class="line">                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);</span><br><span class="line">            &#125;</span><br><span class="line">            e.load_this();</span><br><span class="line">            e.getfield(getFieldName(i));</span><br><span class="line">            EmitUtils.append_string(e, parameterTypes[i], EmitUtils.DEFAULT_DELIMITERS, customizers);</span><br><span class="line">        &#125;</span><br><span class="line">        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, TO_STRING);</span><br><span class="line">        e.return_value();</span><br><span class="line">        e.end_method();</span><br><span class="line"></span><br><span class="line">        ce.end_class();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面最终就是通过asm的MethodVisitor的实现类CodeEmitter的生成字节码，这里暂不深究。</p>
<h2 id="jdk和cglib动态代理类的执行分析"><a href="#jdk和cglib动态代理类的执行分析" class="headerlink" title="jdk和cglib动态代理类的执行分析"></a>jdk和cglib动态代理类的执行分析</h2><h3 id="jdk和cglib谁更快"><a href="#jdk和cglib谁更快" class="headerlink" title="jdk和cglib谁更快"></a>jdk和cglib谁更快</h3><p>为了测试运行速度，写了一个小的demo，代码如下：<br>目标类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface ComputerIntf &#123;</span><br><span class="line">    int add(int i);</span><br><span class="line">&#125;</span><br><span class="line">public class Computer implements ComputerIntf &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int add(int i) &#123;</span><br><span class="line">        return i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>jdk代理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class JdkInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">    private ComputerIntf computerIntf;</span><br><span class="line">    public JdkInvocationHandler(ComputerIntf computerIntf) &#123;</span><br><span class="line">        this.computerIntf &#x3D; computerIntf;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        return method.invoke(computerIntf, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void jdkProxy() throws Exception &#123;</span><br><span class="line">&#x2F;&#x2F;        System.setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);&#x2F;&#x2F; 默认存放当前项目com&#x2F;sun&#x2F;proxy下</span><br><span class="line">    JdkInvocationHandler jdkProxy &#x3D; new JdkInvocationHandler(new Computer());</span><br><span class="line">    long begin &#x3D; System.currentTimeMillis();</span><br><span class="line">    ComputerIntf instance &#x3D; (ComputerIntf) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), Computer.class.getInterfaces(), jdkProxy);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 1000000000; i++) &#123;</span><br><span class="line">        instance.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(&quot;jdk耗时：&#123;&#125;&quot;,System.currentTimeMillis()-begin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行5次结果分别为：2611 2747 2739 2728 2660</p>
</blockquote>
<p>cglib代理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class CglibMethodInterceptor implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    public static Object getProxyInstance(Class targetClass) &#123;</span><br><span class="line">        Enhancer enhancer &#x3D; new Enhancer();</span><br><span class="line">        enhancer.setSuperclass(targetClass);</span><br><span class="line">        enhancer.setCallback(new CglibMethodInterceptor());</span><br><span class="line">        return enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        return methodProxy.invokeSuper(obj, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void cglibProxy() throws Exception &#123;</span><br><span class="line">&#x2F;&#x2F;        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;file&#x2F;proxy&quot;);</span><br><span class="line">    Computer instance &#x3D; (Computer) CglibMethodInterceptor.getProxyInstance(Computer.class);</span><br><span class="line">    long begin &#x3D; System.currentTimeMillis();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 100000000; i++) &#123;</span><br><span class="line">        instance.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(&quot;cglib耗时：&#123;&#125;&quot;,System.currentTimeMillis()-begin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行5次结果分别为：2799 2670 2683 2786 2607</p>
</blockquote>
<p><strong>结论</strong>：由上面测试结果可以看出在jdk1.8下，jdk动态代理类的运行速度和cglib动态代理类的运行速度实力相当，那么想进一步了解代理对象的执行过程请看下面内容。</p>
<h3 id="jdk动态代理类的方法执行过程"><a href="#jdk动态代理类的方法执行过程" class="headerlink" title="jdk动态代理类的方法执行过程"></a>jdk动态代理类的方法执行过程</h3><p>获取jdk生成的动态代理类有两种方法：</p>
<ol>
<li>在动态代理类创建前加上<code>System.setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);// 当前项目com/sun/proxy</code>代码。</li>
<li>设置jvm参数<code>-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true</code>。<br>生成的代理类$Proxy6.class反编译后代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; Source code recreated from a .class file by IntelliJ IDEA</span><br><span class="line">&#x2F;&#x2F; (powered by Fernflower decompiler)</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">package com.sun.proxy;</span><br><span class="line"></span><br><span class="line">import demo.other.proxy.ComputerIntf;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line">public final class $Proxy6 extends Proxy implements ComputerIntf &#123;</span><br><span class="line">    private static Method m1;</span><br><span class="line">    private static Method m3;</span><br><span class="line">    private static Method m2;</span><br><span class="line">    private static Method m0;</span><br><span class="line"></span><br><span class="line">    public $Proxy6(InvocationHandler var1) throws  &#123;</span><br><span class="line">        super(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object var1) throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; catch (RuntimeException | Error var3) &#123;</span><br><span class="line">            throw var3;</span><br><span class="line">        &#125; catch (Throwable var4) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 实现add方法</span><br><span class="line">    public final int add(int var1) throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">        	&#x2F;&#x2F; 将add方法最终传递给我们自定义的InvocationHandler</span><br><span class="line">            return (Integer)super.h.invoke(this, m3, new Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; catch (RuntimeException | Error var3) &#123;</span><br><span class="line">            throw var3;</span><br><span class="line">        &#125; catch (Throwable var4) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final String toString() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (String)super.h.invoke(this, m2, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final int hashCode() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Integer)super.h.invoke(this, m0, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 获取每个原始是方法</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            m1 &#x3D; Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));</span><br><span class="line">            m3 &#x3D; Class.forName(&quot;demo.other.proxy.ComputerIntf&quot;).getMethod(&quot;add&quot;, Integer.TYPE);</span><br><span class="line">            m2 &#x3D; Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;);</span><br><span class="line">            m0 &#x3D; Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;);</span><br><span class="line">        &#125; catch (NoSuchMethodException var2) &#123;</span><br><span class="line">            throw new NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; catch (ClassNotFoundException var3) &#123;</span><br><span class="line">            throw new NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
通过上面源码可以看出jdk生成的代理类是实现目标接口<code>ComputerIntf</code>的实现类，重写每个方法。在静态代码中获取每个原始方法<code>m0 m1 m2 m3</code>，然后在重写的方法中统一包装，最终调用<code>(Integer)super.h.invoke(this, m3, new Object[]&#123;var1&#125;)</code>。<br>具体的执行<code>add</code>方法过程如下：</li>
<li>当我们调用add方法时内部调用了<code>super.h.invoke(this, m3, new Object[]&#123;var1&#125;);</code></li>
<li>其实就是调用我们在创建代理对象时候传入的invocationHandler实现类的对象的<code>JdkInvocationHandler.invoke</code>方法，<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">	&#x2F;&#x2F; 增强逻辑...</span><br><span class="line">	&#x2F;&#x2F; 反射调用目标对象的方法</span><br><span class="line">    return method.invoke(computerIntf, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在执行<code>JdkInvocationHandler.invoke</code>方法时先执行我们自定义的增强逻辑（打印日志），然后执行通过反射执行目标方法<code>method.invoke</code>。</li>
</ol>
<p><strong>调用步骤:</strong> 执行代理类的add方法-&gt;执行代理类的父类中的invocationhandler对象的invoke方法-&gt;执行增强逻辑-&gt;通过反射执行目标方法。</p>
<h3 id="cglib动态代理类的方法执行过程"><a href="#cglib动态代理类的方法执行过程" class="headerlink" title="cglib动态代理类的方法执行过程"></a>cglib动态代理类的方法执行过程</h3><p>cglib自带获取动态代理类文件的设置:System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, “file/proxy”);<br>执行后我们竟然获取到三个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Computer$$EnhancerByCGLIB$$4ab32890$$FastClassByCGLIB$$fdfcab1d.class</span><br><span class="line">Computer$$EnhancerByCGLIB$$4ab32890.class</span><br><span class="line">Computer$$FastClassByCGLIB$$48de3884.class</span><br></pre></td></tr></table></figure>
<p>通过字节码反编译后可以看出Computer$$EnhancerByCGLIB$$4ab32890.class就是我们的代理类（代码比jdk生成的长）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; Source code recreated from a .class file by IntelliJ IDEA</span><br><span class="line">&#x2F;&#x2F; (powered by Fernflower decompiler)</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">package demo.other.proxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import net.sf.cglib.core.ReflectUtils;</span><br><span class="line">import net.sf.cglib.core.Signature;</span><br><span class="line">import net.sf.cglib.proxy.Callback;</span><br><span class="line">import net.sf.cglib.proxy.Factory;</span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">public class Computer$$EnhancerByCGLIB$$4ab32890 extends Computer implements Factory &#123;</span><br><span class="line">    private boolean CGLIB$BOUND;</span><br><span class="line">    public static Object CGLIB$FACTORY_DATA;</span><br><span class="line">    private static final ThreadLocal CGLIB$THREAD_CALLBACKS;</span><br><span class="line">    private static final Callback[] CGLIB$STATIC_CALLBACKS;</span><br><span class="line">    private MethodInterceptor CGLIB$CALLBACK_0;</span><br><span class="line">    private static Object CGLIB$CALLBACK_FILTER;</span><br><span class="line">    private static final Method CGLIB$add$0$Method;</span><br><span class="line">    private static final MethodProxy CGLIB$add$0$Proxy;</span><br><span class="line">    private static final Object[] CGLIB$emptyArgs;</span><br><span class="line">    private static final Method CGLIB$equals$1$Method;</span><br><span class="line">    private static final MethodProxy CGLIB$equals$1$Proxy;</span><br><span class="line">    private static final Method CGLIB$toString$2$Method;</span><br><span class="line">    private static final MethodProxy CGLIB$toString$2$Proxy;</span><br><span class="line">    private static final Method CGLIB$hashCode$3$Method;</span><br><span class="line">    private static final MethodProxy CGLIB$hashCode$3$Proxy;</span><br><span class="line">    private static final Method CGLIB$clone$4$Method;</span><br><span class="line">    private static final MethodProxy CGLIB$clone$4$Proxy;</span><br><span class="line"></span><br><span class="line">    static void CGLIB$STATICHOOK1() &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS &#x3D; new ThreadLocal();</span><br><span class="line">        CGLIB$emptyArgs &#x3D; new Object[0];</span><br><span class="line">        &#x2F;&#x2F; 加载动态代理类（也就是本身）</span><br><span class="line">        Class var0 &#x3D; Class.forName(&quot;demo.other.proxy.Computer$$EnhancerByCGLIB$$4ab32890&quot;);</span><br><span class="line">        Class var1;</span><br><span class="line">        Method[] var10000 &#x3D; ReflectUtils.findMethods(new String[]&#123;&quot;equals&quot;, &quot;(Ljava&#x2F;lang&#x2F;Object;)Z&quot;, &quot;toString&quot;, &quot;()Ljava&#x2F;lang&#x2F;String;&quot;, &quot;hashCode&quot;, &quot;()I&quot;, &quot;clone&quot;, &quot;()Ljava&#x2F;lang&#x2F;Object;&quot;&#125;, (var1 &#x3D; Class.forName(&quot;java.lang.Object&quot;)).getDeclaredMethods());</span><br><span class="line">        CGLIB$equals$1$Method &#x3D; var10000[0];</span><br><span class="line">        CGLIB$equals$1$Proxy &#x3D; MethodProxy.create(var1, var0, &quot;(Ljava&#x2F;lang&#x2F;Object;)Z&quot;, &quot;equals&quot;, &quot;CGLIB$equals$1&quot;);</span><br><span class="line">        CGLIB$toString$2$Method &#x3D; var10000[1];</span><br><span class="line">        CGLIB$toString$2$Proxy &#x3D; MethodProxy.create(var1, var0, &quot;()Ljava&#x2F;lang&#x2F;String;&quot;, &quot;toString&quot;, &quot;CGLIB$toString$2&quot;);</span><br><span class="line">        CGLIB$hashCode$3$Method &#x3D; var10000[2];</span><br><span class="line">        CGLIB$hashCode$3$Proxy &#x3D; MethodProxy.create(var1, var0, &quot;()I&quot;, &quot;hashCode&quot;, &quot;CGLIB$hashCode$3&quot;);</span><br><span class="line">        CGLIB$clone$4$Method &#x3D; var10000[3];</span><br><span class="line">        CGLIB$clone$4$Proxy &#x3D; MethodProxy.create(var1, var0, &quot;()Ljava&#x2F;lang&#x2F;Object;&quot;, &quot;clone&quot;, &quot;CGLIB$clone$4&quot;);</span><br><span class="line">        &#x2F;&#x2F; 获取目标类的原始方法</span><br><span class="line">        CGLIB$add$0$Method &#x3D; ReflectUtils.findMethods(new String[]&#123;&quot;add&quot;, &quot;(I)I&quot;&#125;, (var1 &#x3D; Class.forName(&quot;demo.other.proxy.Computer&quot;)).getDeclaredMethods())[0];</span><br><span class="line">        &#x2F;&#x2F; var1：demo.other.proxy.Computer的class对象</span><br><span class="line">        &#x2F;&#x2F; var0：demo.other.proxy.Computer$$EnhancerByCGLIB$$4ab32890的class对象</span><br><span class="line">        &#x2F;&#x2F; (I)I：表示入参和出参类型</span><br><span class="line">        &#x2F;&#x2F; add：对应var1的方法名</span><br><span class="line">        &#x2F;&#x2F; CGLIB$add$0：对应var0的方法名</span><br><span class="line">        CGLIB$add$0$Proxy &#x3D; MethodProxy.create(var1, var0, &quot;(I)I&quot;, &quot;add&quot;, &quot;CGLIB$add$0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 代理类的CGLIB$add$0</span><br><span class="line">    final int CGLIB$add$0(int var1) &#123;</span><br><span class="line">        return super.add(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 代理类重写父类的add方法</span><br><span class="line">    public final int add(int var1) &#123;</span><br><span class="line">        MethodInterceptor var10000 &#x3D; this.CGLIB$CALLBACK_0;</span><br><span class="line">        &#x2F;&#x2F; 初始化回调对象var10000（我们创建的CglibMethodInterceptor对象）</span><br><span class="line">        if (this.CGLIB$CALLBACK_0 &#x3D;&#x3D; null) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">            var10000 &#x3D; this.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (var10000 !&#x3D; null) &#123;</span><br><span class="line">        	&#x2F;&#x2F; 执行CglibMethodInterceptor对象的intercept方法</span><br><span class="line">            Object var2 &#x3D; var10000.intercept(this, CGLIB$add$0$Method, new Object[]&#123;new Integer(var1)&#125;, CGLIB$add$0$Proxy);</span><br><span class="line">            return var2 &#x3D;&#x3D; null ? 0 : ((Number)var2).intValue();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return super.add(var1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final boolean CGLIB$equals$1(Object var1) &#123;</span><br><span class="line">        return super.equals(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object var1) &#123;</span><br><span class="line">        MethodInterceptor var10000 &#x3D; this.CGLIB$CALLBACK_0;</span><br><span class="line">        if (this.CGLIB$CALLBACK_0 &#x3D;&#x3D; null) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">            var10000 &#x3D; this.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (var10000 !&#x3D; null) &#123;</span><br><span class="line">            Object var2 &#x3D; var10000.intercept(this, CGLIB$equals$1$Method, new Object[]&#123;var1&#125;, CGLIB$equals$1$Proxy);</span><br><span class="line">            return var2 &#x3D;&#x3D; null ? false : (Boolean)var2;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return super.equals(var1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final String CGLIB$toString$2() &#123;</span><br><span class="line">        return super.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final String toString() &#123;</span><br><span class="line">        MethodInterceptor var10000 &#x3D; this.CGLIB$CALLBACK_0;</span><br><span class="line">        if (this.CGLIB$CALLBACK_0 &#x3D;&#x3D; null) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">            var10000 &#x3D; this.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return var10000 !&#x3D; null ? (String)var10000.intercept(this, CGLIB$toString$2$Method, CGLIB$emptyArgs, CGLIB$toString$2$Proxy) : super.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static MethodProxy CGLIB$findMethodProxy(Signature var0) &#123;</span><br><span class="line">        String var10000 &#x3D; var0.toString();</span><br><span class="line">        switch(var10000.hashCode()) &#123;</span><br><span class="line">        case -1149925822:</span><br><span class="line">            if (var10000.equals(&quot;add(I)I&quot;)) &#123;</span><br><span class="line">                return CGLIB$add$0$Proxy;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case -508378822:</span><br><span class="line">            if (var10000.equals(&quot;clone()Ljava&#x2F;lang&#x2F;Object;&quot;)) &#123;</span><br><span class="line">                return CGLIB$clone$4$Proxy;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case 1826985398:</span><br><span class="line">            if (var10000.equals(&quot;equals(Ljava&#x2F;lang&#x2F;Object;)Z&quot;)) &#123;</span><br><span class="line">                return CGLIB$equals$1$Proxy;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case 1913648695:</span><br><span class="line">            if (var10000.equals(&quot;toString()Ljava&#x2F;lang&#x2F;String;&quot;)) &#123;</span><br><span class="line">                return CGLIB$toString$2$Proxy;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case 1984935277:</span><br><span class="line">            if (var10000.equals(&quot;hashCode()I&quot;)) &#123;</span><br><span class="line">                return CGLIB$hashCode$3$Proxy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Computer$$EnhancerByCGLIB$$4ab32890() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS.set(var0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) &#123;</span><br><span class="line">        CGLIB$STATIC_CALLBACKS &#x3D; var0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final void CGLIB$BIND_CALLBACKS(Object var0) &#123;</span><br><span class="line">        Computer$$EnhancerByCGLIB$$4ab32890 var1 &#x3D; (Computer$$EnhancerByCGLIB$$4ab32890)var0;</span><br><span class="line">        if (!var1.CGLIB$BOUND) &#123;</span><br><span class="line">            var1.CGLIB$BOUND &#x3D; true;</span><br><span class="line">            Object var10000 &#x3D; CGLIB$THREAD_CALLBACKS.get();</span><br><span class="line">            if (var10000 &#x3D;&#x3D; null) &#123;</span><br><span class="line">                var10000 &#x3D; CGLIB$STATIC_CALLBACKS;</span><br><span class="line">                if (CGLIB$STATIC_CALLBACKS &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var1.CGLIB$CALLBACK_0 &#x3D; (MethodInterceptor)((Callback[])var10000)[0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object newInstance(Callback[] var1) &#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(var1);</span><br><span class="line">        Computer$$EnhancerByCGLIB$$4ab32890 var10000 &#x3D; new Computer$$EnhancerByCGLIB$$4ab32890();</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);</span><br><span class="line">        return var10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object newInstance(Callback var1) &#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(new Callback[]&#123;var1&#125;);</span><br><span class="line">        Computer$$EnhancerByCGLIB$$4ab32890 var10000 &#x3D; new Computer$$EnhancerByCGLIB$$4ab32890();</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);</span><br><span class="line">        return var10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object newInstance(Class[] var1, Object[] var2, Callback[] var3) &#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(var3);</span><br><span class="line">        Computer$$EnhancerByCGLIB$$4ab32890 var10000 &#x3D; new Computer$$EnhancerByCGLIB$$4ab32890;</span><br><span class="line">        switch(var1.length) &#123;</span><br><span class="line">        case 0:</span><br><span class="line">            var10000.&lt;init&gt;();</span><br><span class="line">            CGLIB$SET_THREAD_CALLBACKS((Callback[])null);</span><br><span class="line">            return var10000;</span><br><span class="line">        default:</span><br><span class="line">            throw new IllegalArgumentException(&quot;Constructor not found&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Callback getCallback(int var1) &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">        MethodInterceptor var10000;</span><br><span class="line">        switch(var1) &#123;</span><br><span class="line">        case 0:</span><br><span class="line">            var10000 &#x3D; this.CGLIB$CALLBACK_0;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            var10000 &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return var10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCallback(int var1, Callback var2) &#123;</span><br><span class="line">        switch(var1) &#123;</span><br><span class="line">        case 0:</span><br><span class="line">            this.CGLIB$CALLBACK_0 &#x3D; (MethodInterceptor)var2;</span><br><span class="line">        default:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Callback[] getCallbacks() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">        return new Callback[]&#123;this.CGLIB$CALLBACK_0&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCallbacks(Callback[] var1) &#123;</span><br><span class="line">        this.CGLIB$CALLBACK_0 &#x3D; (MethodInterceptor)var1[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 初始化</span><br><span class="line">    static &#123;</span><br><span class="line">        CGLIB$STATICHOOK1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当我们代理对象调用add方法时候调用过程如下：<br>1.首先进行初始化CGLIB$STATICHOOK1()方法，主要目的就是获取目标类和代理类的class对象，获取目标类的方法（通过<code>ReflectUtils.findMethods</code>获取）和代理类的方法（通过<code>MethodProxy.create</code>获取）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">       CGLIB$STATICHOOK1();</span><br><span class="line">   &#125;</span><br><span class="line">  static void CGLIB$STATICHOOK1() &#123;</span><br><span class="line">       CGLIB$THREAD_CALLBACKS &#x3D; new ThreadLocal();</span><br><span class="line">       CGLIB$emptyArgs &#x3D; new Object[0];</span><br><span class="line">       Class var0 &#x3D; Class.forName(&quot;demo.other.proxy.Computer$$EnhancerByCGLIB$$4ab32890&quot;);</span><br><span class="line">       Class var1;</span><br><span class="line">       Method[] var10000 &#x3D; ReflectUtils.findMethods(new String[]&#123;&quot;equals&quot;, &quot;(Ljava&#x2F;lang&#x2F;Object;)Z&quot;, &quot;toString&quot;, &quot;()Ljava&#x2F;lang&#x2F;String;&quot;, &quot;hashCode&quot;, &quot;()I&quot;, &quot;clone&quot;, &quot;()Ljava&#x2F;lang&#x2F;Object;&quot;&#125;, (var1 &#x3D; Class.forName(&quot;java.lang.Object&quot;)).getDeclaredMethods());</span><br><span class="line">       CGLIB$equals$1$Method &#x3D; var10000[0];</span><br><span class="line">       CGLIB$equals$1$Proxy &#x3D; MethodProxy.create(var1, var0, &quot;(Ljava&#x2F;lang&#x2F;Object;)Z&quot;, &quot;equals&quot;, &quot;CGLIB$equals$1&quot;);</span><br><span class="line">       CGLIB$toString$2$Method &#x3D; var10000[1];</span><br><span class="line">       CGLIB$toString$2$Proxy &#x3D; MethodProxy.create(var1, var0, &quot;()Ljava&#x2F;lang&#x2F;String;&quot;, &quot;toString&quot;, &quot;CGLIB$toString$2&quot;);</span><br><span class="line">       CGLIB$hashCode$3$Method &#x3D; var10000[2];</span><br><span class="line">       CGLIB$hashCode$3$Proxy &#x3D; MethodProxy.create(var1, var0, &quot;()I&quot;, &quot;hashCode&quot;, &quot;CGLIB$hashCode$3&quot;);</span><br><span class="line">       CGLIB$clone$4$Method &#x3D; var10000[3];</span><br><span class="line">       CGLIB$clone$4$Proxy &#x3D; MethodProxy.create(var1, var0, &quot;()Ljava&#x2F;lang&#x2F;Object;&quot;, &quot;clone&quot;, &quot;CGLIB$clone$4&quot;);</span><br><span class="line">       CGLIB$add$0$Method &#x3D; ReflectUtils.findMethods(new String[]&#123;&quot;add&quot;, &quot;(I)I&quot;&#125;, (var1 &#x3D; Class.forName(&quot;demo.other.proxy.Computer&quot;)).getDeclaredMethods())[0];</span><br><span class="line">       CGLIB$add$0$Proxy &#x3D; MethodProxy.create(var1, var0, &quot;(I)I&quot;, &quot;add&quot;, &quot;CGLIB$add$0&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 获取目标对象的原始方法</span><br><span class="line">   public static Method[] findMethods(String[] namesAndDescriptors, Method[] methods)&#123;</span><br><span class="line">       Map map &#x3D; new HashMap();</span><br><span class="line">       for (int i &#x3D; 0; i &lt; methods.length; i++) &#123;</span><br><span class="line">           Method method &#x3D; methods[i];</span><br><span class="line">           map.put(method.getName() + Type.getMethodDescriptor(method), method);</span><br><span class="line">       &#125;</span><br><span class="line">       Method[] result &#x3D; new Method[namesAndDescriptors.length &#x2F; 2];</span><br><span class="line">       for (int i &#x3D; 0; i &lt; result.length; i++) &#123;</span><br><span class="line">           result[i] &#x3D; (Method)map.get(namesAndDescriptors[i * 2] + namesAndDescriptors[i * 2 + 1]);</span><br><span class="line">           if (result[i] &#x3D;&#x3D; null) &#123;</span><br><span class="line">               &#x2F;&#x2F; TODO: error?</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 根据目标类和代理类及目标方法名（add）和代理方法名（CGLIB$add$0）创建代理方法</span><br><span class="line">   public static MethodProxy create(Class c1, Class c2, String desc, String name1, String name2) &#123;</span><br><span class="line">       MethodProxy proxy &#x3D; new MethodProxy();</span><br><span class="line">       proxy.sig1 &#x3D; new Signature(name1, desc);</span><br><span class="line">       proxy.sig2 &#x3D; new Signature(name2, desc);</span><br><span class="line">       proxy.createInfo &#x3D; new CreateInfo(c1, c2);</span><br><span class="line">       return proxy;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.执行代理类的add方法，设置代理类的回调对象var10000（也就是我们在enhancer.setCallBack传入的CglibMethodInterceptor对象）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MethodInterceptor var10000 &#x3D; this.CGLIB$CALLBACK_0;</span><br><span class="line">      &#x2F;&#x2F; 初始化回调对象var10000（我们创建的CglibMethodInterceptor对象）</span><br><span class="line">      if (this.CGLIB$CALLBACK_0 &#x3D;&#x3D; null) &#123;</span><br><span class="line">          CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">          var10000 &#x3D; this.CGLIB$CALLBACK_0;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>3.调用方法拦截器的var10000的intercept方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object var2 &#x3D; var10000.intercept(this, CGLIB$add$0$Method, new Object[]&#123;new Integer(var1)&#125;, CGLIB$add$0$Proxy);</span><br></pre></td></tr></table></figure>
<p>4.执行我们在CglibMethodInterceptor.intercept的增强逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">    &#x2F;&#x2F; 增强逻辑</span><br><span class="line">    System.out.println(args[0]);</span><br><span class="line">    &#x2F;&#x2F; 通过代理方法调用执行目标方法</span><br><span class="line">    return methodProxy.invokeSuper(obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.执行methodProxy.invokeSuper方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; obj：代理对象</span><br><span class="line">&#x2F;&#x2F; args：方法入参</span><br><span class="line">   public Object invokeSuper(Object obj, Object[] args) throws Throwable &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">       	&#x2F;&#x2F; 初始化fast类</span><br><span class="line">           init();</span><br><span class="line">           FastClassInfo fci &#x3D; fastClassInfo;</span><br><span class="line">           &#x2F;&#x2F; 调用代理类的方法</span><br><span class="line">           return fci.f2.invoke(fci.i2, obj, args);</span><br><span class="line">       &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">           throw e.getTargetException();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>MethodProxy执行init方法生成快速类FastClass。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">private void init()&#123;</span><br><span class="line">    if (fastClassInfo &#x3D;&#x3D; null)</span><br><span class="line">    &#123;</span><br><span class="line">        synchronized (initLock)</span><br><span class="line">        &#123;</span><br><span class="line">            if (fastClassInfo &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                CreateInfo ci &#x3D; createInfo;&#x2F;&#x2F; 在代理类中CGLIB$STATICHOOK1()方法中创建methodProxy时候初始化，存放目标类和代理类及他们的命名方针和生成策略。</span><br><span class="line">                FastClassInfo fci &#x3D; new FastClassInfo();</span><br><span class="line">                fci.f1 &#x3D; helper(ci, ci.c1);&#x2F;&#x2F; 生成目标类的快速类Computer$$FastClassByCGLIB$$48de3884.class</span><br><span class="line">                fci.f2 &#x3D; helper(ci, ci.c2);&#x2F;&#x2F; 生成代理类的快速类Computer$$EnhancerByCGLIB$$4ab32890$$FastClassByCGLIB$$fdfcab1d.class</span><br><span class="line">                fci.i1 &#x3D; fci.f1.getIndex(sig1);&#x2F;&#x2F; 通过快速类和方法签名获取方法索引</span><br><span class="line">                fci.i2 &#x3D; fci.f2.getIndex(sig2);&#x2F;&#x2F; 通过快速类和方法签名获取方法索引</span><br><span class="line">                fastClassInfo &#x3D; fci;</span><br><span class="line">                createInfo &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 创建信息类</span><br><span class="line">private static class CreateInfo&#123;</span><br><span class="line">    Class c1;&#x2F;&#x2F; 目标类</span><br><span class="line">    Class c2;&#x2F;&#x2F; 代理类</span><br><span class="line">    NamingPolicy namingPolicy;</span><br><span class="line">    GeneratorStrategy strategy;</span><br><span class="line">    boolean attemptLoad;</span><br><span class="line">    public CreateInfo(Class c1, Class c2)</span><br><span class="line">    &#123;</span><br><span class="line">        this.c1 &#x3D; c1;</span><br><span class="line">        this.c2 &#x3D; c2;</span><br><span class="line">        AbstractClassGenerator fromEnhancer &#x3D; AbstractClassGenerator.getCurrent();</span><br><span class="line">        if (fromEnhancer !&#x3D; null) &#123;</span><br><span class="line">            namingPolicy &#x3D; fromEnhancer.getNamingPolicy();</span><br><span class="line">            strategy &#x3D; fromEnhancer.getStrategy();</span><br><span class="line">            attemptLoad &#x3D; fromEnhancer.getAttemptLoad();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 根据生成器生成快速类</span><br><span class="line">private static FastClass helper(CreateInfo ci, Class type) &#123;</span><br><span class="line">    FastClass.Generator g &#x3D; new FastClass.Generator();</span><br><span class="line">    g.setType(type);</span><br><span class="line">    g.setClassLoader(ci.c2.getClassLoader());</span><br><span class="line">    g.setNamingPolicy(ci.namingPolicy);</span><br><span class="line">    g.setStrategy(ci.strategy);</span><br><span class="line">    g.setAttemptLoad(ci.attemptLoad);</span><br><span class="line">    return g.create();</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>生成的两个快速类反编译部分源码：<br>代理类的快速类：Computer$$EnhancerByCGLIB$$4ab32890$$FastClassByCGLIB$$fdfcab1d</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class Computer$$EnhancerByCGLIB$$4ab32890$$FastClassByCGLIB$$fdfcab1d extends FastClass &#123;</span><br><span class="line">    public Computer$$EnhancerByCGLIB$$4ab32890$$FastClassByCGLIB$$fdfcab1d(Class var1) &#123;</span><br><span class="line">        super(var1);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 通过方法签名获取方法索引</span><br><span class="line">    public int getIndex(Signature var1) &#123;</span><br><span class="line">        String var10000 &#x3D; var1.toString();</span><br><span class="line">        switch(var10000.hashCode()) &#123;</span><br><span class="line">        case -1832866005:</span><br><span class="line">            if (var10000.equals(&quot;CGLIB$add$0(I)I&quot;)) &#123;</span><br><span class="line">                return 8;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case -1149925822:</span><br><span class="line">            if (var10000.equals(&quot;add(I)I&quot;)) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 通过方法名称和类创建方法索引</span><br><span class="line">    public int getIndex(String var1, Class[] var2) &#123;</span><br><span class="line">        switch(var1.hashCode()) &#123;</span><br><span class="line">        case 96417:</span><br><span class="line">            if (var1.equals(&quot;add&quot;)) &#123;</span><br><span class="line">                switch(var2.length) &#123;</span><br><span class="line">                case 1:</span><br><span class="line">                    if (var2[0].getName().equals(&quot;int&quot;)) &#123;</span><br><span class="line">                        return 0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case 1108311562:</span><br><span class="line">            if (var1.equals(&quot;CGLIB$add$0&quot;)) &#123;</span><br><span class="line">                switch(var2.length) &#123;</span><br><span class="line">                case 1:</span><br><span class="line">                    if (var2[0].getName().equals(&quot;int&quot;)) &#123;</span><br><span class="line">                        return 8;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 根据方法索引，调用对象，方法参数直接执行方法</span><br><span class="line">    public Object invoke(int var1, Object var2, Object[] var3) throws InvocationTargetException &#123;</span><br><span class="line">        4ab32890 var10000 &#x3D; (4ab32890)var2;</span><br><span class="line">        int var10001 &#x3D; var1;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            switch(var10001) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                return new Integer(var10000.add(((Number)var3[0]).intValue()));</span><br><span class="line">            case 8:</span><br><span class="line">                return new Integer(var10000.CGLIB$add$0(((Number)var3[0]).intValue()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable var4) &#123;</span><br><span class="line">            throw new InvocationTargetException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Cannot find matching method&#x2F;constructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>目标类的快速类和上面类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class Computer$$FastClassByCGLIB$$48de3884 extends FastClass &#123;</span><br><span class="line">    public Computer$$FastClassByCGLIB$$48de3884(Class var1) &#123;</span><br><span class="line">        super(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getIndex(Signature var1) &#123;</span><br><span class="line">        String var10000 &#x3D; var1.toString();</span><br><span class="line">        switch(var10000.hashCode()) &#123;</span><br><span class="line">        case -1149925822:</span><br><span class="line">            if (var10000.equals(&quot;add(I)I&quot;)) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getIndex(String var1, Class[] var2) &#123;</span><br><span class="line">        switch(var1.hashCode()) &#123;</span><br><span class="line">        case 96417:</span><br><span class="line">            if (var1.equals(&quot;add&quot;)) &#123;</span><br><span class="line">                switch(var2.length) &#123;</span><br><span class="line">                case 1:</span><br><span class="line">                    if (var2[0].getName().equals(&quot;int&quot;)) &#123;</span><br><span class="line">                        return 0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object invoke(int var1, Object var2, Object[] var3) throws InvocationTargetException &#123;</span><br><span class="line">        Computer var10000 &#x3D; (Computer)var2;</span><br><span class="line">        int var10001 &#x3D; var1;</span><br><span class="line">        try &#123;</span><br><span class="line">            switch(var10001) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                return new Integer(var10000.add(((Number)var3[0]).intValue()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable var4) &#123;</span><br><span class="line">            throw new InvocationTargetException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Cannot find matching method&#x2F;constructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过上面两个fastclass源码可以知道这个快速类提供类方法的index查询，同时可以通过invoke方法传入index来直接执行目标对象的方法。<br>我们再回到第5步执行<code>fci.f2.invoke(fci.i2, obj, args)</code>，f2就是生成的代理类的快速类Computer$$EnhancerByCGLIB$$4ab32890$$FastClassByCGLIB$$fdfcab1d，其中fci.i2就是在MethodProxy的init方法中调用快速类的getIndex(Signature var1)获取的方法索引，通过代理类的初始化方法可知intercept方法的参数methodProxy对象的i2就是CGLIB$add$0(I)I，索引为8，也就是最终调用的是代理对象的CGLIB$add$0方法而这个方法最终也是调用父类的add方法<code>super.add(var1);</code>也就是目标对象的add方法。</p>
<p><strong>调用步骤:</strong> 调用代理类的add方法-&gt;调用方法拦截器的intercept方法-&gt;调用代理方法的invokeSuper方法-&gt;调用代理类的快速类invoke方法-&gt;执行代理类的代理方法<code>CGLIB$add$0</code>-&gt;调用父类对应的add方法。</p>
<blockquote>
<p>通过jdk和cglib生成的代理对象的执行过程可知jdk最终是通过反射调用目标方法的，而cglib通过方法索引查询到方法并执行的。</p>
</blockquote>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/964fbc30151a">关于Java中的WeakReference</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44402359/article/details/95447277">为什么JDK动态代理中要求目标类实现的接口数量不能超过65535个</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zzg1229059735/article/details/78991200">你真的了解IdentityHashMap与HashMap区别吗？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liuyun1995/p/8144706.html">JDK动态代理[4]—-ProxyGenerator生成代理类的字节码文件解析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qiuhao9527/article/details/80775524">WeakHashMap的详细理解</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2019/08/02/VirtualBox%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/08/02/VirtualBox%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">VirtualBox网络设置实践</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-08-02 00:00:00" itemprop="dateCreated datePublished" datetime="2019-08-02T00:00:00+08:00">2019-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:03" itemprop="dateModified" datetime="2022-07-05T22:46:03+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">开发技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="VirtualBox网络设置实践"><a href="#VirtualBox网络设置实践" class="headerlink" title="VirtualBox网络设置实践"></a>VirtualBox网络设置实践</h2><blockquote>
<p>需求：使用virtualBox安装linux虚拟机做实验，需要linux可以访问外网（用来下载安装软件等），同时也需要和物理机互通，又要保证ip不变（不用每次ssh时候查看ip）。</p>
</blockquote>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ul>
<li>首先实现虚拟机可以访问外网，可以通过设置【桥接网卡】，物理机和虚拟机在同一个网络，具备物理机同样的网络连通性，但是当换办公场地时候ip会变。</li>
<li>为了实现ip不变，可以增加一个【仅主机(Host-Only)网络】，则物理机会创建个网络共享，多个虚拟机可以互联，将虚拟机设置为固定ip，ssh就不用更换ip。</li>
<li>设置虚拟机网卡配置，虚拟主机设为静态ip，桥接网卡设置为dhcp，两个网卡设为开机启动。<br>通过以上两个网卡来实现我们的需求，下面将介绍如何配置。<h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><h4 id="桥接网卡配置"><a href="#桥接网卡配置" class="headerlink" title="桥接网卡配置"></a>桥接网卡配置</h4>这个比较简单，直接设置》网络》桥接网卡 即可。<br><img src="https://gitee.com/mvilplss/note/raw/master/image/VirtualBox%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%E5%AE%9E%E8%B7%B5/%E6%A1%A5%E6%8E%A5%E7%BD%91%E5%8D%A1.png" alt="桥接网卡"><h4 id="仅主机-Host-Only-网络配置"><a href="#仅主机-Host-Only-网络配置" class="headerlink" title="仅主机(Host-Only)网络配置"></a>仅主机(Host-Only)网络配置</h4>添加主机共享网络<br><img src="https://gitee.com/mvilplss/note/raw/master/image/VirtualBox%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%E5%AE%9E%E8%B7%B5/%E6%B7%BB%E5%8A%A0%E4%B8%BB%E6%9C%BA%E7%BD%91%E7%BB%9C.png" alt="添加主机网络"><br>创建主机共享网络，使用默认的ip配置即可<br><img src="https://gitee.com/mvilplss/note/raw/master/image/VirtualBox%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%E5%AE%9E%E8%B7%B5/%E5%88%9B%E5%BB%BA%E4%B8%BB%E6%9C%BA%E7%BD%91%E7%BB%9C.png" alt="创建主机网络"><br>设置第二个网卡，选择配置好的主机共享网络<br><img src="https://gitee.com/mvilplss/note/raw/master/image/VirtualBox%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%E5%AE%9E%E8%B7%B5/%E8%AE%BE%E7%BD%AE%E7%AC%AC%E4%BA%8C%E4%B8%AA%E7%BD%91%E5%8D%A1.png" alt="设置第二个网卡"><h4 id="配置虚拟机网卡"><a href="#配置虚拟机网卡" class="headerlink" title="配置虚拟机网卡"></a>配置虚拟机网卡</h4>查看网卡：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@vworld network-scripts]# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1&#x2F;8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1&#x2F;128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link&#x2F;ether 08:00:27:37:8f:4f brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.31.250&#x2F;24 brd 192.168.31.255 scope global noprefixroute dynamic enp0s3</span><br><span class="line">       valid_lft 42995sec preferred_lft 42995sec</span><br><span class="line">    inet6 fe80::b32:2e09:3fd3:4406&#x2F;64 scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: enp0s8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link&#x2F;ether 08:00:27:f8:e6:2c brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.66.111&#x2F;24 brd 192.168.66.255 scope global noprefixroute enp0s8</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::d55:8ac4:5086:a899&#x2F;64 scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br></pre></td></tr></table></figure>
其中lo为默认网卡，enp0s3为【桥接网卡】，enp0s8为【共享网卡】。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@vworld network-scripts]#cd &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;</span><br><span class="line">[root@vworld network-scripts]#ls</span><br><span class="line">ifcfg-enp0s3  ifdown-ippp    ifdown-sit       ifup-bnep  ifup-plusb   ifup-TeamPort</span><br><span class="line">ifdown-ipv6    ifdown-Team      ifup-eth   ifup-post    ifup-tunnel</span><br><span class="line">ifcfg-lo      ifdown-isdn    ifdown-TeamPort  ifup-ippp  ifup-ppp     ifup-wireless</span><br><span class="line">ifdown        ifdown-post    ifdown-tunnel    ifup-ipv6  ifup-routes  init.ipv6-global</span><br><span class="line">ifdown-bnep   ifdown-ppp     ifup             ifup-isdn  ifup-sit     network-functions</span><br><span class="line">ifdown-eth    ifdown-routes  ifup-aliases     ifup-plip  ifup-Team    network-functions-ipv6</span><br></pre></td></tr></table></figure>
下面将共享网卡设置为固定IP，但是发现没有enp0s8网卡配置，我们就新增一个，同时配置固定IP。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@vworld network-scripts]# cp ifcfg-enp0s3 ifcfg-enp0s8</span><br><span class="line"># 配置共享网卡IP</span><br><span class="line">TYPE&#x3D;Ethernet</span><br><span class="line">PROXY_METHOD&#x3D;none</span><br><span class="line">BROWSER_ONLY&#x3D;no</span><br><span class="line">BOOTPROTO&#x3D;static # 静态IP</span><br><span class="line">DEFROUTE&#x3D;yes</span><br><span class="line">IPV4_FAILURE_FATAL&#x3D;no</span><br><span class="line">IPV6INIT&#x3D;yes</span><br><span class="line">IPV6_AUTOCONF&#x3D;yes</span><br><span class="line">IPV6_DEFROUTE&#x3D;yes</span><br><span class="line">IPV6_FAILURE_FATAL&#x3D;no</span><br><span class="line">IPV6_ADDR_GEN_MODE&#x3D;stable-privacy</span><br><span class="line">NAME&#x3D;enp0s8</span><br><span class="line">UUID&#x3D;6dc95768-5f00-4d6b-acad-041888e74386 # UUID为了不重复，可以随便修改下。</span><br><span class="line">DEVICE&#x3D;enp0s8 # 名称</span><br><span class="line">ONBOOT&#x3D;yes # 开机启动</span><br><span class="line"></span><br><span class="line"># 固定IP配置</span><br><span class="line">IPADDR&#x3D;192.168.66.111</span><br><span class="line">GATEWAY&#x3D;192.168.66.1</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>配置桥接网卡为开机启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">TYPE&#x3D;Ethernet</span><br><span class="line">PROXY_METHOD&#x3D;none</span><br><span class="line">BROWSER_ONLY&#x3D;no</span><br><span class="line">BOOTPROTO&#x3D;dhcp</span><br><span class="line">DEFROUTE&#x3D;yes</span><br><span class="line">IPV4_FAILURE_FATAL&#x3D;no</span><br><span class="line">IPV6INIT&#x3D;yes</span><br><span class="line">IPV6_AUTOCONF&#x3D;yes</span><br><span class="line">IPV6_DEFROUTE&#x3D;yes</span><br><span class="line">IPV6_FAILURE_FATAL&#x3D;no</span><br><span class="line">IPV6_ADDR_GEN_MODE&#x3D;stable-privacy</span><br><span class="line">NAME&#x3D;enp0s3</span><br><span class="line">UUID&#x3D;5dc95768-5f00-4d6b-acad-041888e74386</span><br><span class="line">DEVICE&#x3D;enp0s3</span><br><span class="line">ONBOOT&#x3D;yes # 开机启动</span><br></pre></td></tr></table></figure>
<p>重启后配置生效。</p>
<h2 id="MACOS下的设置"><a href="#MACOS下的设置" class="headerlink" title="MACOS下的设置"></a>MACOS下的设置</h2><p>MacOS下的设置和windows的设置稍微有点不同。</p>
<ol>
<li><p>网卡1<br><img src="https://gitee.com/mvilplss/note/raw/master/image/VirtualBox%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%E5%AE%9E%E8%B7%B5/img.png" alt="img.png"></p>
</li>
<li><p>网卡2<br><img src="https://gitee.com/mvilplss/note/raw/master/image/VirtualBox%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%E5%AE%9E%E8%B7%B5/img2.png" alt="img.png"></p>
</li>
</ol>
<p>修改配置：<br>cd /etc/sysconfig/network-scripts<br>ifcfg-enp0s3</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=enp0s3</span><br><span class="line">UUID=55748483-a791-4a5f-acac-2cc8db27f73b</span><br><span class="line">DEVICE=enp0s3</span><br><span class="line">ONBOOT=yes</span><br><span class="line">HWADDR=08:00:27:DB:F4:33</span><br><span class="line">MACADDR=08:00:27:DB:F4:33</span><br></pre></td></tr></table></figure>
<p>ifcfg-eth0</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HWADDR=08:00:27:2D:CB:B6</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=staic</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=&quot;eth0&quot;</span><br><span class="line">UUID=a4cf419a-5fc7-3b9e-8f9d-bb31cf459d22</span><br><span class="line">ONBOOT=yes</span><br><span class="line">AUTOCONNECT_PRIORITY=-999</span><br><span class="line"></span><br><span class="line">IPADDR=192.168.56.11</span><br><span class="line">GATEWAY=192.168.56.1</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e84c19effeea">https://www.jianshu.com/p/e84c19effeea</a><br>测试</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2019/07/02/JSON%E5%85%A5%E5%8F%82%E6%A0%BC%E5%BC%8F%E9%94%99%E8%AF%AF%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/07/02/JSON%E5%85%A5%E5%8F%82%E6%A0%BC%E5%BC%8F%E9%94%99%E8%AF%AF%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97/" class="post-title-link" itemprop="url">JSON入参格式错误打印日志</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-02 00:00:00" itemprop="dateCreated datePublished" datetime="2019-07-02T00:00:00+08:00">2019-07-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:03" itemprop="dateModified" datetime="2022-07-05T22:46:03+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/" itemprop="url" rel="index"><span itemprop="name">开发日常</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="JSON入参格式错误打印日志"><a href="#JSON入参格式错误打印日志" class="headerlink" title="JSON入参格式错误打印日志"></a>JSON入参格式错误打印日志</h2><p>最近接了个项目，其中涉及到一个很大的数据表单，系统是前后端分离的，在实际开发调试中老是出现前端传入JSON数据不能被后端正常解析，这种问题在调试期间是可以通过F12得到入参数据，然后对入参数据进行格式分析即可。<br>但是现在线上也偶尔会出现以下类似错误（当然这个可以看出来是json未正常结束，还有其他错误就不能直接用来排查问题）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ERROR | 42907 | http-nio-8051-exec-2 | com.mhc.framework.common.exception.handler.RestExceptionHandler | [RestExceptionHandler.java:46] | com.alibaba.fastjson.JSONException: not close json text, token : &#125;</span><br><span class="line">	at com.alibaba.fastjson.parser.DefaultJSONParser.close(DefaultJSONParser.java:1526)</span><br><span class="line">	at com.alibaba.fastjson.JSON.parseObject(JSON.java:387)</span><br><span class="line">	at com.alibaba.fastjson.JSON.parseObject(JSON.java:448)</span><br><span class="line">	at com.alibaba.fastjson.JSON.parseObject(JSON.java:556)</span><br><span class="line">	at com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter.readType(FastJsonHttpMessageConverter.java:263)</span><br><span class="line">	at com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter.read(FastJsonHttpMessageConverter.java:237)</span><br><span class="line">	at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver.readWithMessageConverters(AbstractMessageConverterMethodArgumentResolver.java:201)</span><br><span class="line">	at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.readWithMessageConverters(RequestResponseBodyMethodProcessor.java:150)</span><br><span class="line">	at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.resolveArgument(RequestResponseBodyMethodProcessor.java:128)</span><br><span class="line">	at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:121)</span><br><span class="line">	at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:158)</span><br><span class="line">	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:128)</span><br><span class="line">	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:97)</span><br><span class="line">	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:827)</span><br><span class="line">	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:738)</span><br><span class="line">	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85)</span><br><span class="line">	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:967)</span><br><span class="line">	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901)</span><br><span class="line">	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970)</span><br><span class="line">	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:872)</span><br></pre></td></tr></table></figure>

<p>此时把问题告诉前端，数据格式有问题，那么前端有很多数据要封装到一个JSON中，而且是偶然出现的，所以他会给你要入参的数据，而此时后台也没有记录，因此问题的解决收到的阻碍。<br>因此下面的内容就是要介绍如何在入参不能被正常解析时打印对应的日志。</p>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>本系统是SpringBoot项目，解析入参JSON数据用的是fastjson，通过配置增加了HttpMessageConverters转换器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public HttpMessageConverters fastJsonConfigure()&#123;</span><br><span class="line">	FastJsonHttpMessageConverter converter &#x3D; new FastJsonHttpMessageConverter();</span><br><span class="line">	FastJsonConfig fastJsonConfig &#x3D; new FastJsonConfig();</span><br><span class="line">	fastJsonConfig.setSerializerFeatures(SerializerFeature.WriteMapNullValue);</span><br><span class="line">	converter.setFastJsonConfig(fastJsonConfig);</span><br><span class="line">	converter.setSupportedMediaTypes(Arrays.asList(MediaType.APPLICATION_JSON_UTF8));</span><br><span class="line">	return new HttpMessageConverters(converter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而错误日志显示是其中这个类的这一行打印出来的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter.read(FastJsonHttpMessageConverter.java:237)</span><br></pre></td></tr></table></figure>
<p>此处源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Object read(Type type, &#x2F;&#x2F;</span><br><span class="line">                   Class&lt;?&gt; contextClass, &#x2F;&#x2F;</span><br><span class="line">                   HttpInputMessage inputMessage &#x2F;&#x2F;</span><br><span class="line">) throws IOException, HttpMessageNotReadableException &#123;</span><br><span class="line">    return readType(getType(type, contextClass), inputMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以考虑继承FastJsonHttpMessageConverter，然后对此方法进行增强：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class FastJsonHttpMessageConverterProxy extends FastJsonHttpMessageConverter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object read(Type type, Class&lt;?&gt; contextClass, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return super.read(type, contextClass, inputMessage);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            &#x2F;&#x2F; 解析入参异常时候，打印对应入参数据</span><br><span class="line">            log.error(&quot;request body json parse error :[&#123;&#125;]&quot;, IoUtil.read(inputMessage.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完工，跑一下看看，但是发现错误日志里面是没有任何数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR | 43188 | http-nio-8051-exec-2 | [FastJsonHttpMessageConverterProxy.java:28] | request body json parse error :[]</span><br></pre></td></tr></table></figure>
<p> 这是什么原因？原来inputMessage是从HttpServletRequest过来的，这里的输入流限制只能读一次，不能进行reset。因此我们就需要让这个inputMessage支持多次读取。继续对其增强：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class FastJsonHttpMessageConverterProxy extends FastJsonHttpMessageConverter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object read(Type type, Class&lt;?&gt; contextClass, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return super.read(type, contextClass, inputMessage);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(&quot;request body json parse error :[&#123;&#125;]&quot;, IoUtil.read(inputMessage.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 对入参消息体进行代理，使其支持可重复读</span><br><span class="line">     *&#x2F;</span><br><span class="line">    class HttpInputMessageProxy implements HttpInputMessage &#123;</span><br><span class="line">        private HttpHeaders headers;</span><br><span class="line">        private byte[] body;</span><br><span class="line">        public HttpInputMessageProxy(HttpInputMessage inputMessage) &#123;</span><br><span class="line">            this.headers &#x3D; inputMessage.getHeaders();</span><br><span class="line">            try &#123;</span><br><span class="line">                InputStream inputStream &#x3D; inputMessage.getBody();</span><br><span class="line">                body &#x3D; IoUtil.readBytes(inputStream);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                &#x2F;&#x2F;ignore</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public InputStream getBody() throws IOException &#123;</span><br><span class="line">            return new ByteArrayInputStream(body);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public HttpHeaders getHeaders() &#123;</span><br><span class="line">            return headers;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经测试在入参异常情况下打印出错误的入参数据。</p>
<h3 id="内容扩展"><a href="#内容扩展" class="headerlink" title="内容扩展"></a>内容扩展</h3><p>有些情况我们需要对入参进行解密操作，也需要提前读取入参，这样可以通过Spring的ControllerAdvice解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@ControllerAdvice</span><br><span class="line">public class AuthRequestBodyAdvice implements RequestBodyAdvice &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean supports(MethodParameter methodParameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object handleEmptyBody(Object body, HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123;</span><br><span class="line">        return body;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public HttpInputMessage beforeBodyRead(HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) throws IOException &#123;</span><br><span class="line">        HttpInputMessageProxy httpInputMessageProxy &#x3D; new HttpInputMessageProxy(inputMessage);</span><br><span class="line">        &#x2F;&#x2F; TODO 读取入参流，解密校验</span><br><span class="line">        return httpInputMessageProxy;</span><br><span class="line">    &#125;</span><br><span class="line">    class HttpInputMessageProxy implements HttpInputMessage &#123;</span><br><span class="line">        private HttpHeaders headers;</span><br><span class="line">        private byte[] body;</span><br><span class="line">        public HttpInputMessageProxy(HttpInputMessage inputMessage) &#123;</span><br><span class="line">            this.headers &#x3D; inputMessage.getHeaders();</span><br><span class="line">            try &#123;</span><br><span class="line">                InputStream inputStream &#x3D; inputMessage.getBody();</span><br><span class="line">                body &#x3D; IoUtil.readBytes(inputStream);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public InputStream getBody() throws IOException &#123;</span><br><span class="line">            return new ByteArrayInputStream(body);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public HttpHeaders getHeaders() &#123;</span><br><span class="line">            return headers;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object afterBodyRead(Object body, HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123;</span><br><span class="line">        return body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.52jingya.com/aid13401.html">https://www.52jingya.com/aid13401.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nickhan/p/9849693.html">https://www.cnblogs.com/nickhan/p/9849693.html</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">三行</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
