<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"mvilplss.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="一行知,二行理,三行本">
<meta property="og:type" content="website">
<meta property="og:title" content="三行">
<meta property="og:url" content="http://mvilplss.github.io/page/3/index.html">
<meta property="og:site_name" content="三行">
<meta property="og:description" content="一行知,二行理,三行本">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="三行">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://mvilplss.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>三行</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">三行</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">一行知,二行理,三行本</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">三行</p>
  <div class="site-description" itemprop="description">一行知,二行理,三行本</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2019/02/04/Spring%E4%BA%8B%E7%89%A9%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/04/Spring%E4%BA%8B%E7%89%A9%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/" class="post-title-link" itemprop="url">Spring事物深入研究</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-04 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-04T00:00:00+08:00">2019-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:27" itemprop="dateModified" datetime="2022-07-05T22:46:27+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">开发技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Spring事务是如何实现的"><a href="#Spring事务是如何实现的" class="headerlink" title="Spring事务是如何实现的"></a>Spring事务是如何实现的</h2><h3 id="事务类的增强"><a href="#事务类的增强" class="headerlink" title="事务类的增强"></a>事务类的增强</h3><p>Spring的事务是通对目标类生成增强后的代理类，然后自动在执行目标方法前开启事务，目标方法后关闭事务等。<br>下面是生成代理类的增强拦截器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class TransactionInterceptor extends TransactionAspectSupport implements MethodInterceptor, Serializable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    &#x2F;&#x2F;实现了MethodInterceptor的invoke方法</span><br><span class="line">    public Object invoke(final MethodInvocation invocation) throws Throwable &#123;</span><br><span class="line">        &#x2F;&#x2F;获取目标类</span><br><span class="line">　　　　 Class&lt;?&gt; targetClass &#x3D; (invocation.getThis() !&#x3D; null ? AopUtils.getTargetClass(invocation.getThis()) : null);</span><br><span class="line">　　　　 &#x2F;&#x2F;父类TransactionAspectSupport的模板方法</span><br><span class="line">        return invokeWithinTransaction(invocation.getMethod(), targetClass, new InvocationCallback() &#123;</span><br><span class="line">            @Override</span><br><span class="line">　　　　　　　&#x2F;&#x2F;InvocationCallback接口的回调方法</span><br><span class="line">            public Object proceedWithInvocation() throws Throwable &#123;</span><br><span class="line">　　　　　　　　　 &#x2F;&#x2F;执行目标方法</span><br><span class="line">                return invocation.proceed();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终执行的父类方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">public abstract class TransactionAspectSupport implements BeanFactoryAware, InitializingBean &#123;</span><br><span class="line">　　 &#x2F;&#x2F;protected修饰，不允许其他包和无关类调用</span><br><span class="line">    protected Object invokeWithinTransaction(Method method, Class&lt;?&gt; targetClass, final InvocationCallback invocation) throws Throwable &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取对应事务属性.如果事务属性为空（则目标方法不存在事务）</span><br><span class="line">        final TransactionAttribute txAttr &#x3D; getTransactionAttributeSource().getTransactionAttribute(method, targetClass);</span><br><span class="line">　　　　 &#x2F;&#x2F; 根据事务的属性获取beanFactory中的PlatformTransactionManager(spring事务管理器的顶级接口)，一般这里或者的是DataSourceTransactiuonManager</span><br><span class="line">        final PlatformTransactionManager tm &#x3D; determineTransactionManager(txAttr);</span><br><span class="line"> 　　　　&#x2F;&#x2F; 目标方法唯一标识（类.方法，如service.UserServiceImpl.save）</span><br><span class="line">        final String joinpointIdentification &#x3D; methodIdentification(method, targetClass);</span><br><span class="line">　　　　 &#x2F;&#x2F;如果txAttr为空或者tm 属于非CallbackPreferringPlatformTransactionManager，执行目标增强     ①</span><br><span class="line">        if (txAttr &#x3D;&#x3D; null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">            &#x2F;&#x2F;看是否有必要创建一个事务，根据事务传播行为，做出相应的判断</span><br><span class="line">            TransactionInfo txInfo &#x3D; createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">            Object retVal &#x3D; null;</span><br><span class="line">            try &#123;</span><br><span class="line">　　　　　　　　　 &#x2F;&#x2F;回调方法执行，执行目标方法（原有的业务逻辑）</span><br><span class="line">                retVal &#x3D; invocation.proceedWithInvocation();</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Throwable ex) &#123;</span><br><span class="line">                &#x2F;&#x2F; 异常回滚</span><br><span class="line">                completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125;</span><br><span class="line">            finally &#123;</span><br><span class="line">　　　　　　　　　 &#x2F;&#x2F;清除信息</span><br><span class="line">                cleanupTransactionInfo(txInfo);</span><br><span class="line">            &#125;</span><br><span class="line">　　　　　　  &#x2F;&#x2F;提交事务</span><br><span class="line">            commitTransactionAfterReturning(txInfo);</span><br><span class="line">            return retVal;</span><br><span class="line">        &#125;</span><br><span class="line">　　　　 &#x2F;&#x2F;编程式事务处理(CallbackPreferringPlatformTransactionManager) 不做重点分析</span><br><span class="line">        else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Object result &#x3D; ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr,</span><br><span class="line">                        new TransactionCallback&lt;Object&gt;() &#123;</span><br><span class="line">                            @Override</span><br><span class="line">                            public Object doInTransaction(TransactionStatus status) &#123;</span><br><span class="line">                                TransactionInfo txInfo &#x3D; prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">                                try &#123;</span><br><span class="line">                                    return invocation.proceedWithInvocation();</span><br><span class="line">                                &#125;</span><br><span class="line">                                catch (Throwable ex) &#123;</span><br><span class="line">                                    if (txAttr.rollbackOn(ex)) &#123;</span><br><span class="line">                                        &#x2F;&#x2F; A RuntimeException: will lead to a rollback.</span><br><span class="line">                                        if (ex instanceof RuntimeException) &#123;</span><br><span class="line">                                            throw (RuntimeException) ex;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        else &#123;</span><br><span class="line">                                            throw new ThrowableHolderException(ex);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    else &#123;</span><br><span class="line">                                        &#x2F;&#x2F; A normal return value: will lead to a commit.</span><br><span class="line">                                        return new ThrowableHolder(ex);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                finally &#123;</span><br><span class="line">                                    cleanupTransactionInfo(txInfo);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; Check result: It might indicate a Throwable to rethrow.</span><br><span class="line">                if (result instanceof ThrowableHolder) &#123;</span><br><span class="line">                    throw ((ThrowableHolder) result).getThrowable();</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    return result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (ThrowableHolderException ex) &#123;</span><br><span class="line">                throw ex.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行流程为：<br>当我们调用Service的事务方法时候，其实是调用的Service的增强后的代理类，然后调用TransactionInterceptor的invoke方法，最终执行了TransactionAspectSupport.invokeWithinTransaction方法。</p>
<h2 id="事务的核心接口"><a href="#事务的核心接口" class="headerlink" title="事务的核心接口"></a>事务的核心接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 事务的各种属性定义</span><br><span class="line">public interface TransactionDefinition &#123;</span><br><span class="line">    int PROPAGATION_REQUIRED &#x3D; 0;</span><br><span class="line">    int PROPAGATION_SUPPORTS &#x3D; 1;</span><br><span class="line">    int PROPAGATION_MANDATORY &#x3D; 2;</span><br><span class="line">    int PROPAGATION_REQUIRES_NEW &#x3D; 3;</span><br><span class="line">    int PROPAGATION_NOT_SUPPORTED &#x3D; 4;</span><br><span class="line">    int PROPAGATION_NEVER &#x3D; 5;</span><br><span class="line">    int PROPAGATION_NESTED &#x3D; 5;</span><br><span class="line">    int ISOLATION_DEFAULT &#x3D; -1;</span><br><span class="line">    </span><br><span class="line">    int ISOLATION_READ_UNCOMMITTED &#x3D; Connection.TRANSACTION_READ_UNCOMMITTED;</span><br><span class="line">    int ISOLATION_READ_COMMITTED &#x3D; Connection.TRANSACTION_READ_COMMITTED;</span><br><span class="line">    int ISOLATION_REPEATABLE_READ &#x3D; Connection.TRANSACTION_REPEATABLE_READ;</span><br><span class="line">    int ISOLATION_SERIALIZABLE &#x3D; Connection.TRANSACTION_SERIALIZABLE;</span><br><span class="line">    int TIMEOUT_DEFAULT &#x3D; -1;</span><br><span class="line">    </span><br><span class="line">    int getPropagationBehavior();</span><br><span class="line">    int getIsolationLevel();</span><br><span class="line">    int getTimeout();</span><br><span class="line">    boolean isReadOnly();</span><br><span class="line">    String getName();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 事务的状态</span><br><span class="line">public interface TransactionStatus extends SavepointManager, Flushable &#123;</span><br><span class="line">    boolean isNewTransaction();</span><br><span class="line">    boolean hasSavepoint();</span><br><span class="line">    void setRollbackOnly();</span><br><span class="line">    boolean isRollbackOnly();</span><br><span class="line">    void flush();</span><br><span class="line">    boolean isCompleted();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 事务的获取，提交和回滚</span><br><span class="line">public interface PlatformTransactionManager &#123;</span><br><span class="line">    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;</span><br><span class="line">    void commit(TransactionStatus status) throws TransactionException;</span><br><span class="line">    void rollback(TransactionStatus status) throws TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应关系如下图所示：<br><img src="https://gitee.com/mvilplss/note/raw/master/image/%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3.jpg" alt="事务相关接口.jpg"></p>
<h2 id="Spring事务的隔离级别"><a href="#Spring事务的隔离级别" class="headerlink" title="Spring事务的隔离级别"></a>Spring事务的隔离级别</h2><table>
<thead>
<tr>
<th>隔离级别</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ISOLATION_DEFAULT</td>
<td>-1</td>
<td>这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与JDBC的隔离级别相对应</td>
</tr>
<tr>
<td>ISOLATION_READ_UNCOMMITTED</td>
<td>1</td>
<td>这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻读。</td>
</tr>
<tr>
<td>ISOLATION_READ_COMMITTED</td>
<td>2</td>
<td>保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。</td>
</tr>
<tr>
<td>ISOLATION_REPEATABLE_READ</td>
<td>4</td>
<td>这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻读。</td>
</tr>
<tr>
<td>ISOLATION_SERIALIZABLE</td>
<td>8</td>
<td>这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻读。</td>
</tr>
</tbody></table>
<h2 id="什么是事务传播"><a href="#什么是事务传播" class="headerlink" title="什么是事务传播"></a>什么是事务传播</h2><p>事务传播就是多级事务方法（可以是同一个方法）调用时，事务方法是如何管理事务的行为。例如：A事务方法调用B事务方法，B事务方法是沿用A的事务还是新开一个事务或不用事务，这个是由事务的传播行为决定的。</p>
<h3 id="Spring的7个事务传播行为"><a href="#Spring的7个事务传播行为" class="headerlink" title="Spring的7个事务传播行为"></a>Spring的7个事务传播行为</h3><table>
<thead>
<tr>
<th>传播行为</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>PROPAGATION_REQUIRED</td>
<td>支持当前事务，如果不存在则创建一个事务。</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS</td>
<td>如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。</td>
</tr>
<tr>
<td>PROPAGATION_MANDATORY</td>
<td>如果存在一个事务，支持当前事务。如果没有事务，则抛出异常IllegalTransactionStateException。</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRES_NEW</td>
<td>创建一个新的事务，如果当前已经存在事务则进行挂起。</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED</td>
<td>不支持事务，如果当前已经存在事务则进行挂起。</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td>不支持事务，如果当前已经存在事务则抛出异常IllegalTransactionStateException。</td>
</tr>
<tr>
<td>PROPAGATION_NESTED</td>
<td>如果当前事务存在，则在嵌套事务中执行，嵌套事务支持事务提交和回滚；如果当前事务不存在则类似PROPAGATION_REQUIRED。</td>
</tr>
</tbody></table>
<h4 id="PROPAGATION-REQUIRED"><a href="#PROPAGATION-REQUIRED" class="headerlink" title="PROPAGATION_REQUIRED"></a>PROPAGATION_REQUIRED</h4><p>如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">public void methodA()&#123;</span><br><span class="line">    self.methodB();</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">public void methodB()&#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当单独执行方法B时，发现不存在事务则会打开一个事务；如果单独执行方法A时，发现不存在事务则开启一个事务，然后内部调用方法B时，由于传播行为PROPAGATION_REQUIRED，因此会使用当前事务。</p>
<h4 id="PROPAGATION-SUPPORTS"><a href="#PROPAGATION-SUPPORTS" class="headerlink" title="PROPAGATION_SUPPORTS"></a>PROPAGATION_SUPPORTS</h4><p>如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">public void methodA()&#123;</span><br><span class="line">    self.methodB();</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Transactional(propagation &#x3D; Propagation.PROPAGATION_SUPPORTS)</span><br><span class="line">public void methodB()&#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单独调用方法B时，根据当前事务传播行为B将不使用事务执行；当调用方法A时，开启事务，内部调用B时，B使用A的事务。</p>
<h4 id="PROPAGATION-MANDATORY"><a href="#PROPAGATION-MANDATORY" class="headerlink" title="PROPAGATION_MANDATORY"></a>PROPAGATION_MANDATORY</h4><p>如果存在一个事务，支持当前事务。如果没有事务，则抛出事务不存在异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">public void methodA()&#123;</span><br><span class="line">    self.methodB();</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Transactional(propagation &#x3D; Propagation.PROPAGATION_MANDATORY)</span><br><span class="line">public void methodB()&#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单独调用方法B时，由于B未在事务中执行，则抛出异常(<code>IllegalTransactionStateException: No existing transaction found for transaction marked with propagation &#39;mandatory&#39;</code>)；当调用方法A时，开启事务，内部调用B时，B使用A的事务。</p>
<h4 id="PROPAGATION-REQUIRES-NEW"><a href="#PROPAGATION-REQUIRES-NEW" class="headerlink" title="PROPAGATION_REQUIRES_NEW"></a>PROPAGATION_REQUIRES_NEW</h4><p>创建一个新的事务，如果当前已经存在事务则进行挂起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">public void methodA()&#123;</span><br><span class="line">    self.methodB();</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Transactional(propagation &#x3D; Propagation.PROPAGATION_REQUIRES_NEW)</span><br><span class="line">public void methodB()&#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论是单独调用方法B还是通过方法A内部调用B都会挂起已存在的事务，然后创建一个新的事务执行。</p>
<h4 id="PROPAGATION-NOT-SUPPORTED"><a href="#PROPAGATION-NOT-SUPPORTED" class="headerlink" title="PROPAGATION_NOT_SUPPORTED"></a>PROPAGATION_NOT_SUPPORTED</h4><p>不支持事务，如果当前已经存在事务则进行挂起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">public void methodA()&#123;</span><br><span class="line">    self.methodB();</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Transactional(propagation &#x3D; Propagation.PROPAGATION_NOT_SUPPORTED)</span><br><span class="line">public void methodB()&#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论是单独调用方法B还是通过方法A内部调用B都会挂起已经存在的事务，然后以非事务执行。</p>
<h4 id="PROPAGATION-NEVER"><a href="#PROPAGATION-NEVER" class="headerlink" title="PROPAGATION_NEVER"></a>PROPAGATION_NEVER</h4><p>不支持事务，如果当前已经存在事务则抛出异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">public void methodA()&#123;</span><br><span class="line">    self.methodB();</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Transactional(propagation &#x3D; Propagation.PROPAGATION_NEVER)</span><br><span class="line">public void methodB()&#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论是单独调用方法B还是通过方法A内部调用B，如果存在事务，则抛出异常(<code>IllegalTransactionStateException: Existing transaction found for transaction marked with propagation &#39;never&#39;</code>‘)。</p>
<h4 id="PROPAGATION-NESTED"><a href="#PROPAGATION-NESTED" class="headerlink" title="PROPAGATION_NESTED"></a>PROPAGATION_NESTED</h4><p>如果当前事务存在，则在嵌套事务中执行，嵌套事务支持事务提交和回滚；如果当前事务不存在则类似PROPAGATION_REQUIRED。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">public void methodA()&#123;</span><br><span class="line">    self.methodB();</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Transactional(propagation &#x3D; Propagation.PROPAGATION_NESTED)</span><br><span class="line">public void methodB()&#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个活动的事务存在，则运行在一个嵌套的事务中。 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行。</p>
<h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><h3 id="PROPAGATION-NESTED和PROPAGATION-REQUIRES-NE区别"><a href="#PROPAGATION-NESTED和PROPAGATION-REQUIRES-NE区别" class="headerlink" title="PROPAGATION_NESTED和PROPAGATION_REQUIRES_NE区别"></a>PROPAGATION_NESTED和PROPAGATION_REQUIRES_NE区别</h3><p>它们非常类似,都像一个嵌套事务，如果不存在一个活动的事务，都会开启一个新的事务。<br>使用 PROPAGATION_REQUIRES_NEW时，内层事务与外层事务就像两个独立的事务一样，一旦内层事务进行了提交后，外层事务不能对其进行回滚。两个事务互不影响。两个事务不是一个真正的嵌套事务。同时它需要JTA事务管理器的支持。<br>使用PROPAGATION_NESTED时，外层事务的回滚可以引起内层事务的回滚。而内层事务的异常并不会导致外层事务的回滚，它是一个真正的嵌套事务。DataSourceTransactionManager使用savepoint支持PROPAGATION_NESTED时，需要JDBC 3.0以上驱动及1.4以上的JDK版本支持。其它的JTATrasactionManager实现可能有不同的支持方式。</p>
<h3 id="嵌套调用时候，事务传播行为未生效"><a href="#嵌套调用时候，事务传播行为未生效" class="headerlink" title="嵌套调用时候，事务传播行为未生效"></a>嵌套调用时候，事务传播行为未生效</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">public void methodA()&#123;</span><br><span class="line">    methodB();&#x2F;&#x2F; 直接调用</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Transactional(propagation &#x3D; Propagation.PROPAGATION_SUPPORTS)</span><br><span class="line">public void methodB()&#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面代码，当methodA调用methodB时候，methodB理论上应该在methodA开启的事务中执行，但是现实是methodB并未开启事务，这是什么原因呢？<br>我们知道Spring的事务管理是通过AOP对Service对象进行增强实现的，因此我们从bean工厂中获取到的Service为增强过的类，当我们直接调用时会直接调用增强的方法，然后在调用目标方。<br>如图：<br><img src="https://gitee.com/mvilplss/note/raw/master/image/%E5%86%85%E9%83%A8%E8%B0%83%E7%94%A8%E6%9C%AA%E5%A2%9E%E5%BC%BA.jpg" alt="内部调用未增强.jpg"><br>红色调用部分<code>this.methodA</code>则是目标类自己调用自己，因此是未经过增强的方法，不会按照Spring的事务传播行为执行的。</p>
<h3 id="Transaction-rolled-back-because-it-has-been-marked-as-rollback-only"><a href="#Transaction-rolled-back-because-it-has-been-marked-as-rollback-only" class="headerlink" title="Transaction rolled back because it has been marked as rollback-only"></a>Transaction rolled back because it has been marked as rollback-only</h3><p>这篇文章之所以会写出来，主要是在维护老系统时候，发现了下面一个错误.<br>首先看下这段代码有什么问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRED)</span><br><span class="line">public void methodA()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        methodB();&#x2F;&#x2F; 直接调用</span><br><span class="line">        &#x2F;&#x2F; do something</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            log.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRED,rollbackFor &#x3D; Exception.class)</span><br><span class="line">public void methodB()&#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">    i &#x3D; 1&#x2F;0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们调用methodA时，内嵌调用methodB，methodB执行时候发生异常，将事务标记为rollback-only=true，然后异常被methodA捕获，并打印出异常栈（其实并没有打印出1/0的异常）。<br>异常竟然是UnexpectedRollbackException异常，这是为什么呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only</span><br></pre></td></tr></table></figure>
<p>原因是methodB设置了rollbackFor = Exception.class，异常后将当前事务设置为了rollback-only，因此当methodA调用methodB完成后将异常catch后进行了提交事务操作，因此就出现UnexpectedRollbackException异常。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2019/01/04/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/04/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Mybatis源码分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-04 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-04T00:00:00+08:00">2019-01-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:27" itemprop="dateModified" datetime="2022-07-05T22:46:27+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">开发技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>本文通过通过jdbc到mybatis查询数据库代码来分析mybatis的优势，同时进一步分析mybatis的源码，分析mybatis的整体架构设计，最后再对mybatis的缓存进行剖析。</p>
<h1 id="JDBC与mybatis"><a href="#JDBC与mybatis" class="headerlink" title="JDBC与mybatis"></a>JDBC与mybatis</h1><p>下面介绍jdbc和mybatis操作数据库的方式。</p>
<h2 id="jdbc访问数据库"><a href="#jdbc访问数据库" class="headerlink" title="jdbc访问数据库"></a>jdbc访问数据库</h2><p>通过jdbc直接操作数据库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void jdbcTest() throws Exception&#123;</span><br><span class="line">    &#x2F;&#x2F; 1.获取链接</span><br><span class="line">    Connection connection &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test_db&quot;, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line">    &#x2F;&#x2F; 2.准备会话</span><br><span class="line">    PreparedStatement statement &#x3D; connection.prepareStatement(&quot;select * from tb_user&quot;);</span><br><span class="line">    &#x2F;&#x2F; 3.执行查询</span><br><span class="line">    statement.execute();</span><br><span class="line">    &#x2F;&#x2F; 4.获取查询结果</span><br><span class="line">    ResultSet resultSet &#x3D; statement.getResultSet();</span><br><span class="line">    &#x2F;&#x2F; 5.封装结果到对象中</span><br><span class="line">    List&lt;User&gt; users &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    while (resultSet.next())&#123;</span><br><span class="line">        Object id &#x3D; resultSet.getObject(&quot;id&quot;);</span><br><span class="line">        Object name &#x3D; resultSet.getObject(&quot;name&quot;);</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        user.setId(Long.valueOf(id.toString()));</span><br><span class="line">        user.setName(name.toString());</span><br><span class="line">        users.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(users);</span><br><span class="line">    &#x2F;&#x2F; 6.关闭相关资源</span><br><span class="line">    resultSet.close();</span><br><span class="line">    statement.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过实例可以看出，jdbc对数据库的操作有多处可以改进：</p>
<ol>
<li>获取链接可以交给数据库连接池来实现，不用每次都打开一个链接。</li>
<li>准备会话的sql可以放置到配置文件中，实现统一管理。</li>
<li>获取查询结果时可以增加结果处理器来实现返回结果自动封装到对象中。</li>
<li>查询的结果可以放到缓存中，提高查询效率。</li>
<li>关闭资源可以交给动态代理来实现自动关闭。</li>
</ol>
<h2 id="mybatis访问数据"><a href="#mybatis访问数据" class="headerlink" title="mybatis访问数据"></a>mybatis访问数据</h2><p>创建一个maven工程，然后加入mybaits依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;x.x.x&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="增加mybatis的配置项"><a href="#增加mybatis的配置项" class="headerlink" title="增加mybatis的配置项"></a>增加mybatis的配置项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">  PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">  &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;environments default&#x3D;&quot;development&quot;&gt;</span><br><span class="line">    &lt;environment id&#x3D;&quot;development&quot;&gt;</span><br><span class="line">      &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;</span><br><span class="line">      &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;dataSource&gt;</span><br><span class="line">    &lt;&#x2F;environment&gt;</span><br><span class="line">  &lt;&#x2F;environments&gt;</span><br><span class="line">  &lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource&#x3D;&quot;org&#x2F;mybatis&#x2F;example&#x2F;BlogMapper.xml&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;mappers&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<p>通过配置可以管理数据库的链接配置，数据源的配置，同时还支持插件开发和配置。</p>
<h3 id="增加Mapper接口类"><a href="#增加Mapper接口类" class="headerlink" title="增加Mapper接口类"></a>增加Mapper接口类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserMapper &#123;</span><br><span class="line">    List&lt;User&gt; selectAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过编写接口来关联查询的具体语句，实现面向对象开发。</p>
<h3 id="增加对应Mapper-xml配置"><a href="#增加对应Mapper-xml配置" class="headerlink" title="增加对应Mapper.xml配置"></a>增加对应Mapper.xml配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.mybatis.demo.UserMapper&quot;&gt;</span><br><span class="line">    &lt;resultMap id&#x3D;&quot;BaseResultMap&quot; type&#x3D;&quot;com.mybatis.demo.User&quot;&gt;</span><br><span class="line">        &lt;result column&#x3D;&quot;id&quot; property&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result column&#x3D;&quot;name&quot; property&#x3D;&quot;name&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;resultMap&gt;</span><br><span class="line">    &lt;select id&#x3D;&quot;selectAll&quot; resultMap&#x3D;&quot;BaseResultMap&quot;&gt;</span><br><span class="line">    select * from tb_user where id &#x3D; #&#123;id&#125;</span><br><span class="line">  &lt;&#x2F;select&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>
<p>配置读经的Mapper.xml，将sql放到配置文件中。同时可以配置查询是否开启缓存等可以参考官方文档。</p>
<h3 id="编写测试代码："><a href="#编写测试代码：" class="headerlink" title="编写测试代码："></a>编写测试代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void mybatisTest() throws Exception&#123;</span><br><span class="line">    InputStream inputStream &#x3D; Resources.getResourceAsStream(&quot;mybatis&#x2F;mybatis-config.xml&quot;);</span><br><span class="line">    DefaultSqlSessionFactory sqlSessionFactory &#x3D; (DefaultSqlSessionFactory) new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    SqlSession sqlSession &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">    UserMapper userMapper &#x3D; sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    System.out.println(userMapper.selectAll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">54:48:375|DEBUG|main|137|Opening JDBC Connection</span><br><span class="line">54:49:888|DEBUG|main|406|Created connection 1474957626.</span><br><span class="line">54:49:889|DEBUG|main|101|Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@57ea113a]</span><br><span class="line">54:49:892|DEBUG|main|159|&#x3D;&#x3D;&gt;  Preparing: select * from tb_user </span><br><span class="line">54:49:958|DEBUG|main|159|&#x3D;&#x3D;&gt; Parameters: </span><br><span class="line">54:49:997|DEBUG|main|159|&lt;&#x3D;&#x3D;      Total: 3</span><br><span class="line">[User(id&#x3D;1, name&#x3D;a), User(id&#x3D;2, name&#x3D;b), User(id&#x3D;3, name&#x3D;c)]</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>mybtis的优点：</p>
<ul>
<li>数据库连接可以通过配置指定的数据源来管理</li>
<li>sql语句与代码分离，存放于xml配置文件中</li>
<li>通过映射实现通过接口直接调用方法来操作数据库</li>
<li>增加缓存，提高数据的查询效率</li>
<li>自动封装数据查询结果</li>
</ul>
<h1 id="mybatis源码分析"><a href="#mybatis源码分析" class="headerlink" title="mybatis源码分析"></a>mybatis源码分析</h1><p>通过上面mybatis的例子，我们来进一步分析下对应的源码。</p>
<h2 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F; 根据指定类加载器》默认类加载器》当前线程类加载器》系统类加载器 顺序创建一个类加载器数组</span><br><span class="line"> ClassLoader[] getClassLoaders(ClassLoader classLoader) &#123;</span><br><span class="line">   return new ClassLoader[]&#123;</span><br><span class="line">       classLoader,</span><br><span class="line">       defaultClassLoader,</span><br><span class="line">       Thread.currentThread().getContextClassLoader(),</span><br><span class="line">       getClass().getClassLoader(),</span><br><span class="line">       systemClassLoader&#125;;</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F; 循环类加载器，如果获取到配置内容则返回</span><br><span class="line">InputStream getResourceAsStream(String resource, ClassLoader[] classLoader) &#123;</span><br><span class="line">   for (ClassLoader cl : classLoader) &#123;</span><br><span class="line">     if (null !&#x3D; cl) &#123;</span><br><span class="line">       &#x2F;&#x2F; try to find the resource as passed</span><br><span class="line">       InputStream returnValue &#x3D; cl.getResourceAsStream(resource);</span><br><span class="line">  </span><br><span class="line">       &#x2F;&#x2F; now, some class loaders want this leading &quot;&#x2F;&quot;, so we&#39;ll add it and try again if we didn&#39;t find the resource</span><br><span class="line">       if (null &#x3D;&#x3D; returnValue) &#123;</span><br><span class="line">         returnValue &#x3D; cl.getResourceAsStream(&quot;&#x2F;&quot; + resource);</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line">       if (null !&#x3D; returnValue) &#123;</span><br><span class="line">         return returnValue;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return null;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>通过Resources.getResourceAsStream读取配置的最终原理由classload来加载文件流。</p>
<h2 id="创建DefaultSqlSessionFactory工厂对象"><a href="#创建DefaultSqlSessionFactory工厂对象" class="headerlink" title="创建DefaultSqlSessionFactory工厂对象"></a>创建DefaultSqlSessionFactory工厂对象</h2><p>org.apache.ibatis.session.SqlSessionFactoryBuilder#build方法来构建SqlSessionFactory对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    XMLConfigBuilder parser &#x3D; new XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">    return build(parser.parse());</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">    try &#123;</span><br><span class="line">      inputStream.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      &#x2F;&#x2F; Intentionally ignore. Prefer previous error.</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构建new XMLConfigBuilder()对象时候,将文件流解析为Document</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过JDK的javax.xml.parsers解析配置为Document</span><br><span class="line">private Document createDocument(InputSource inputSource) &#123;</span><br><span class="line">    &#x2F;&#x2F; important: this must only be called AFTER common constructor</span><br><span class="line">    try &#123;</span><br><span class="line">      DocumentBuilderFactory factory &#x3D; DocumentBuilderFactory.newInstance();</span><br><span class="line">      factory.setValidating(validation);</span><br><span class="line"></span><br><span class="line">      factory.setNamespaceAware(false);</span><br><span class="line">      factory.setIgnoringComments(true);</span><br><span class="line">      factory.setIgnoringElementContentWhitespace(false);</span><br><span class="line">      factory.setCoalescing(false);</span><br><span class="line">      factory.setExpandEntityReferences(true);</span><br><span class="line"></span><br><span class="line">      DocumentBuilder builder &#x3D; factory.newDocumentBuilder();</span><br><span class="line">      builder.setEntityResolver(entityResolver);</span><br><span class="line">      builder.setErrorHandler(new ErrorHandler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void error(SAXParseException exception) throws SAXException &#123;</span><br><span class="line">          throw exception;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void fatalError(SAXParseException exception) throws SAXException &#123;</span><br><span class="line">          throw exception;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void warning(SAXParseException exception) throws SAXException &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      return builder.parse(inputSource);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BuilderException(&quot;Error creating document instance.  Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>构建SqlSessionFactory对象前，需要通过org.apache.ibatis.builder.xml.XMLConfigBuilder#parse解析配置到Configuration中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将配置读取到Configuration中</span><br><span class="line">public Configuration parse() &#123;</span><br><span class="line">  if (parsed) &#123;</span><br><span class="line">    throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  parsed &#x3D; true;</span><br><span class="line">  parseConfiguration(parser.evalNode(&quot;&#x2F;configuration&quot;));</span><br><span class="line">  return configuration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; XMLConfigBuilder 解析每个配置元素到Configuration中</span><br><span class="line">  private void parseConfiguration(XNode root) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F;issue #117 read properties first</span><br><span class="line">      propertiesElement(root.evalNode(&quot;properties&quot;));</span><br><span class="line">      Properties settings &#x3D; settingsAsProperties(root.evalNode(&quot;settings&quot;));</span><br><span class="line">      loadCustomVfs(settings);</span><br><span class="line">      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));</span><br><span class="line">      pluginElement(root.evalNode(&quot;plugins&quot;));&#x2F;&#x2F; 解析并配置拦截器</span><br><span class="line">      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));</span><br><span class="line">      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));</span><br><span class="line">      reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));</span><br><span class="line">      settingsElement(settings);</span><br><span class="line">      &#x2F;&#x2F; read it after objectFactory and objectWrapperFactory issue #631</span><br><span class="line">      environmentsElement(root.evalNode(&quot;environments&quot;));</span><br><span class="line">      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));</span><br><span class="line">      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));</span><br><span class="line">      mapperElement(root.evalNode(&quot;mappers&quot;));&#x2F;&#x2F; mapper元素解析(重点)</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>mapper元素解析，根据mapper的配置（resouce,url,class)来使用不同的读取方式获取到mapper文件，使用XMLMapperBuilder解析或者直接获取class加入到configurution中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; org.apache.ibatis.builder.xml.XMLConfigBuilder#mapperElement</span><br><span class="line">&#x2F;&#x2F; mapper元素解析，包括resource,url(支持远程）,class</span><br><span class="line">private void mapperElement(XNode parent) throws Exception &#123;</span><br><span class="line">  if (parent !&#x3D; null) &#123;</span><br><span class="line">    for (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      if (&quot;package&quot;.equals(child.getName())) &#123;</span><br><span class="line">        String mapperPackage &#x3D; child.getStringAttribute(&quot;name&quot;);</span><br><span class="line">        configuration.addMappers(mapperPackage);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        String resource &#x3D; child.getStringAttribute(&quot;resource&quot;);</span><br><span class="line">        String url &#x3D; child.getStringAttribute(&quot;url&quot;);</span><br><span class="line">        String mapperClass &#x3D; child.getStringAttribute(&quot;class&quot;);</span><br><span class="line">        if (resource !&#x3D; null &amp;&amp; url &#x3D;&#x3D; null &amp;&amp; mapperClass &#x3D;&#x3D; null) &#123;</span><br><span class="line">          ErrorContext.instance().resource(resource);</span><br><span class="line">          InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">          XMLMapperBuilder mapperParser &#x3D; new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; else if (resource &#x3D;&#x3D; null &amp;&amp; url !&#x3D; null &amp;&amp; mapperClass &#x3D;&#x3D; null) &#123;</span><br><span class="line">          ErrorContext.instance().resource(url);</span><br><span class="line">          InputStream inputStream &#x3D; Resources.getUrlAsStream(url);</span><br><span class="line">          XMLMapperBuilder mapperParser &#x3D; new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; else if (resource &#x3D;&#x3D; null &amp;&amp; url &#x3D;&#x3D; null &amp;&amp; mapperClass !&#x3D; null) &#123;</span><br><span class="line">          Class&lt;?&gt; mapperInterface &#x3D; Resources.classForName(mapperClass);</span><br><span class="line">          configuration.addMapper(mapperInterface);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          throw new BuilderException(&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; org.apache.ibatis.binding.MapperRegistry#addMapper 增加Mapper到knownMappers中，同时创建对应的MapperProxyFactory代理工厂类。</span><br><span class="line">public &lt;T&gt; void addMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">  if (type.isInterface()) &#123;</span><br><span class="line">    if (hasMapper(type)) &#123;</span><br><span class="line">      throw new BindingException(&quot;Type &quot; + type + &quot; is already known to the MapperRegistry.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    boolean loadCompleted &#x3D; false;</span><br><span class="line">    try &#123;</span><br><span class="line">      knownMappers.put(type, new MapperProxyFactory&lt;T&gt;(type));</span><br><span class="line">      &#x2F;&#x2F; It&#39;s important that the type is added before the parser is run</span><br><span class="line">      &#x2F;&#x2F; otherwise the binding may automatically be attempted by the</span><br><span class="line">      &#x2F;&#x2F; mapper parser. If the type is already known, it won&#39;t try.</span><br><span class="line">      &#x2F;&#x2F; 解析通过注解实现的sql映射。</span><br><span class="line">      MapperAnnotationBuilder parser &#x3D; new MapperAnnotationBuilder(config, type);</span><br><span class="line">      parser.parse();</span><br><span class="line">      loadCompleted &#x3D; true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      &#x2F;&#x2F; 注解解析失败则移出</span><br><span class="line">      if (!loadCompleted) &#123;</span><br><span class="line">        knownMappers.remove(type);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>url或resource方式的资源配置的mapper的解析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; org.apache.ibatis.builder.xml.XMLMapperBuilder#parse</span><br><span class="line">public void parse() &#123;</span><br><span class="line">  if (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 1. 解析mapper配置到configuration中</span><br><span class="line">    configurationElement(parser.evalNode(&quot;&#x2F;mapper&quot;));</span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    &#x2F;&#x2F; 2. 根据命名空间来实现Mapper接口和mapper配置进行绑定</span><br><span class="line">    bindMapperForNamespace();</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 3. 解析结果映射</span><br><span class="line">  parsePendingResultMaps();</span><br><span class="line">  &#x2F;&#x2F; 4. 解析缓存配置</span><br><span class="line">  parsePendingCacheRefs();</span><br><span class="line">  parsePendingStatements();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 解析mapper.xml内容,包括命名空间,缓存配置,参数,结果映射,sql</span><br><span class="line">private void configurationElement(XNode context) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    String namespace &#x3D; context.getStringAttribute(&quot;namespace&quot;);</span><br><span class="line">    if (namespace &#x3D;&#x3D; null || namespace.equals(&quot;&quot;)) &#123;</span><br><span class="line">      throw new BuilderException(&quot;Mapper&#39;s namespace cannot be empty&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">    cacheRefElement(context.evalNode(&quot;cache-ref&quot;));</span><br><span class="line">    cacheElement(context.evalNode(&quot;cache&quot;));</span><br><span class="line">    parameterMapElement(context.evalNodes(&quot;&#x2F;mapper&#x2F;parameterMap&quot;));</span><br><span class="line">    resultMapElements(context.evalNodes(&quot;&#x2F;mapper&#x2F;resultMap&quot;));</span><br><span class="line">    sqlElement(context.evalNodes(&quot;&#x2F;mapper&#x2F;sql&quot;));</span><br><span class="line">    &#x2F;&#x2F; 创建XMLStatementBuilder并放入Configurtion中</span><br><span class="line">    buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    throw new BuilderException(&quot;Error parsing Mapper XML. The XML location is &#39;&quot; + resource + &quot;&#39;. Cause: &quot; + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 创建XMLStatementBuilder对象</span><br><span class="line">private void buildStatementFromContext(List&lt;XNode&gt; list, String requiredDatabaseId) &#123;</span><br><span class="line">  for (XNode context : list) &#123;</span><br><span class="line">    final XMLStatementBuilder statementParser &#x3D; new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);</span><br><span class="line">    try &#123;</span><br><span class="line">      statementParser.parseStatementNode();</span><br><span class="line">    &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">      configuration.addIncompleteStatement(statementParser);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>org.apache.ibatis.builder.xml.XMLStatementBuilder#parseStatementNode,解析Statement，包含生成MappedStatement对象，这个方法比较复杂，我们只要知道这个方法是读取Mapper的所有配置最终创建MappedStatement，然后赋值给configuration对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">public void parseStatementNode() &#123;</span><br><span class="line">  String id &#x3D; context.getStringAttribute(&quot;id&quot;);</span><br><span class="line">  String databaseId &#x3D; context.getStringAttribute(&quot;databaseId&quot;);</span><br><span class="line"></span><br><span class="line">  if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Integer fetchSize &#x3D; context.getIntAttribute(&quot;fetchSize&quot;);</span><br><span class="line">  Integer timeout &#x3D; context.getIntAttribute(&quot;timeout&quot;);</span><br><span class="line">  String parameterMap &#x3D; context.getStringAttribute(&quot;parameterMap&quot;);</span><br><span class="line">  String parameterType &#x3D; context.getStringAttribute(&quot;parameterType&quot;);</span><br><span class="line">  Class&lt;?&gt; parameterTypeClass &#x3D; resolveClass(parameterType);</span><br><span class="line">  String resultMap &#x3D; context.getStringAttribute(&quot;resultMap&quot;);</span><br><span class="line">  String resultType &#x3D; context.getStringAttribute(&quot;resultType&quot;);</span><br><span class="line">  String lang &#x3D; context.getStringAttribute(&quot;lang&quot;);</span><br><span class="line">  LanguageDriver langDriver &#x3D; getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt; resultTypeClass &#x3D; resolveClass(resultType);</span><br><span class="line">  String resultSetType &#x3D; context.getStringAttribute(&quot;resultSetType&quot;);</span><br><span class="line">  StatementType statementType &#x3D; StatementType.valueOf(context.getStringAttribute(&quot;statementType&quot;, StatementType.PREPARED.toString()));</span><br><span class="line">  ResultSetType resultSetTypeEnum &#x3D; resolveResultSetType(resultSetType);</span><br><span class="line"></span><br><span class="line">  String nodeName &#x3D; context.getNode().getNodeName();</span><br><span class="line">  SqlCommandType sqlCommandType &#x3D; SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">  boolean isSelect &#x3D; sqlCommandType &#x3D;&#x3D; SqlCommandType.SELECT;</span><br><span class="line">  boolean flushCache &#x3D; context.getBooleanAttribute(&quot;flushCache&quot;, !isSelect);</span><br><span class="line">  boolean useCache &#x3D; context.getBooleanAttribute(&quot;useCache&quot;, isSelect);</span><br><span class="line">  boolean resultOrdered &#x3D; context.getBooleanAttribute(&quot;resultOrdered&quot;, false);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Include Fragments before parsing</span><br><span class="line">  XMLIncludeTransformer includeParser &#x3D; new XMLIncludeTransformer(configuration, builderAssistant);</span><br><span class="line">  includeParser.applyIncludes(context.getNode());</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Parse selectKey after includes and remove them.</span><br><span class="line">  processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed)</span><br><span class="line">  SqlSource sqlSource &#x3D; langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line">  String resultSets &#x3D; context.getStringAttribute(&quot;resultSets&quot;);</span><br><span class="line">  String keyProperty &#x3D; context.getStringAttribute(&quot;keyProperty&quot;);</span><br><span class="line">  String keyColumn &#x3D; context.getStringAttribute(&quot;keyColumn&quot;);</span><br><span class="line">  KeyGenerator keyGenerator;</span><br><span class="line">  String keyStatementId &#x3D; id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">  keyStatementId &#x3D; builderAssistant.applyCurrentNamespace(keyStatementId, true);</span><br><span class="line">  if (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">    keyGenerator &#x3D; configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    keyGenerator &#x3D; context.getBooleanAttribute(&quot;useGeneratedKeys&quot;,</span><br><span class="line">        configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">        ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">      fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">      resultSetTypeEnum, flushCache, useCache, resultOrdered, </span><br><span class="line">      keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 构建MappedStatement，并赋值给configuration</span><br><span class="line">public MappedStatement addMappedStatement(XXX) &#123;</span><br><span class="line">  if (unresolvedCacheRef) &#123;</span><br><span class="line">    throw new IncompleteElementException(&quot;Cache-ref not yet resolved&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  id &#x3D; applyCurrentNamespace(id, false);</span><br><span class="line">  boolean isSelect &#x3D; sqlCommandType &#x3D;&#x3D; SqlCommandType.SELECT;</span><br><span class="line">  MappedStatement.Builder statementBuilder &#x3D; new MappedStatement.Builder(configuration, id, sqlSource, sqlCommandType)</span><br><span class="line">      .resource(resource)</span><br><span class="line">      .fetchSize(fetchSize)</span><br><span class="line">      .timeout(timeout)</span><br><span class="line">      .statementType(statementType)</span><br><span class="line">      .keyGenerator(keyGenerator)</span><br><span class="line">      .keyProperty(keyProperty)</span><br><span class="line">      .keyColumn(keyColumn)</span><br><span class="line">      .databaseId(databaseId)</span><br><span class="line">      .lang(lang)</span><br><span class="line">      .resultOrdered(resultOrdered)</span><br><span class="line">      .resultSets(resultSets)</span><br><span class="line">      .resultMaps(getStatementResultMaps(resultMap, resultType, id))</span><br><span class="line">      .resultSetType(resultSetType)</span><br><span class="line">      .flushCacheRequired(valueOrDefault(flushCache, !isSelect))</span><br><span class="line">      .useCache(valueOrDefault(useCache, isSelect))</span><br><span class="line">      .cache(currentCache);</span><br><span class="line">  ParameterMap statementParameterMap &#x3D; getStatementParameterMap(parameterMap, parameterType, id);</span><br><span class="line">  if (statementParameterMap !&#x3D; null) &#123;</span><br><span class="line">    statementBuilder.parameterMap(statementParameterMap);</span><br><span class="line">  &#125;</span><br><span class="line">  MappedStatement statement &#x3D; statementBuilder.build();</span><br><span class="line">  configuration.addMappedStatement(statement);</span><br><span class="line">  return statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面几个步骤获取Configuration对象,并赋给DefaultSqlSessionFactory</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 最终根据config对象创建SqlSessionFactory对象并返回</span><br><span class="line">public SqlSessionFactory build(Configuration config) &#123;</span><br><span class="line">  return new DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通过SqlSessionFactory工厂获取SqlSession"><a href="#通过SqlSessionFactory工厂获取SqlSession" class="headerlink" title="通过SqlSessionFactory工厂获取SqlSession"></a>通过SqlSessionFactory工厂获取SqlSession</h2><p>org.apache.ibatis.session.defaults.DefaultSqlSessionFactory#openSession()获取SqlSession对象,SqlSession对象的获取其实就是事物管理器和执行器的设置.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取会话</span><br><span class="line">public SqlSession openSession() &#123;</span><br><span class="line">    return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123;</span><br><span class="line">  Transaction tx &#x3D; null;</span><br><span class="line">  try &#123;</span><br><span class="line">    final Environment environment &#x3D; configuration.getEnvironment();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 根据环境来获取事务管理工厂：JdbcTransactionFactory和ManagedTransactionFactory</span><br><span class="line">    &#x2F;&#x2F; 通过这两个事务工厂来获取不同的事务管理器：JdbcTransaction（由Jdbc来管理）和ManagedTransaction（事务交给外部管理器管理，如jboss)</span><br><span class="line">    final TransactionFactory transactionFactory &#x3D; getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 构造函数创建事务管理器：JdbcTransaction</span><br><span class="line">    tx &#x3D; transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 创建执行器，默认是SimpleExecutor</span><br><span class="line">    final Executor executor &#x3D; configuration.newExecutor(tx, execType);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 创建DefaultSqlSession对象并返回，此时的sqlsession拥有configuration和executor对象。</span><br><span class="line">    return new DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    closeTransaction(tx); &#x2F;&#x2F; may have fetched a connection so lets call close()</span><br><span class="line">    throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 执行器的获取</span><br><span class="line">  public Executor newExecutor(Transaction transaction, ExecutorType executorType) &#123;</span><br><span class="line">    executorType &#x3D; executorType &#x3D;&#x3D; null ? defaultExecutorType : executorType;</span><br><span class="line">    executorType &#x3D; executorType &#x3D;&#x3D; null ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    if (ExecutorType.BATCH &#x3D;&#x3D; executorType) &#123;</span><br><span class="line">      &#x2F;&#x2F; 批量执行器</span><br><span class="line">      executor &#x3D; new BatchExecutor(this, transaction);</span><br><span class="line">    &#125; else if (ExecutorType.REUSE &#x3D;&#x3D; executorType) &#123;</span><br><span class="line">      &#x2F;&#x2F; 复用执行器</span><br><span class="line">      executor &#x3D; new ReuseExecutor(this, transaction);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 默认简单执行器</span><br><span class="line">      executor &#x3D; new SimpleExecutor(this, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    if (cacheEnabled) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果开启缓存,则使用缓存执行器</span><br><span class="line">      executor &#x3D; new CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 将执行器放入责任链中</span><br><span class="line">    executor &#x3D; (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    return executor;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="通过SqlSession来获取mapper对象"><a href="#通过SqlSession来获取mapper对象" class="headerlink" title="通过SqlSession来获取mapper对象"></a>通过SqlSession来获取mapper对象</h2><p>通过SqlSession来获取mapper对象：UserMapper userMapper = sqlSession.getMapper(UserMapper.class);<br>我们已知UserMapper是个接口类,那么mybatis生成的实现类一定是个代理类,下面我们将分析如何获取这个代理对象以及这个代理对象的方法执行的过程;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; DefaultSqlSession委托configuration</span><br><span class="line">  public &lt;T&gt; T getMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">    return configuration.&lt;T&gt;getMapper(type, this);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; Configuration委托MapperRegistry</span><br><span class="line">  public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line">    return mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 最后MapperRegistry获取代理工厂</span><br><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line">  final MapperProxyFactory&lt;T&gt; mapperProxyFactory &#x3D; (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">  if (mapperProxyFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">    throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    return mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 根据代理工厂获取代理类    </span><br><span class="line">  public T newInstance(SqlSession sqlSession) &#123;</span><br><span class="line">    final MapperProxy&lt;T&gt; mapperProxy &#x3D; new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    return newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 最终根据jdk的代理工具获取代理对象</span><br><span class="line">  protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123;</span><br><span class="line">    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="调用mapper方法执行数据库操作。"><a href="#调用mapper方法执行数据库操作。" class="headerlink" title="调用mapper方法执行数据库操作。"></a>调用mapper方法执行数据库操作。</h2><p>为了研究mapper的真实调用，我们需要通过对代理对象进行反编译，可以通过<code>arthas</code>工具来获取，下面是UserMapper的代理对象的部分代码.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public final class $Proxy7</span><br><span class="line">extends Proxy</span><br><span class="line">implements UserMapper &#123;</span><br><span class="line">    private static Method m1;</span><br><span class="line">    private static Method m5;</span><br><span class="line">    private static Method m2;</span><br><span class="line">    private static Method m4;</span><br><span class="line">    private static Method m3;</span><br><span class="line">    private static Method m0;</span><br><span class="line"></span><br><span class="line">    public $Proxy7(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        super(invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 调用</span><br><span class="line">    public final List selectAll() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 最终调用的是invocationHandler的invoke方法。</span><br><span class="line">            return (List)this.h.invoke(this, m3, null);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Error | RuntimeException throwable) &#123;</span><br><span class="line">            throw throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable throwable) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是最终调用的org.apache.ibatis.binding.MapperProxy#invoke</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class MapperProxy&lt;T&gt; implements InvocationHandler, Serializable &#123;</span><br><span class="line"></span><br><span class="line">  private static final long serialVersionUID &#x3D; -6424540398559729838L;</span><br><span class="line">  private final SqlSession sqlSession;</span><br><span class="line">  private final Class&lt;T&gt; mapperInterface;</span><br><span class="line">  private final Map&lt;Method, MapperMethod&gt; methodCache;</span><br><span class="line"></span><br><span class="line">  public MapperProxy(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache) &#123;</span><br><span class="line">    this.sqlSession &#x3D; sqlSession;</span><br><span class="line">    this.mapperInterface &#x3D; mapperInterface;</span><br><span class="line">    this.methodCache &#x3D; methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      if (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        return method.invoke(this, args);</span><br><span class="line">      &#125; else if (isDefaultMethod(method)) &#123;</span><br><span class="line">        return invokeDefaultMethod(proxy, method, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">      throw ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 从缓存中获取映射方法，如果没有则创建一个</span><br><span class="line">    final MapperMethod mapperMethod &#x3D; cachedMapperMethod(method);</span><br><span class="line">    &#x2F;&#x2F; 执行映射方法</span><br><span class="line">    return mapperMethod.execute(sqlSession, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建映射方法并缓存起来</span><br><span class="line">  private MapperMethod cachedMapperMethod(Method method) &#123;</span><br><span class="line">    MapperMethod mapperMethod &#x3D; methodCache.get(method);</span><br><span class="line">    if (mapperMethod &#x3D;&#x3D; null) &#123;</span><br><span class="line">      mapperMethod &#x3D; new MapperMethod(mapperInterface, method, sqlSession.getConfiguration());</span><br><span class="line">      methodCache.put(method, mapperMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    return mapperMethod;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Backport of java.lang.reflect.Method#isDefault()</span><br><span class="line">   *&#x2F;</span><br><span class="line">  private boolean isDefaultMethod(Method method) &#123;</span><br><span class="line">    return (method.getModifiers()</span><br><span class="line">        &amp; (Modifier.ABSTRACT | Modifier.PUBLIC | Modifier.STATIC)) &#x3D;&#x3D; Modifier.PUBLIC</span><br><span class="line">        &amp;&amp; method.getDeclaringClass().isInterface();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行org.apache.ibatis.binding.MapperMethod#execute</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public Object execute(SqlSession sqlSession, Object[] args) &#123;</span><br><span class="line">  Object result;</span><br><span class="line">  &#x2F;&#x2F; 根据执行类型来判断sqlSession的执行类型</span><br><span class="line">  switch (command.getType()) &#123;</span><br><span class="line">    case INSERT: &#123;</span><br><span class="line">    Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result &#x3D; rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    case UPDATE: &#123;</span><br><span class="line">      Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result &#x3D; rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    case DELETE: &#123;</span><br><span class="line">      Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result &#x3D; rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    case SELECT:&#x2F;&#x2F; 如果是查询，则还要根据返回值进行判断执行方法</span><br><span class="line">      if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">        executeWithResultHandler(sqlSession, args);</span><br><span class="line">        result &#x3D; null;</span><br><span class="line">      &#125; else if (method.returnsMany()) &#123;</span><br><span class="line">        result &#x3D; executeForMany(sqlSession, args);&#x2F;&#x2F; 执行获取多个结果</span><br><span class="line">      &#125; else if (method.returnsMap()) &#123;</span><br><span class="line">        result &#x3D; executeForMap(sqlSession, args);</span><br><span class="line">      &#125; else if (method.returnsCursor()) &#123;</span><br><span class="line">        result &#x3D; executeForCursor(sqlSession, args);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result &#x3D; sqlSession.selectOne(command.getName(), param);</span><br><span class="line">      &#125;</span><br><span class="line">      break;</span><br><span class="line">    case FLUSH:</span><br><span class="line">      result &#x3D; sqlSession.flushStatements();</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">      throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());</span><br><span class="line">  &#125;</span><br><span class="line">  if (result &#x3D;&#x3D; null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">    throw new BindingException(&quot;Mapper method &#39;&quot; + command.getName() </span><br><span class="line">        + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 获取多个结果查询方法</span><br><span class="line">private &lt;E&gt; Object executeForMany(SqlSession sqlSession, Object[] args) &#123;</span><br><span class="line">  List&lt;E&gt; result;</span><br><span class="line">  &#x2F;&#x2F; 参数拼接为sql</span><br><span class="line">  Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">  if (method.hasRowBounds()) &#123;&#x2F;&#x2F; 判断是否需要分页查询</span><br><span class="line">    RowBounds rowBounds &#x3D; method.extractRowBounds(args);</span><br><span class="line">    result &#x3D; sqlSession.&lt;E&gt;selectList(command.getName(), param, rowBounds);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; 最终又委托defaultSqlSession进行selectList方法调用</span><br><span class="line">    result &#x3D; sqlSession.&lt;E&gt;selectList(command.getName(), param);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; issue #510 Collections &amp; arrays support</span><br><span class="line">  if (!method.getReturnType().isAssignableFrom(result.getClass())) &#123;</span><br><span class="line">    if (method.getReturnType().isArray()) &#123;</span><br><span class="line">      return convertToArray(result);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return convertToDeclaredCollection(sqlSession.getConfiguration(), result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DefaultSqlSession进行selectList方法的调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; 通过configuration 获取MappedStatement（包含sql对应的各种描述，如结果，缓存，sql语句等，在创建SqlSessionFactory时候生成并放在configuration中）</span><br><span class="line">    MappedStatement ms &#x3D; configuration.getMappedStatement(statement);</span><br><span class="line">    &#x2F;&#x2F; 委托executor进行执行查询</span><br><span class="line">    return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>org.apache.ibatis.executor.BaseExecutor#query查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; BaseExecutor 进行query</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());</span><br><span class="line">  if (closed) &#123;</span><br><span class="line">    throw new ExecutorException(&quot;Executor was closed.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if (queryStack &#x3D;&#x3D; 0 &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    clearLocalCache();&#x2F;&#x2F; 根据flushCache配置清理缓存</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  try &#123;</span><br><span class="line">    queryStack++;</span><br><span class="line">    &#x2F;&#x2F; 判断是否有缓存，如果有则使用缓存</span><br><span class="line">    list &#x3D; resultHandler &#x3D;&#x3D; null ? (List&lt;E&gt;) localCache.getObject(key) : null;</span><br><span class="line">    if (list !&#x3D; null) &#123;</span><br><span class="line">      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 从数据库查询数据</span><br><span class="line">      list &#x3D; queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    queryStack--;</span><br><span class="line">  &#125;</span><br><span class="line">  if (queryStack &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    for (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">      deferredLoad.load();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; issue #601</span><br><span class="line">    deferredLoads.clear();</span><br><span class="line">    if (configuration.getLocalCacheScope() &#x3D;&#x3D; LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">      &#x2F;&#x2F; issue #482</span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数据库查询前，放置缓存一个占位</span><br><span class="line">  private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">    try &#123;</span><br><span class="line">    &#x2F;&#x2F; 数据库查询</span><br><span class="line">      list &#x3D; doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      localCache.removeObject(key);</span><br><span class="line">    &#125;</span><br><span class="line">    localCache.putObject(key, list);</span><br><span class="line">    if (ms.getStatementType() &#x3D;&#x3D; StatementType.CALLABLE) &#123;</span><br><span class="line">      localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>执行org.apache.ibatis.executor.SimpleExecutor#doQuery方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F; 执行org.apache.ibatis.executor.SimpleExecutor#doQuery方法</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">  Statement stmt &#x3D; null;</span><br><span class="line">  try &#123;</span><br><span class="line">    Configuration configuration &#x3D; ms.getConfiguration();</span><br><span class="line">    StatementHandler handler &#x3D; configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    stmt &#x3D; prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    &#x2F;&#x2F; 委托给RoutingStatementHandler</span><br><span class="line">    return handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    &#x2F;&#x2F; 关闭声明</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过JdbcTransaction获取Connection，然后Statement</span><br><span class="line">private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException &#123;</span><br><span class="line">  Statement stmt;</span><br><span class="line">  Connection connection &#x3D; getConnection(statementLog);</span><br><span class="line">  stmt &#x3D; handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">  handler.parameterize(stmt);</span><br><span class="line">  return stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用org.apache.ibatis.executor.statement.RoutingStatementHandler#query方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; org.apache.ibatis.executor.statement.RoutingStatementHandler#query</span><br><span class="line">&#x2F;&#x2F; 由RoutingStatementHandler委派给对应的StatementHandler</span><br><span class="line">  @Override</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">  return delegate.&lt;E&gt;query(statement, resultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终委派给org.apache.ibatis.executor.statement.PreparedStatemen方法进行查询，通过resultSetHandler封装获取结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 最终委派给PreparedStatemen方法进行查询，通过resultSetHandler封装获取结果</span><br><span class="line">  @Override</span><br><span class="line">  public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">    &#x2F;&#x2F; JDBC的原始类</span><br><span class="line">    PreparedStatement ps &#x3D; (PreparedStatement) statement;</span><br><span class="line">    ps.execute();</span><br><span class="line">    &#x2F;&#x2F; 封装查询结果</span><br><span class="line">    return resultSetHandler.&lt;E&gt; handleResultSets(ps);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>最后由org.apache.ibatis.executor.resultset.DefaultResultSetHandler对查询结果进行封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; org.apache.ibatis.executor.resultset.DefaultResultSetHandler#handleResultSets</span><br><span class="line">&#x2F;&#x2F; 对查询结果进行封装</span><br><span class="line">  @Override</span><br><span class="line">  public List&lt;Object&gt; handleResultSets(Statement stmt) throws SQLException &#123;</span><br><span class="line">    ErrorContext.instance().activity(&quot;handling results&quot;).object(mappedStatement.getId());</span><br><span class="line"></span><br><span class="line">    final List&lt;Object&gt; multipleResults &#x3D; new ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    int resultSetCount &#x3D; 0;</span><br><span class="line">    ResultSetWrapper rsw &#x3D; getFirstResultSet(stmt);</span><br><span class="line"></span><br><span class="line">    List&lt;ResultMap&gt; resultMaps &#x3D; mappedStatement.getResultMaps();</span><br><span class="line">    int resultMapCount &#x3D; resultMaps.size();</span><br><span class="line">    validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line">    while (rsw !&#x3D; null &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">      ResultMap resultMap &#x3D; resultMaps.get(resultSetCount);</span><br><span class="line">      handleResultSet(rsw, resultMap, multipleResults, null);</span><br><span class="line">      rsw &#x3D; getNextResultSet(stmt);</span><br><span class="line">      cleanUpAfterHandlingResultSet();</span><br><span class="line">      resultSetCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] resultSets &#x3D; mappedStatement.getResultSets();</span><br><span class="line">    if (resultSets !&#x3D; null) &#123;</span><br><span class="line">      while (rsw !&#x3D; null &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</span><br><span class="line">        ResultMapping parentMapping &#x3D; nextResultMaps.get(resultSets[resultSetCount]);</span><br><span class="line">        if (parentMapping !&#x3D; null) &#123;</span><br><span class="line">          String nestedResultMapId &#x3D; parentMapping.getNestedResultMapId();</span><br><span class="line">          ResultMap resultMap &#x3D; configuration.getResultMap(nestedResultMapId);</span><br><span class="line">          handleResultSet(rsw, resultMap, null, parentMapping);</span><br><span class="line">        &#125;</span><br><span class="line">        rsw &#x3D; getNextResultSet(stmt);</span><br><span class="line">        cleanUpAfterHandlingResultSet();</span><br><span class="line">        resultSetCount++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return collapseSingleResultList(multipleResults);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="mybatis结构图"><a href="#mybatis结构图" class="headerlink" title="mybatis结构图"></a>mybatis结构图</h2><h3 id="整体架构图"><a href="#整体架构图" class="headerlink" title="整体架构图"></a>整体架构图</h3><p><img src="https://gitee.com/mvilplss/note/raw/master/image/mybatis%E6%9E%B6%E6%9E%84.jpeg"><br><a target="_blank" rel="noopener" href="https://gitee.com/mvilplss/note/raw/master/image/mybatis%E6%9E%B6%E6%9E%84.jpeg">https://gitee.com/mvilplss/note/raw/master/image/mybatis架构.jpeg</a></p>
<h3 id="层次结构图"><a href="#层次结构图" class="headerlink" title="层次结构图"></a>层次结构图</h3><p><img src="https://gitee.com/mvilplss/note/raw/master/image/mybatis%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.jpg"><br><a target="_blank" rel="noopener" href="https://gitee.com/mvilplss/note/raw/master/image/mybatis%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.jpg">https://gitee.com/mvilplss/note/raw/master/image/mybatis层次结构.jpg</a></p>
<h3 id="调用时序图"><a href="#调用时序图" class="headerlink" title="调用时序图"></a>调用时序图</h3><p><img src="https://gitee.com/mvilplss/note/raw/master/image/mybatis%E6%97%B6%E5%BA%8F%E5%9B%BE.jpeg"><br><a target="_blank" rel="noopener" href="https://gitee.com/mvilplss/note/raw/master/image/mybatis%E6%97%B6%E5%BA%8F%E5%9B%BE.jpeg">https://gitee.com/mvilplss/note/raw/master/image/mybatis时序图.jpeg</a></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/getting-started.html">https://mybatis.org/mybatis-3/zh/getting-started.html</a></li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/MyBatis/2824918?fr=aladdin">https://baike.baidu.com/item/MyBatis/2824918?fr=aladdin</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2018/03/03/Java%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/03/03/Java%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Java之线程池分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-03-03 00:00:00" itemprop="dateCreated datePublished" datetime="2018-03-03T00:00:00+08:00">2018-03-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:27" itemprop="dateModified" datetime="2022-07-05T22:46:27+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">开发技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="java线程池ThreadPoolExecutor原理"><a href="#java线程池ThreadPoolExecutor原理" class="headerlink" title="java线程池ThreadPoolExecutor原理"></a>java线程池ThreadPoolExecutor原理</h2><h3 id="线程池构造器的每个参数含义"><a href="#线程池构造器的每个参数含义" class="headerlink" title="线程池构造器的每个参数含义"></a>线程池构造器的每个参数含义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;&#x3D; 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue &#x3D;&#x3D; null || threadFactory &#x3D;&#x3D; null || handler &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.acc &#x3D; System.getSecurityManager() &#x3D;&#x3D; null ?</span><br><span class="line">            null :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    this.corePoolSize &#x3D; corePoolSize;</span><br><span class="line">    this.maximumPoolSize &#x3D; maximumPoolSize;</span><br><span class="line">    this.workQueue &#x3D; workQueue;</span><br><span class="line">    this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory &#x3D; threadFactory;</span><br><span class="line">    this.handler &#x3D; handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>七个参数：</p>
<ul>
<li>corePoolSize 线程池的核心线程数大小，当线程数小于这个值的时候，新任务过来会创建线程并执行任务。</li>
<li>maximumPoolSize 线程池的总线程数大小，当队列满的时候会判断线程数是否小于这个值，如果小于则进行创建线程并执行任务。</li>
<li>keepAliveTime 当超过核心线程数创建的线程空闲时间，如果超过这个时间当前线程就会执行完毕并关闭，通过获取队列超时来实现的。</li>
<li>unit 上面时间值的单位 毫秒，秒，分钟。。。</li>
<li>workQueue 工作队列，当核心线程数满的时候就会把任务放进工作队列。</li>
<li>threadFactory 创建线程的线程工厂，可以实现接口ThreadFactory，实现newThread方法来创建自己定义的线程，默认：Executors.defaultThreadFactory()。</li>
<li>handler 拒绝处理器，当队列满时候并且达到最大线程数，新增任务会触发拒绝处理器，拒绝器会获取当前要执行的任务，默认是拒绝并抛异常。</li>
</ul>
<h2 id="任务提交到线程池执行过程"><a href="#任务提交到线程池执行过程" class="headerlink" title="任务提交到线程池执行过程"></a>任务提交到线程池执行过程</h2><h3 id="线程池状态："><a href="#线程池状态：" class="headerlink" title="线程池状态："></a>线程池状态：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过一个原子性整数的高低位来保存线程池的运行状态和工作线程数。</span><br><span class="line">private final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line">private static final int COUNT_BITS &#x3D; Integer.SIZE - 3;</span><br><span class="line">private static final int CAPACITY   &#x3D; (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; runState is stored in the high-order bits 高位表示状态</span><br><span class="line">private static final int RUNNING    &#x3D; -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int SHUTDOWN   &#x3D;  0 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int STOP       &#x3D;  1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TIDYING    &#x3D;  2 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TERMINATED &#x3D;  3 &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Packing and unpacking ctl</span><br><span class="line">&#x2F;&#x2F; 获取状态</span><br><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class="line">&#x2F;&#x2F; 获取工作线程数</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class="line">&#x2F;&#x2F; 状态和工作线程数合并成一个整数</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>RUNNING 线程池在运行中。</li>
<li>SHUTDOWN 线程池关闭状态，新的任务不允许加入线程池，等待剩余老的任务和队列执行完毕，shutdown()会进入此状态。</li>
<li>STOP 线程池处于停止状态，shutdownNow()会进入此状态。</li>
<li>TIDYING 当工作线程为0的时候进入此状态。</li>
<li>TERMINATED 线程池终止。</li>
</ul>
<h3 id="提交任务："><a href="#提交任务：" class="headerlink" title="提交任务："></a>提交任务：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * Proceed in 3 steps:</span><br><span class="line">     *</span><br><span class="line">     * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="line">     * start a new thread with the given command as its first</span><br><span class="line">     * task.  The call to addWorker atomically checks runState and</span><br><span class="line">     * workerCount, and so prevents false alarms that would add</span><br><span class="line">     * threads when it shouldn&#39;t, by returning false.</span><br><span class="line">     *</span><br><span class="line">     * 2. If a task can be successfully queued, then we still need</span><br><span class="line">     * to double-check whether we should have added a thread</span><br><span class="line">     * (because existing ones died since last checking) or that</span><br><span class="line">     * the pool shut down since entry into this method. So we</span><br><span class="line">     * recheck state and if necessary roll back the enqueuing if</span><br><span class="line">     * stopped, or start a new thread if there are none.</span><br><span class="line">     *</span><br><span class="line">     * 3. If we cannot queue task, then we try to add a new</span><br><span class="line">     * thread.  If it fails, we know we are shut down or saturated</span><br><span class="line">     * and so reject the task.</span><br><span class="line">     *&#x2F;</span><br><span class="line">     </span><br><span class="line">     &#x2F;&#x2F; 如果工作线程数小于核心线程则直接增加工作线程和任务执行。</span><br><span class="line">    int c &#x3D; ctl.get();</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        if (addWorker(command, true))</span><br><span class="line">            return;</span><br><span class="line">        c &#x3D; ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果超过核心数，则任务放入队列，然后再次检测线程池是否在执行，如果不在执行则移除当前任务并拒绝任务。否则判断工作线程是否为0，如果为0则通过增加一个空的任务增加一个线程。</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        int recheck &#x3D; ctl.get();</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        else if (workerCountOf(recheck) &#x3D;&#x3D; 0)</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果任务满了则增加非核心线程和任务，如果失败则拒绝任务。</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="增加工作线程和任务："><a href="#增加工作线程和任务：" class="headerlink" title="增加工作线程和任务："></a>增加工作线程和任务：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; firstTask表示当前线程的第一个任务，如果任务为空，则只增加一个线程。</span><br><span class="line">&#x2F;&#x2F; core 表示是否是核心线程，主要是判断工作线程和核心线程或最大线程数做对比。</span><br><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">    retry:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; ctl.get();</span><br><span class="line">        int rs &#x3D; runStateOf(c);</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; Check if queue empty only if necessary.</span><br><span class="line">        if (rs &gt;&#x3D; SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask &#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            return false;</span><br><span class="line"> </span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int wc &#x3D; workerCountOf(c);</span><br><span class="line">            if (wc &gt;&#x3D; CAPACITY ||</span><br><span class="line">                wc &gt;&#x3D; (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                return false;</span><br><span class="line">            if (compareAndIncrementWorkerCount(c))</span><br><span class="line">                break retry;</span><br><span class="line">            c &#x3D; ctl.get();  &#x2F;&#x2F; Re-read ctl</span><br><span class="line">            if (runStateOf(c) !&#x3D; rs)</span><br><span class="line">                continue retry;</span><br><span class="line">            &#x2F;&#x2F; else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    boolean workerStarted &#x3D; false;</span><br><span class="line">    boolean workerAdded &#x3D; false;</span><br><span class="line">    Worker w &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        w &#x3D; new Worker(firstTask);</span><br><span class="line">        final Thread t &#x3D; w.thread;</span><br><span class="line">        if (t !&#x3D; null) &#123;</span><br><span class="line">            final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; Recheck while holding lock.</span><br><span class="line">                &#x2F;&#x2F; Back out on ThreadFactory failure or if</span><br><span class="line">                &#x2F;&#x2F; shut down before lock acquired.</span><br><span class="line">                int rs &#x3D; runStateOf(ctl.get());</span><br><span class="line">                if (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp; firstTask &#x3D;&#x3D; null)) &#123;</span><br><span class="line">                    if (t.isAlive()) &#x2F;&#x2F; precheck that t is startable</span><br><span class="line">                        throw new IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    int s &#x3D; workers.size();</span><br><span class="line">                    if (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize &#x3D; s;&#x2F;&#x2F; 出现过最大线程数。</span><br><span class="line">                    workerAdded &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            if (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    return workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工作线程内部类："><a href="#工作线程内部类：" class="headerlink" title="工作线程内部类："></a>工作线程内部类：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">private final class Worker</span><br><span class="line">        extends AbstractQueuedSynchronizer</span><br><span class="line">        implements Runnable&#123;</span><br><span class="line">        private static final long serialVersionUID &#x3D; 6138294804551838833L;</span><br><span class="line">        &#x2F;** Thread this worker is running in.  Null if factory fails. *&#x2F;</span><br><span class="line">        final Thread thread;</span><br><span class="line">        &#x2F;** Initial task to run.  Possibly null. *&#x2F;</span><br><span class="line">        Runnable firstTask;</span><br><span class="line">        &#x2F;** Per-thread task counter *&#x2F;</span><br><span class="line">        volatile long completedTasks;</span><br><span class="line">        &#x2F;&#x2F; 创建新的线程，并把this赋给新的线程</span><br><span class="line">        Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-1); &#x2F;&#x2F; inhibit interrupts until runWorker</span><br><span class="line">            this.firstTask &#x3D; firstTask;</span><br><span class="line">            this.thread &#x3D; getThreadFactory().newThread(this);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 当addWorker成功后，调用worker.t.start()则执行此方法（线程会调用Runnable的run方法）。</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            runWorker(this);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; Lock methods</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        &#x2F;&#x2F; The value 0 represents the unlocked state.</span><br><span class="line">        &#x2F;&#x2F; The value 1 represents the locked state.</span><br><span class="line">        protected boolean isHeldExclusively() &#123;</span><br><span class="line">            return getState() !&#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        protected boolean tryAcquire(int unused) &#123;</span><br><span class="line">            if (compareAndSetState(0, 1)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        protected boolean tryRelease(int unused) &#123;</span><br><span class="line">            setExclusiveOwnerThread(null);</span><br><span class="line">            setState(0);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        public void lock()        &#123; acquire(1); &#125;</span><br><span class="line">        public boolean tryLock()  &#123; return tryAcquire(1); &#125;</span><br><span class="line">        public void unlock()      &#123; release(1); &#125;</span><br><span class="line">        public boolean isLocked() &#123; return isHeldExclusively(); &#125;</span><br><span class="line">        void interruptIfStarted() &#123;</span><br><span class="line">            Thread t;</span><br><span class="line">            if (getState() &gt;&#x3D; 0 &amp;&amp; (t &#x3D; thread) !&#x3D; null &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; catch (SecurityException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行任务："><a href="#执行任务：" class="headerlink" title="执行任务："></a>执行任务：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">    Thread wt &#x3D; Thread.currentThread();</span><br><span class="line">    Runnable task &#x3D; w.firstTask;</span><br><span class="line">    w.firstTask &#x3D; null;</span><br><span class="line">    w.unlock(); &#x2F;&#x2F; allow interrupts</span><br><span class="line">    boolean completedAbruptly &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 循环执行当前任务或获取任务并执行任务。</span><br><span class="line">        while (task !&#x3D; null || (task &#x3D; getTask()) !&#x3D; null) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            &#x2F;&#x2F; If pool is stopping, ensure thread is interrupted;</span><br><span class="line">            &#x2F;&#x2F; if not, ensure thread is not interrupted.  This</span><br><span class="line">            &#x2F;&#x2F; requires a recheck in second case to deal with</span><br><span class="line">            &#x2F;&#x2F; shutdownNow race while clearing interrupt</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">                beforeExecute(wt, task);&#x2F;&#x2F; 用来重写实现自己的执行任务前方法</span><br><span class="line">                Throwable thrown &#x3D; null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                    thrown &#x3D; x; throw x;</span><br><span class="line">                &#125; catch (Error x) &#123;</span><br><span class="line">                    thrown &#x3D; x; throw x;</span><br><span class="line">                &#125; catch (Throwable x) &#123;</span><br><span class="line">                    thrown &#x3D; x; throw new Error(x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    afterExecute(task, thrown);&#x2F;&#x2F; 用来重写实现自己的执行任务后执行方法</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                task &#x3D; null;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 正常结束</span><br><span class="line">        completedAbruptly &#x3D; false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F; 处理工作退出操作</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="清理工作线程和变更线程计数，异常结束的线程则补充一个。"><a href="#清理工作线程和变更线程计数，异常结束的线程则补充一个。" class="headerlink" title="清理工作线程和变更线程计数，异常结束的线程则补充一个。"></a>清理工作线程和变更线程计数，异常结束的线程则补充一个。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;</span><br><span class="line">    &#x2F;&#x2F; 异常结束则减少工作线程，否则线程数目不变。</span><br><span class="line">    if (completedAbruptly) &#x2F;&#x2F; If abrupt, then workerCount wasn&#39;t adjusted</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        completedTaskCount +&#x3D; w.completedTasks;&#x2F;&#x2F; 计算完成任务数</span><br><span class="line">        workers.remove(w);&#x2F;&#x2F; 移除任务队列</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryTerminate();&#x2F;&#x2F; 有工作线程退出，怀疑是线程池关闭，因此尝试终止线程池。</span><br><span class="line"></span><br><span class="line">    int c &#x3D; ctl.get();</span><br><span class="line">    if (runStateLessThan(c, STOP)) &#123;&#x2F;&#x2F; 如果还没有到STOP状态</span><br><span class="line">        if (!completedAbruptly) &#123;&#x2F;&#x2F; 正常结束的线程</span><br><span class="line">            int min &#x3D; allowCoreThreadTimeOut ? 0 : corePoolSize;</span><br><span class="line">            if (min &#x3D;&#x3D; 0 &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min &#x3D; 1;</span><br><span class="line">            if (workerCountOf(c) &gt;&#x3D; min)</span><br><span class="line">                return; &#x2F;&#x2F; replacement not needed</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 非正常结束或者工作队列不空并且线程数为0则增加一个线程。</span><br><span class="line">        addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="获取任务："><a href="#获取任务：" class="headerlink" title="获取任务："></a>获取任务：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private Runnable getTask() &#123;</span><br><span class="line">    boolean timedOut &#x3D; false; &#x2F;&#x2F; Did the last poll() time out?</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; ctl.get();</span><br><span class="line">        int rs &#x3D; runStateOf(c);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Check if queue empty only if necessary.</span><br><span class="line">        if (rs &gt;&#x3D; SHUTDOWN &amp;&amp; (rs &gt;&#x3D; STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int wc &#x3D; workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Are workers subject to culling? 根据工作线程数判断是否需要杀死线程</span><br><span class="line">        boolean timed &#x3D; allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</span><br><span class="line">            if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                return null;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">        &#x2F;&#x2F; 此处就是根据timed判断来决定线程是否需要超时或者阻塞。</span><br><span class="line">            Runnable r &#x3D; timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            if (r !&#x3D; null)</span><br><span class="line">                return r;</span><br><span class="line">            timedOut &#x3D; true;</span><br><span class="line">        &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">            timedOut &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>shutdown:启动有序关闭，其中先前提交的任务将被执行，但不会接受任何新任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void shutdown() &#123;</span><br><span class="line">    final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(SHUTDOWN);&#x2F;&#x2F; 设为关闭状态</span><br><span class="line">        interruptIdleWorkers();&#x2F;&#x2F; 中断空闲的工作线程</span><br><span class="line">        onShutdown(); &#x2F;&#x2F; hook for ScheduledThreadPoolExecutor</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate(); &#x2F;&#x2F; 尝试终止线程池</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>showdownNow:尝试停止所有正在执行的任务(调用线程的interrupt，不保证一定停止)，停止等待任务的处理，并返回等待执行的任务列表，停止接受任何新的任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Runnable&gt; shutdownNow() &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP);&#x2F;&#x2F; 设置为停止状态</span><br><span class="line">        interruptWorkers();&#x2F;&#x2F; 中断所有工作线程</span><br><span class="line">        tasks &#x3D; drainQueue();&#x2F;&#x2F; 排出所有任务队列中的任务</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    return tasks;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 排出所有任务队列中的任务</span><br><span class="line">private List&lt;Runnable&gt; drainQueue() &#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; q &#x3D; workQueue;</span><br><span class="line">    ArrayList&lt;Runnable&gt; taskList &#x3D; new ArrayList&lt;Runnable&gt;();</span><br><span class="line">    q.drainTo(taskList);</span><br><span class="line">    if (!q.isEmpty()) &#123;</span><br><span class="line">        for (Runnable r : q.toArray(new Runnable[0])) &#123;</span><br><span class="line">            if (q.remove(r))</span><br><span class="line">                taskList.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return taskList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="线程池其他方法"><a href="#线程池其他方法" class="headerlink" title="线程池其他方法"></a>线程池其他方法</h3><p>允许核心线程超时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; allowCoreThreadTimeOut默认是false，当设置为true的时候，核心线程数也会超时被回收。</span><br><span class="line">public void allowCoreThreadTimeOut(boolean value) &#123;</span><br><span class="line">    if (value &amp;&amp; keepAliveTime &lt;&#x3D; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Core threads must have nonzero keep alive times&quot;);</span><br><span class="line">    if (value !&#x3D; allowCoreThreadTimeOut) &#123;</span><br><span class="line">        allowCoreThreadTimeOut &#x3D; value;</span><br><span class="line">        if (value)</span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>准备所有核心线程数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int prestartAllCoreThreads() &#123;</span><br><span class="line">    int n &#x3D; 0;</span><br><span class="line">    while (addWorker(null, true))</span><br><span class="line">        ++n;</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Spring框架中的线程池"><a href="#Spring框架中的线程池" class="headerlink" title="Spring框架中的线程池"></a>Spring框架中的线程池</h1><h1 id="Dubbo框架中的线程池"><a href="#Dubbo框架中的线程池" class="headerlink" title="Dubbo框架中的线程池"></a>Dubbo框架中的线程池</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2018/02/04/Java%E4%B9%8BBigDecimal%E7%B2%BE%E5%BA%A6%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/02/04/Java%E4%B9%8BBigDecimal%E7%B2%BE%E5%BA%A6%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">Java之Bigdecimal精度引发的问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-02-04 00:00:00" itemprop="dateCreated datePublished" datetime="2018-02-04T00:00:00+08:00">2018-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:27" itemprop="dateModified" datetime="2022-07-05T22:46:27+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">开发技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="BigDecimal精度问题"><a href="#BigDecimal精度问题" class="headerlink" title="BigDecimal精度问题"></a>BigDecimal精度问题</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><blockquote>
<p>有一次维护老系统碰到这样一个问题，给定一批车总放款金额，每辆车的实际价格（整数），让根据实际价格的比例进行计算每辆车的放款金额（整数）。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">解决方案：</span><br><span class="line">1.循环每辆车</span><br><span class="line">2.前n-1辆车的放款金额&#x3D;总放款金额*当前车的实际价格&#x2F;总实际价格；</span><br><span class="line">3.最后一辆车放款金额&#x3D;总放款金额-（n-1)车的总放款金额;</span><br></pre></td></tr></table></figure>
<p>经过几次测试发现计算没有问题，就发布上线了，安全运行了一百多天，直到有一天出现了最后一辆的放款金额为负数，一个精度问题就发生了（突然想到墨菲定律）！</p>
<p>通过查看日志和数据的模拟，发现是一个四舍五入的问题，当实际价格/总实际价格的时候，如果结果是0.106经过四舍五入为0.11，这样前面每辆车就会多分配一些放款金额，最终导致（n-1）辆车总放款金额大于给定的总放款金额。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最终通过配置BigDecimal的RoundMode，将四舍五入改为了舍去，这样保证n-1辆车都不会出现多算的情况，从而解决问题。    </span><br><span class="line">想这种问题在实际开发中很难去发现问题，因此我们用BigDecimal一定要清楚他的API，从而避免不适当的使用。</span><br></pre></td></tr></table></figure>

<h2 id="BigDecimal的使用"><a href="#BigDecimal的使用" class="headerlink" title="BigDecimal的使用"></a>BigDecimal的使用</h2><blockquote>
<p>Java在java.math包中提供的API类BigDecimal，<br>用来对超过16位有效位的数进行精确的运算。双精度浮点型变量double可以处理16位有效数。<br>在实际应用中，需要对更大或者更小的数进行运算和处理。float和double只能用来做科学计算或者是工程计算，<br>在商业计算中要用java.math.BigDecimal。BigDecimal所创建的是对象，我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，<br>而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象。构造器是类的特殊方法，专门用来创建对象，特别是带有参数的对象。</p>
</blockquote>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>BigDecimal一共有4个构造方法:</p>
<ul>
<li>BigDecimal(int) 创建一个具有参数所指定整数值的对象。</li>
<li>BigDecimal(double) 创建一个具有参数所指定双精度值的对象。（不建议采用）</li>
<li>BigDecimal(long) 创建一个具有参数所指定长整数值的对象。</li>
<li>BigDecimal(String) 创建一个具有参数所指定以字符串表示的数值的对象</li>
</ul>
<p>第四个方法不建议使用是因为double本身会有精度问题，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal a &#x3D; new BigDecimal(0.1);</span><br><span class="line">BigDecimal b &#x3D; new BigDecimal(&quot;0.1&quot;);</span><br><span class="line">BigDecimal c &#x3D; BigDecimal.valueOf(0.1);</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br><span class="line">System.out.println(c);</span><br><span class="line">System.out.println(a.equals(b));</span><br><span class="line">System.out.println(b.equals(c));</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0.1000000000000000055511151231257827021181583404541015625</span><br><span class="line">0.1</span><br><span class="line">0.1</span><br><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p>原因：JDK的描述：1、参数类型为double的构造方法的结果有一定的不可预知性。<br>有人可能认为在Java中写入newBigDecimal(0.1)所创建的BigDecimal正好等于 0.1（非标度值 1，其标度为 1），<br>但是它实际上等于0.1000000000000000055511151231257827021181583404541015625。这是因为0.1无法准确地表示为<br>double（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，传入到构造方法的值不会正好等于 0.1<br>（虽然表面上等于该值）。2、另一方面，String 构造方法是完全可预知的：写入 newBigDecimal(“0.1”) 将创建一个 BigDecimal，<br>它正好等于预期的 0.1。因此，比较而言，通常建议优先使用String构造方法。</p>
<h3 id="BigDecimal加减乘除运算"><a href="#BigDecimal加减乘除运算" class="headerlink" title="BigDecimal加减乘除运算"></a>BigDecimal加减乘除运算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public BigDecimal add(BigDecimal value); &#x2F;&#x2F;加法</span><br><span class="line">public BigDecimal subtract(BigDecimal value); &#x2F;&#x2F;减法 </span><br><span class="line">public BigDecimal multiply(BigDecimal value); &#x2F;&#x2F;乘法</span><br><span class="line">public BigDecimal divide(BigDecimal value); &#x2F;&#x2F;除法</span><br></pre></td></tr></table></figure>

<p>除法的时候一定要注意，当出现不能整除的情况会会报错java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.<br>其实divide方法有可以传三个参数：public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) 第一参数表示除数， 第二个参数表示小数点后保留位数，第三个参数表示舍入模式。</p>
<h4 id="roundingMode舍入模式"><a href="#roundingMode舍入模式" class="headerlink" title="roundingMode舍入模式"></a>roundingMode舍入模式</h4><blockquote>
<p>舍入模式和scale配合使用，其中scale是保留小数点后面的位数，而roundingMode是表示如何进行舍入，舍入模式有八种，下面将为介绍。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">UP &#x2F;&#x2F; 舍入模式来远离零。</span><br><span class="line">5.5     6</span><br><span class="line">2.5     3</span><br><span class="line">1.6     2</span><br><span class="line">1.1     2</span><br><span class="line">1.0     1</span><br><span class="line">-1.0        -1</span><br><span class="line">-1.1        -2</span><br><span class="line">-1.6        -2</span><br><span class="line">-2.5        -3</span><br><span class="line">-5.5        -6</span><br><span class="line"></span><br><span class="line">DOWN &#x2F;&#x2F; 舍入模式为零.</span><br><span class="line">5.5     5</span><br><span class="line">2.5     2</span><br><span class="line">1.6     1</span><br><span class="line">1.1     1</span><br><span class="line">1.0     1</span><br><span class="line">-1.0        -1</span><br><span class="line">-1.1        -1</span><br><span class="line">-1.6        -1</span><br><span class="line">-2.5        -2</span><br><span class="line">-5.5        -5</span><br><span class="line"></span><br><span class="line">CEILING&#x2F;&#x2F; 舍入模式正无穷;</span><br><span class="line">5.5     6</span><br><span class="line">2.5     3</span><br><span class="line">1.6     2</span><br><span class="line">1.1     2</span><br><span class="line">1.0     1</span><br><span class="line">-1.0        -1</span><br><span class="line">-1.1        -1</span><br><span class="line">-1.6        -1</span><br><span class="line">-2.5        -2</span><br><span class="line">-5.5        -5</span><br><span class="line"></span><br><span class="line">FLOOR&#x2F;&#x2F; 舍入模式向负无穷</span><br><span class="line">5.5     5</span><br><span class="line">2.5     2</span><br><span class="line">1.6     1</span><br><span class="line">1.1     1</span><br><span class="line">1.0     1</span><br><span class="line">-1.0        -1</span><br><span class="line">-1.1        -2</span><br><span class="line">-1.6        -2</span><br><span class="line">-2.5        -3</span><br><span class="line">-5.5        -6</span><br><span class="line"></span><br><span class="line">HALF_UP&#x2F;&#x2F; 四舍五入</span><br><span class="line">5.5     6</span><br><span class="line">2.5     3</span><br><span class="line">1.6     2</span><br><span class="line">1.1     2</span><br><span class="line">1.0     1</span><br><span class="line">-1.0        -1</span><br><span class="line">-1.1        -1</span><br><span class="line">-1.6        -2</span><br><span class="line">-2.5        -3</span><br><span class="line">-5.5        -6</span><br><span class="line"></span><br><span class="line">HALF_DOWN&#x2F;&#x2F; 五舍六入</span><br><span class="line">5.5     5</span><br><span class="line">2.5     2</span><br><span class="line">1.6     2</span><br><span class="line">1.1     1</span><br><span class="line">1.0     1</span><br><span class="line">-1.0        -1</span><br><span class="line">-1.1        -1</span><br><span class="line">-1.6        -2</span><br><span class="line">-2.5        -2</span><br><span class="line">-5.5        -5</span><br><span class="line"></span><br><span class="line">HALF_EVEN&#x2F;&#x2F; 当&#x3D;.5的时候向者偶数靠近</span><br><span class="line">5.5     6</span><br><span class="line">2.5     2</span><br><span class="line">1.6     2</span><br><span class="line">1.1     1</span><br><span class="line">1.0     1</span><br><span class="line">-1.0        -1</span><br><span class="line">-1.1        -1</span><br><span class="line">-1.6        -2</span><br><span class="line">-2.5        -2</span><br><span class="line">-5.5        -6</span><br><span class="line"></span><br><span class="line">UNNECESSARY&#x2F;&#x2F; 不允许需要舍入的，否则抛出异常：ArithmeticException</span><br></pre></td></tr></table></figure>

<h3 id="其他常用方法"><a href="#其他常用方法" class="headerlink" title="其他常用方法"></a>其他常用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 比较两个数的大小：</span><br><span class="line">&#x2F;&#x2F; -1, 0, or 1 as this BigDecimal is numerically less than, equal to, or greater than val</span><br><span class="line">public int compareTo(BigDecimal val);</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>java doc</li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/BigDecimal/5131707">https://baike.baidu.com/item/BigDecimal/5131707</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2018/01/20/Java%E4%B9%8B%E7%BC%96%E8%AF%91%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/20/Java%E4%B9%8B%E7%BC%96%E8%AF%91%E5%99%A8/" class="post-title-link" itemprop="url">Java之编译器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-01-20 00:00:00" itemprop="dateCreated datePublished" datetime="2018-01-20T00:00:00+08:00">2018-01-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:27" itemprop="dateModified" datetime="2022-07-05T22:46:27+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">开发技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>写过规则引擎的同学都知道drools语言，我们都通过一个drools容器来加载并执行drools写的各种规则,也玩过通过Java的脚本引擎执行过Javascript代码.这些动态加载并运行代码主要是用于编写不同规则,而非在代码中写满各种ifelse判断.<br>有的开发同学可能会想,Java语言可以作为想动态语言一样使用吗?答案是可以的,下面我们就开始!</p>
<h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><p>sun公司在jdk1.6后就正式发布了关于Java编译器的API,下面我们直接看一个简单的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void simpleCode() throws Exception &#123;</span><br><span class="line">    JavaCompiler javaCompiler &#x3D; ToolProvider.getSystemJavaCompiler();</span><br><span class="line">    int run &#x3D; javaCompiler.run(null, null, null, &quot;file&#x2F;SimpleBean.java&quot;);</span><br><span class="line">    if (run &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        log.info(&quot;编译成功&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        log.error(&quot;编译失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码是直接对Java源码文件进行编译,编译后的class文件会存在和源码的同一个目录下.</p>
<h2 id="带有诊断器的实现"><a href="#带有诊断器的实现" class="headerlink" title="带有诊断器的实现"></a>带有诊断器的实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 带有诊断器，编译本地磁盘上源码</span><br><span class="line">@Test</span><br><span class="line">public void templateCode() throws Exception &#123;</span><br><span class="line">    JavaCompiler javaCompiler &#x3D; ToolProvider.getSystemJavaCompiler();</span><br><span class="line">    &#x2F;&#x2F; 诊断收集器</span><br><span class="line">    DiagnosticCollector&lt;JavaFileObject&gt; diagnosticCollector &#x3D; new DiagnosticCollector&lt;JavaFileObject&gt;();</span><br><span class="line">    StandardJavaFileManager standardFileManager &#x3D; javaCompiler.getStandardFileManager(diagnosticCollector, null, null);</span><br><span class="line">    Iterable&lt;? extends JavaFileObject&gt; javaFileObjects &#x3D; standardFileManager.getJavaFileObjects(&quot;&#x2F;Users&#x2F;sanxing&#x2F;blog&#x2F;note&#x2F;code&#x2F;file&#x2F;SimpleBean.java&quot;);</span><br><span class="line">    JavaCompiler.CompilationTask compilerTask &#x3D; javaCompiler.getTask(null, standardFileManager, diagnosticCollector, null, null, javaFileObjects);</span><br><span class="line">    Boolean call &#x3D; compilerTask.call();</span><br><span class="line">    if (call) &#123;</span><br><span class="line">        log.info(&quot;编译成功&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        log.error(&quot;编译失败&quot;);</span><br><span class="line">        diagnosticCollector.getDiagnostics().forEach(diagnostic -&gt; &#123;</span><br><span class="line">            log.error(diagnostic.getKind().name());</span><br><span class="line">            log.error(diagnostic.getCode());</span><br><span class="line">            log.error(diagnostic.getSource().getName() + &quot;&gt;&quot; + diagnostic.getLineNumber() + &quot;:&quot; + diagnostic.getColumnNumber()</span><br><span class="line">                    + &quot;:&quot; + diagnostic.getMessage(Locale.CHINA));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当编译失败后,诊断器会获取编译失败的源码文件名,行数和列数以及失败的具体原因,比如局部变量未初始化使用.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleBean &#123;</span><br><span class="line">    public String whoami()&#123;</span><br><span class="line">        int i;</span><br><span class="line">        return &quot;my name is SimpleBean for testing.&quot;+i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 编译结果</span><br><span class="line">17:11:13:133|ERROR|main|52|编译失败</span><br><span class="line">17:11:13:184|ERROR|main|54|ERROR</span><br><span class="line">17:11:13:184|ERROR|main|55|compiler.err.var.might.not.have.been.initialized</span><br><span class="line">17:11:13:188|ERROR|main|56|&#x2F;Users&#x2F;sanxing&#x2F;blog&#x2F;note&#x2F;code&#x2F;file&#x2F;SimpleBean.java&gt;4:53:可能尚未初始化变量i</span><br></pre></td></tr></table></figure>

<h2 id="复杂实现"><a href="#复杂实现" class="headerlink" title="复杂实现"></a>复杂实现</h2><p>当我们需要自己在程序运行时候编译Java源码的情况下,大部分源码并非是在磁盘上,很有可能是数据库中.那么我们如何实现呢?下面的例子将会展现Java源码的编译,源码的自由获取,源码编译后的字节码加载到jvm中<a href="https://mvilplss.github.io/2018/01/01/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">类加载器</a>并运行其中的方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void forwardingJavaFileManagerCodeWithInvoke() throws Exception &#123;</span><br><span class="line">        JavaCompiler javaCompiler &#x3D; ToolProvider.getSystemJavaCompiler();</span><br><span class="line">        &#x2F;&#x2F; 诊断收集器</span><br><span class="line">        DiagnosticCollector&lt;JavaFileObject&gt; diagnosticCollector &#x3D; new DiagnosticCollector&lt;JavaFileObject&gt;();</span><br><span class="line">        &#x2F;&#x2F; 获取标准Java文件管理器</span><br><span class="line">        StandardJavaFileManager standardFileManager &#x3D; javaCompiler.getStandardFileManager(diagnosticCollector, Locale.CHINA, Charset.forName(&quot;UTF-8&quot;));</span><br><span class="line">        List&lt;ClassByteFileObject&gt; classFileList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F; 创建标准Java文件包装器</span><br><span class="line">        ForwardingJavaFileManager forwardingJavaFileManager &#x3D; new ForwardingJavaFileManager(standardFileManager) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public JavaFileObject getJavaFileForOutput(Location location, String className, JavaFileObject.Kind kind, FileObject sibling) throws IOException &#123;</span><br><span class="line">                &#x2F;&#x2F; 设置编译后的class对象输出对象</span><br><span class="line">                ClassByteFileObject javaFileObject &#x3D; new ClassByteFileObject(className);</span><br><span class="line">                classFileList.add(javaFileObject);</span><br><span class="line">                return javaFileObject;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F; 创建Java编译任务</span><br><span class="line">        JavaCompiler.CompilationTask compilerTask &#x3D; javaCompiler.getTask(null, &#x2F;&#x2F; 错误输出，null则打印控制台</span><br><span class="line">                forwardingJavaFileManager, &#x2F;&#x2F; 设置编译后对象输入文件管理器</span><br><span class="line">                diagnosticCollector, &#x2F;&#x2F; 设置诊断器</span><br><span class="line">                null, null,</span><br><span class="line">                Collections.singleton(new JavaSourceFileObject(&quot;SimpleBean.java&quot;,getSource(&quot;file&#x2F;SimpleBean.java&quot;)))&#x2F;&#x2F; 设置源文件管理器,我们可以从任何地方加载,包括DB</span><br><span class="line">        );</span><br><span class="line">        Boolean call &#x3D; compilerTask.call();</span><br><span class="line">        if (call) &#123;</span><br><span class="line">            log.info(&quot;编译成功！&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.error(&quot;编译失败！&quot;);</span><br><span class="line">            diagnosticCollector.getDiagnostics().forEach(diagnostic -&gt; &#123;</span><br><span class="line">                log.error(diagnostic.getKind().name());</span><br><span class="line">                log.error(diagnostic.getCode());</span><br><span class="line">                log.error(diagnostic.getSource().getName() + &quot;&gt;&quot; + diagnostic.getLineNumber() + &quot;:&quot; + diagnostic.getColumnNumber()</span><br><span class="line">                        + &quot;:&quot; + diagnostic.getMessage(Locale.CHINA));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 加载编译好的类并调用</span><br><span class="line">        ByteClassLoader byteClassLoader &#x3D; new ByteClassLoader(classFileList.get(0).getBytes());</span><br><span class="line">        Class&lt;?&gt; aClass &#x3D; byteClassLoader.findClass(&quot;SimpleBean&quot;);</span><br><span class="line">        Object whoami &#x3D; aClass.getMethod(&quot;whoami&quot;).invoke(aClass.newInstance());</span><br><span class="line">        log.info(s(whoami));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 加载字节类加载器</span><br><span class="line">    class ByteClassLoader extends ClassLoader&#123;</span><br><span class="line">        private byte[] bytes;</span><br><span class="line"></span><br><span class="line">        public ByteClassLoader(byte[] bytes) &#123;</span><br><span class="line">            this.bytes &#x3D; bytes;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">            return defineClass(name,bytes,0,bytes.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 加载Java源码字符串，可以是任何来源</span><br><span class="line">    private String getSource(String path) throws IOException &#123;</span><br><span class="line">        StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">        List&lt;String&gt; allLines &#x3D; Files.readAllLines(Paths.get(path));</span><br><span class="line">        allLines.forEach(line-&gt;&#123;</span><br><span class="line">            sb.append(line);</span><br><span class="line">        &#125;);</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 类编译后的文件输出对象</span><br><span class="line">    class ClassByteFileObject extends SimpleJavaFileObject &#123;</span><br><span class="line">        private ByteArrayOutputStream stream;</span><br><span class="line"></span><br><span class="line">        public ClassByteFileObject(String name) &#123;</span><br><span class="line">            super(URI.create(&quot;bytes:&#x2F;&#x2F;&#x2F;&quot; + name), Kind.CLASS);</span><br><span class="line">            stream &#x3D; new ByteArrayOutputStream();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 表示类文件输出</span><br><span class="line">        @Override</span><br><span class="line">        public OutputStream openOutputStream() throws IOException &#123;</span><br><span class="line">            return stream;</span><br><span class="line">        &#125;</span><br><span class="line">        public byte[] getBytes() &#123;</span><br><span class="line">            return stream.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Java源码文件对象</span><br><span class="line">    class JavaSourceFileObject extends SimpleJavaFileObject &#123;</span><br><span class="line">        private String source;</span><br><span class="line">        public JavaSourceFileObject(String name,String source) throws IOException &#123;</span><br><span class="line">            super(URI.create(&quot;string:&#x2F;&#x2F;&#x2F;&quot; + name), Kind.SOURCE);</span><br><span class="line">            this.source &#x3D; source;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException &#123;</span><br><span class="line">            return source;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的简介:</p>
<ul>
<li>如果要获取到编译后的字节码的字节,我们需要定制自己的JavaFileObject来装载编译结果.</li>
<li>编译的结果获取需要通过文件管理器的包装类<code>ForwardingJavaFileManager.getJavaFileForOutput()</code>的方法中设置我们定义的文件对象<code>ClassByteFileObject</code></li>
<li>自定义文件对象来获取输出结果需要继承<code>SimpleJavaFileObject</code>并重写<code>openOutputStream</code>方法.构造器中Kind为CLASS.</li>
<li>我们把输入的结果存入到<code>classFileList</code>中,下面类加载需要用到.</li>
<li>源码的输入同样需要源码的文件对象<code>JavaSourceFileObject</code>继承并重写<code>SimpleJavaFileObject.getCharContent</code>方法来自定义源文件的字符串,这样我们可以把远程加载过来的Java源码包装成Java文件对象.</li>
<li>定义自己的类字节码加载器<code>ByteClassLoader</code>用来加载编译后的class,然后通过反射调用目标方法.</li>
</ul>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">17:31:47:745|INFO |main|90|编译成功！</span><br><span class="line">17:31:47:747|INFO |main|105|my name is SimpleBean for testing.</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>Java doc</li>
<li>《Java核心技术二》</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2018/01/10/Java%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/10/Java%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Java之线程分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-01-10 00:00:00" itemprop="dateCreated datePublished" datetime="2018-01-10T00:00:00+08:00">2018-01-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:27" itemprop="dateModified" datetime="2022-07-05T22:46:27+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">开发技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="java线程"><a href="#java线程" class="headerlink" title="java线程"></a>java线程</h2><p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程内共享进程范围内的资源(例如内存句柄和文件句柄)，是进程中的实际运作单位，每个线程都有自己的程序计数器(program counter)、栈及局部变量等。我们说的java线程就是jvm程序中执行的线程。</p>
<h3 id="java线程的创建"><a href="#java线程的创建" class="headerlink" title="java线程的创建"></a>java线程的创建</h3><p>Java线程有两个创建方式，可以通过继承Thread，重写run方法来创建。也可以通过实现runnable接口作为构造参数来创建线程。</p>
<p>参数简介：</p>
<ul>
<li>ThreadGroup g 线程组，线程需要加到线程组中，方便线程的维护，线程的线程组默认是当前线程的线程组。</li>
<li>Runnable target 可执行目标，指线程开启后要执行的任务。</li>
<li>String name 线程的名称</li>
<li>long stackSize 线程栈期望的大小，默认0 忽略大小，可通过Xss参数配置，线程栈的大小影响递归的深度，线程栈越大递归的深度越大。栈大小默认为1024k，可以通过：-XX:+PrintFlagsFinal 打印<code>ThreadStackSize</code>。</li>
<li>AccessControlContext acc 线程的上下文访问控制 默认null</li>
<li>boolean inheritThreadLocals 是否继承ThreadLocal，默认是false，表示ThreadLocal</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">private void init(ThreadGroup g, Runnable target, String name,</span><br><span class="line">                      long stackSize, AccessControlContext acc,</span><br><span class="line">                      boolean inheritThreadLocals) &#123;</span><br><span class="line">        if (name &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;name cannot be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        Thread parent &#x3D; currentThread();</span><br><span class="line">        SecurityManager security &#x3D; System.getSecurityManager();</span><br><span class="line">        if (g &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;* Determine if it&#39;s an applet or not *&#x2F;</span><br><span class="line">            &#x2F;* If there is a security manager, ask the security manager</span><br><span class="line">               what to do. *&#x2F;</span><br><span class="line">               &#x2F;&#x2F; 如果是applet 则使用security的线程组</span><br><span class="line">            if (security !&#x3D; null) &#123;</span><br><span class="line">                g &#x3D; security.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;* If the security doesn&#39;t have a strong opinion of the matter</span><br><span class="line">               use the parent thread group. *&#x2F;</span><br><span class="line">               &#x2F;&#x2F; 如果线程组未指定，则使用当前线程的线程组</span><br><span class="line">            if (g &#x3D;&#x3D; null) &#123;</span><br><span class="line">                g &#x3D; parent.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;* checkAccess regardless of whether or not threadgroup is</span><br><span class="line">           explicitly passed in. *&#x2F;</span><br><span class="line">        g.checkAccess();&#x2F;&#x2F; 校验权限</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Do we have the required permissions?</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if (security !&#x3D; null) &#123;</span><br><span class="line">            if (isCCLOverridden(getClass())) &#123;</span><br><span class="line">                security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 线程组增加未启动的线程个数</span><br><span class="line">        g.addUnstarted();</span><br><span class="line">        </span><br><span class="line">        this.group &#x3D; g;</span><br><span class="line">        this.daemon &#x3D; parent.isDaemon();&#x2F;&#x2F; 如果父线程是守护线程，则只能创建出来的线程默认也是守护线程</span><br><span class="line">        this.priority &#x3D; parent.getPriority();&#x2F;&#x2F; 优先级同父线程</span><br><span class="line">        if (security &#x3D;&#x3D; null || isCCLOverridden(parent.getClass()))</span><br><span class="line">            this.contextClassLoader &#x3D; parent.getContextClassLoader();</span><br><span class="line">        else</span><br><span class="line">            this.contextClassLoader &#x3D; parent.contextClassLoader;</span><br><span class="line">        this.inheritedAccessControlContext &#x3D;</span><br><span class="line">                acc !&#x3D; null ? acc : AccessController.getContext();</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">        setPriority(priority);&#x2F;&#x2F; 设置优先级</span><br><span class="line">        if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals !&#x3D; null)</span><br><span class="line">            this.inheritableThreadLocals &#x3D;</span><br><span class="line">                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">        &#x2F;* Stash the specified stack size in case the VM cares *&#x2F;</span><br><span class="line">        this.stackSize &#x3D; stackSize;</span><br><span class="line"></span><br><span class="line">        &#x2F;* Set thread ID *&#x2F;</span><br><span class="line">        tid &#x3D; nextThreadID();&#x2F;&#x2F; 线程的id</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="java线程的状态"><a href="#java线程的状态" class="headerlink" title="java线程的状态"></a>java线程的状态</h3><p>线程在创建，执行到销毁对应不同的线程状态，下面将介绍线程的每个状态以及如何进入改状态的。</p>
<ul>
<li>NEW 初始化状态：线程创建但未启动的时候为该状态。</li>
<li>RUNNABLE 运行状态：一个线程在jvm正常执行过程中为该状态，包括正在等待处理器资源，在所有状态切换都需要先进入这个状态。</li>
<li>BLOCKED 阻塞状态：当线程正在等待monitor lock的时候会进入此状态，或者wait()后重新等待monitor lock。</li>
<li>WAITING 等待状态：当线程调用了Object.wait(),Thread.join(),LockSupport.park（包括所有AQS)等待的时候为该状态。</li>
<li>TIMED_WAITING 等待超时：当线程调用了Object.wait(time),Thread.join(time),LockSupport.park(time)，Thread.sleep(time)会等待时间的等待。</li>
<li>TERMINATED 终止：线程完成执行。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">    @Test</span><br><span class="line">    public void threadState() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 通过引擎启动来演示线程的状态转换</span><br><span class="line">        class Engine &#123;</span><br><span class="line">            synchronized void start() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    TestUtil.sleep(500);</span><br><span class="line">                    wait(1000);</span><br><span class="line">                    TestUtil.sleep(2000);</span><br><span class="line">                &#125; catch (Exception e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Engine engine &#x3D; new Engine();</span><br><span class="line">        Runnable runnable &#x3D; engine::start;</span><br><span class="line">        &#x2F;&#x2F; 创建演示目标线程</span><br><span class="line">        Thread thread &#x3D; new Thread(runnable);</span><br><span class="line">        thread.setName(&quot;targetThread&quot;);</span><br><span class="line">        &#x2F;&#x2F; 启动干扰线程，触发同步阻塞</span><br><span class="line">        new Thread(runnable).start();</span><br><span class="line">        &#x2F;&#x2F; 获取线程状态</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            Thread.State oldState &#x3D; null;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                Thread.State state &#x3D; thread.getState();</span><br><span class="line">                if (oldState !&#x3D; state) &#123;</span><br><span class="line">                    System.err.println(thread.getName() + &quot;:&quot; + state);</span><br><span class="line">                    oldState &#x3D; state;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        thread.start();</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 打印结果</span><br><span class="line">targetThread:NEW</span><br><span class="line">targetThread:RUNNABLE</span><br><span class="line">targetThread:BLOCKED</span><br><span class="line">targetThread:RUNNABLE</span><br><span class="line">targetThread:TIMED_WAITING</span><br><span class="line">targetThread:RUNNABLE</span><br><span class="line">targetThread:TIMED_WAITING</span><br><span class="line">targetThread:BLOCKED</span><br><span class="line">targetThread:TIMED_WAITING</span><br><span class="line">targetThread:RUNNABLE</span><br><span class="line">targetThread:TERMINATED</span><br></pre></td></tr></table></figure>

<p>由上面例子的运行结果可以得出：当线程创建好为NEW状态，调用start后为RUNNABLE，发送同步锁竞争等待时候为BLOCKED，当进入wait(&gt;0)/sleep时候进入TIMED_WAITING，运行结束进入TERMINATED。所有状态切换都先进入RUNNABLE。<br><img src="https://gitee.com/mvilplss/note/raw/master/image/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt="线程状态转换"></p>
<h3 id="java线程的常用方法"><a href="#java线程的常用方法" class="headerlink" title="java线程的常用方法"></a>java线程的常用方法</h3><ul>
<li>interrupt() 发起阻断请求，当线程正在处于WAITING，TIMED_WAITING状态时候，将会进入RUNNABLE状态并收到InterruptedException异常。</li>
<li>isInterrupted() 单纯的判断阻断状态。</li>
<li>Thread.interrupted();// 判断是否被阻断并清除阻断状态，将阻断状态设置为false。</li>
<li>setUncaughtExceptionHandler() 设置线程内未捕获的异常处理器。</li>
<li>join() 等待线程执行完毕</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public final synchronized void join(long millis)</span><br><span class="line">throws InterruptedException &#123;</span><br><span class="line">    long base &#x3D; System.currentTimeMillis();</span><br><span class="line">    long now &#x3D; 0;</span><br><span class="line">    if (millis &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (millis &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        while (isAlive()) &#123;&#x2F;&#x2F; 如果线程存活则继续等待。</span><br><span class="line">            wait(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        while (isAlive()) &#123;</span><br><span class="line">            long delay &#x3D; millis - now;</span><br><span class="line">            if (delay &lt;&#x3D; 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now &#x3D; System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>setDaemon() 设置为守护线程，线程启动前可以设置，默认随父线程（当前线程）；当所有非守护线程关闭后守护线程也会被jvm关闭。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final void setDaemon(boolean on) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        if (isAlive()) &#123;&#x2F;&#x2F; 必须为存活状态</span><br><span class="line">            throw new IllegalThreadStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        daemon &#x3D; on;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>run() 执行线程中target.run方法，如果直接调用thread.run这样会失效线程的作用，变成线程直接执行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    if (target !&#x3D; null) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>setPriority() 设置线程优先级，级别1-10，默认优先级随父线程（当前线程），官方不建议通过优先级来决定线程的执行顺序，因为不同平台的优先级可能不一样，也可能某些平台不支持。</li>
</ul>
<h3 id="关于线程的stackSize的研究："><a href="#关于线程的stackSize的研究：" class="headerlink" title="关于线程的stackSize的研究："></a>关于线程的stackSize的研究：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; -XX:+PrintFlagsFinal -XX:MaxDirectMemorySize&#x3D;512</span><br><span class="line">&#x2F;&#x2F; -XX:NativeMemoryTracking&#x3D;detail -Xmx4g -Xss180k</span><br><span class="line">@Test</span><br><span class="line">public void stackSize() throws Exception &#123;</span><br><span class="line">    class Door &#123;</span><br><span class="line">        int deepNum;</span><br><span class="line"></span><br><span class="line">        public void openDoor() &#123;</span><br><span class="line">            deepNum++;</span><br><span class="line">            if (deepNum &lt; 10000) &#123;</span><br><span class="line">                openDoor();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Door door &#x3D; new Door();</span><br><span class="line">    Thread thread &#x3D; new Thread(null, () -&gt; &#123;</span><br><span class="line">        log.info(&quot;running...&quot;);</span><br><span class="line">        door.openDoor();</span><br><span class="line">    &#125;, &quot;xxxxxxx&quot;, 1024 * 512);</span><br><span class="line"></span><br><span class="line">    thread.start();</span><br><span class="line">    Field stackSizeField &#x3D; Thread.class.getDeclaredField(&quot;stackSize&quot;);</span><br><span class="line">    stackSizeField.setAccessible(true);</span><br><span class="line">    Object o &#x3D; stackSizeField.get(thread);</span><br><span class="line">    log.info(&quot;stackSize:&quot; + s(o));</span><br><span class="line">    thread.join();</span><br><span class="line">    log.error(&quot;exp:&#123;&#125;&quot;, door.deepNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过实验，发现栈的深度并不是随着stackSize增加而线性增加，而是当stackSize大于某个些值时候才会增加栈的深度。确定的是stackSize越大则栈的深度越深。</p>
<h3 id="Java虚拟机栈（Java-virtual-machine-stack）"><a href="#Java虚拟机栈（Java-virtual-machine-stack）" class="headerlink" title="Java虚拟机栈（Java virtual machine stack）"></a>Java虚拟机栈（Java virtual machine stack）</h3><p>关于jvm的运行时数据区中和线程紧密相关的就是Java虚拟机栈，每一条Java线程都有一个私有的虚拟机栈，这个栈与线程同时创建，用于存储栈帧。栈帧是用来存储数据和部分过程结果的数据结构，随着方法的调用而创建，随着方法的结束而销毁。</p>
<ul>
<li>当线程请求分配的栈容量超过Java虚拟机允许的最大容量，Java虚拟机会抛出一个StackOverFlowError异常。</li>
<li>当创建线程过多，新的线程无法申请到足够的内存的时候，Java虚拟机会抛出一个OutOfMemoryError异常。<br><img src="https://gitee.com/mvilplss/note/raw/master/image/%E7%BA%BF%E7%A8%8B%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84.png" alt="线程栈帧结构"></li>
</ul>
<h3 id="线程交替打印1，2，3-实现方式"><a href="#线程交替打印1，2，3-实现方式" class="headerlink" title="线程交替打印1，2，3 实现方式"></a>线程交替打印1，2，3 实现方式</h3><h4 id="使用wait和notifyAll实现"><a href="#使用wait和notifyAll实现" class="headerlink" title="使用wait和notifyAll实现"></a>使用wait和notifyAll实现</h4><p>通过同步方法对线程数取模来交替的唤醒和阻塞，设置初始值为0，第一个线程取模为0则进行打印后递增，唤醒其他线程同时阻塞自己；当另外两个线程被唤醒后启动并检测取模后的值为真则打印，递增，唤醒所有，阻塞，以此类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void printOrderThread1() throws Exception &#123;</span><br><span class="line">        AtomicInteger atomicInteger &#x3D; new AtomicInteger(0);</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (atomicInteger) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        while (true) &#123;</span><br><span class="line">                            if (atomicInteger.get() % 3 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                                log.info(s(0));</span><br><span class="line">                                atomicInteger.incrementAndGet();</span><br><span class="line">                                atomicInteger.notifyAll();</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                atomicInteger.wait();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (atomicInteger) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        while (true) &#123;</span><br><span class="line">                            if (atomicInteger.get() % 3 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                                log.info(s(1));</span><br><span class="line">                                atomicInteger.incrementAndGet();</span><br><span class="line">                                atomicInteger.notifyAll();</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                atomicInteger.wait();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (atomicInteger) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        while (true) &#123;</span><br><span class="line">                            if (atomicInteger.get() % 3 &#x3D;&#x3D; 2) &#123;</span><br><span class="line">                                log.info(s(2));</span><br><span class="line">                                atomicInteger.incrementAndGet();</span><br><span class="line">                                atomicInteger.notifyAll();</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                atomicInteger.wait();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="借助阻塞队列的阻塞机制实现"><a href="#借助阻塞队列的阻塞机制实现" class="headerlink" title="借助阻塞队列的阻塞机制实现"></a>借助阻塞队列的阻塞机制实现</h4><p>通过阻塞队列就比较清晰，声明三个队列，初始化第一个队列增加一个元素，当线程启动后获取当前队列的元素，如果没有则阻塞，否则打印然后放入第二个队列中一个元素，第二个线程获取元素并打印后放入第三个队列中一个元素，第三线程同样获取元素并打印，然后放入到第一个队列元素，以此类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void printOrderThread2() throws Exception &#123;</span><br><span class="line">    BlockingQueue q1 &#x3D; new ArrayBlockingQueue(1);</span><br><span class="line">    BlockingQueue q2 &#x3D; new ArrayBlockingQueue(1);</span><br><span class="line">    BlockingQueue q3 &#x3D; new ArrayBlockingQueue(1);</span><br><span class="line">    q1.put(new Object());</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (q1.take() !&#x3D; null) &#123;</span><br><span class="line">                log.info(s(0));</span><br><span class="line">                q2.put(new Object());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (q2.take() !&#x3D; null) &#123;</span><br><span class="line">                log.info(s(1));</span><br><span class="line">                q3.put(new Object());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (q3.take() !&#x3D; null) &#123;</span><br><span class="line">                log.info(s(2));</span><br><span class="line">                q1.put(new Object());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    System.in.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>《Java核心技术I》</li>
<li>《Java虚拟机规范java SE 8》</li>
<li> Java虚拟机规范：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf">https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf</a></li>
</ul>
<h3 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h3><blockquote>
<p>相关源码：<a target="_blank" rel="noopener" href="https://github.com/mvilplss/note">https://github.com/mvilplss/note</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2018/01/02/Java%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/02/Java%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" class="post-title-link" itemprop="url">Java之类加载器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-01-02 00:00:00" itemprop="dateCreated datePublished" datetime="2018-01-02T00:00:00+08:00">2018-01-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:27" itemprop="dateModified" datetime="2022-07-05T22:46:27+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">开发技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是类加载器"><a href="#什么是类加载器" class="headerlink" title="什么是类加载器"></a>什么是类加载器</h2><p>我们都知道Java程序运行到jvm上，我们把Java源码文件编译为jvm运行的指令，这些指令按照一定格式存在一个文件中-Java class文件，这些class文件如果要运行需要类加载器先加载到虚拟机内存中,然后获取一个java.lang.Class对象。<br>在Java中有三种类加载器：</p>
<ul>
<li>引导类加载器：用来加载jdk的自带类（rt.jar等,可以通过<code>Launcher.getBootstrapClassPath()</code>获取路径.）</li>
<li>扩展类加载器Launcher.ExtClassLoader：用来加载%JAVA_HOME%/jre/lib/ext下的类。</li>
<li>应用类加载器Launcher.AppClassLoader：用来加载classpath下的类。</li>
</ul>
<p>获取不同的类加载器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void javaClassLoader() throws Exception &#123;</span><br><span class="line">       log.info(s(Integer.class.getClassLoader()));</span><br><span class="line">       log.info(s(NashornGuards.class.getClassLoader()));&#x2F;&#x2F; javascript引擎，位于%JAVA_HOME%&#x2F;jre&#x2F;lib&#x2F;ext下</span><br><span class="line">       log.info(s(ClassLoaderDemo.class.getClassLoader()));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">19:28:20:228|INFO |main|27|null</span><br><span class="line">19:28:20:236|INFO |main|28|sun.misc.Launcher$ExtClassLoader@1b40d5f0</span><br><span class="line">19:28:20:236|INFO |main|29|sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>

<h2 id="如何保证类唯一性"><a href="#如何保证类唯一性" class="headerlink" title="如何保证类唯一性"></a>如何保证类唯一性</h2><p>Classloader为了保证加载到jvm中的类的唯一性，通过<code>双亲委派模式</code>和<code>同步锁</code>实现。</p>
<ul>
<li><code>双亲委派模式</code>保证了一个类只被一个加载器加载。</li>
<li><code>同步锁</code>保证了在并发情况下一个类只被加载一次（jvm类加载默认是并行的）。</li>
</ul>
<p>我们看下ClassLoader类的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">    throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; 同步锁</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">        &#x2F;&#x2F; First, check if the class has already been loaded 检测是否加载过</span><br><span class="line">        Class&lt;?&gt; c &#x3D; findLoadedClass(name);</span><br><span class="line">        if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">            long t0 &#x3D; System.nanoTime();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent !&#x3D; null) &#123;&#x2F;&#x2F; 父类不为空则递归继续让父类加载</span><br><span class="line">                    c &#x3D; parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;&#x2F;&#x2F; 如果父类为空则由引导类加载器加载</span><br><span class="line">                    c &#x3D; findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; 这个catch很关键，执行findClass后位找到class则会抛出异常，所以捕获后可以保证继续父类的子类执行。</span><br><span class="line">                &#x2F;&#x2F; ClassNotFoundException thrown if class not found</span><br><span class="line">                &#x2F;&#x2F; from the non-null parent class loader</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; If still not found, then invoke findClass in order</span><br><span class="line">                &#x2F;&#x2F; to find the class.</span><br><span class="line">                long t1 &#x3D; System.nanoTime();</span><br><span class="line">                &#x2F;&#x2F; 如果通过递归向上检测父类及父类的父类等都没有加载,则当前加载器进行加载.</span><br><span class="line">                &#x2F;&#x2F; 下面自定义类加载器可以看到重写这个方法</span><br><span class="line">                c &#x3D; findClass(name);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; this is the defining class loader; record the stats</span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面源码执行过程:<br>1.当前类加载器获取此类名的锁<br>2.从jvm内存中查找类<br>3.如果没有查找到,则判断是否有父类<br>4.有父类则进行调用父类的loadClass()进行类,重复1步骤.<br>5.没有父类则从引导加载器加载的类中查找findBootstrapClassOrNull()<br>6.如果仍然未获取到类则调用当前类加载器的findClass()进行加载.</p>
<p>双亲委派的不仅实现了类的不同优先级,保证了高级别类不被低级别类覆盖.比如系统级别的Integer.class不被自定义的覆盖.</p>
<h2 id="类加载核心"><a href="#类加载核心" class="headerlink" title="类加载核心"></a>类加载核心</h2><p>看完上面的步骤,你可能会问自己:如果所有父类都没有加载这个类,那么调用当前的类加器的<code>findClass()</code>方法是怎么找到这个类的.<br>看下URLClassLoader类的findClass()源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* The search path for classes and resources *&#x2F;</span><br><span class="line">URLClassPath ucp;</span><br><span class="line">protected Class&lt;?&gt; findClass(final String name)</span><br><span class="line">    throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    final Class&lt;?&gt; result;</span><br><span class="line">    try &#123;</span><br><span class="line">        result &#x3D; AccessController.doPrivileged(</span><br><span class="line">            new PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123;</span><br><span class="line">                public Class&lt;?&gt; run() throws ClassNotFoundException &#123;</span><br><span class="line">                    String path &#x3D; name.replace(&#39;.&#39;, &#39;&#x2F;&#39;).concat(&quot;.class&quot;);</span><br><span class="line">                    &#x2F;&#x2F; 从当前加载器的类路径中获取类资源</span><br><span class="line">                    Resource res &#x3D; ucp.getResource(path, false);</span><br><span class="line">                    if (res !&#x3D; null) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            return defineClass(name, res);</span><br><span class="line">                        &#125; catch (IOException e) &#123;</span><br><span class="line">                            throw new ClassNotFoundException(name, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, acc);</span><br><span class="line">    &#125; catch (java.security.PrivilegedActionException pae) &#123;</span><br><span class="line">        throw (ClassNotFoundException) pae.getException();</span><br><span class="line">    &#125;</span><br><span class="line">    if (result &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面源码可以看出类的最终查找是通过<code>ucp.getResource(path, false)</code>获取的,而ucp是存储每个加载器的加载空间.<br>我们看下AppClassLoader的部分源码就明白了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> URLClassPath ucp = SharedSecrets.getJavaNetAccess().getURLClassPath(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getAppClassLoader</span><span class="params">(<span class="keyword">final</span> ClassLoader var0)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">         <span class="keyword">final</span> String var1 = System.getProperty(<span class="string">&quot;java.class.path&quot;</span>);</span><br><span class="line">         <span class="keyword">final</span> File[] var2 = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> File[<span class="number">0</span>] : Launcher.getClassPath(var1);</span><br><span class="line">         <span class="keyword">return</span> (ClassLoader)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Launcher.AppClassLoader&gt;() &#123;</span><br><span class="line">             <span class="keyword">public</span> Launcher.<span class="function">AppClassLoader <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                 URL[] var1x = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> URL[<span class="number">0</span>] : Launcher.pathToURLs(var2);</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">new</span> Launcher.AppClassLoader(var1x, var0);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     AppClassLoader(URL[] var1, ClassLoader var2) &#123;</span><br><span class="line">         <span class="keyword">super</span>(var1, var2, Launcher.factory);</span><br><span class="line">         <span class="keyword">this</span>.ucp.initLookupCache(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         ClassLoader.registerAsParallelCapable();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>AppClassLoader继承URLClassLoader,通过调用静态方法<code>getAppClassLoader</code>创建AppClassLoader对象,具体步骤如下:</p>
<ul>
<li>获取java.class.path的属性,也就是我们classpath的路径.</li>
<li>把文件路径转化为URL[]数组.</li>
<li>调用AppClassLoader带参数构造器,然后调用super父类的构造把url[]传给父类,初始化父类的ucp路径.</li>
<li>初始化自己的ucp查找路径缓存.</li>
</ul>
<p>URLClassLoader的构造器源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public URLClassLoader(URL[] urls, ClassLoader parent,</span><br><span class="line">                      URLStreamHandlerFactory factory) &#123;</span><br><span class="line">    super(parent);</span><br><span class="line">    &#x2F;&#x2F; this is to make the stack depth consistent with 1.1</span><br><span class="line">    SecurityManager security &#x3D; System.getSecurityManager();</span><br><span class="line">    if (security !&#x3D; null) &#123;</span><br><span class="line">        security.checkCreateClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    acc &#x3D; AccessController.getContext();</span><br><span class="line">    &#x2F;&#x2F; 根据子类的urls创建ucp.</span><br><span class="line">    ucp &#x3D; new URLClassPath(urls, factory, acc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样当调用当前对象的<code>findClass</code>方法时候,使用的<code>ucp</code>对象就是当前对象创建时候创建的<code>ucp</code>.<br>简单调用流程如下:<br><img src="https://gitee.com/mvilplss/note/raw/master/image/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png" alt="类加载的简单流程,丑见谅!"></p>
<h2 id="写一个自定义加载器"><a href="#写一个自定义加载器" class="headerlink" title="写一个自定义加载器"></a>写一个自定义加载器</h2><p>我们大多数使用使用默认应用类加载器都可以完成几乎所有工作,但是如果我们想加载远程的class到本地虚拟机,那么就需要自定义一个加载器.<br>实现自定义类加载器只需要继承抽象类<code>ClassLoader</code>,然后重写<code>findClass</code>方法,然后实现远程类的字节下载即可.<br>代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remoteClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    NetworkClassLoader networkClassLoader = <span class="keyword">new</span> NetworkClassLoader();</span><br><span class="line">    Class&lt;?&gt; aClass = networkClassLoader.loadClass(<span class="string">&quot;ClassLoaderDemo$RemoteClass&quot;</span>);</span><br><span class="line">    Object o = aClass.newInstance();</span><br><span class="line">    Object myName = aClass.getMethod(<span class="string">&quot;myName&quot;</span>).invoke(o);</span><br><span class="line">    log.info(s(myName));</span><br><span class="line">    log.info(s(aClass.getClassLoader()));</span><br><span class="line">    log.info(s(aClass.getClassLoader().getParent()));</span><br><span class="line">    log.info(s(aClass.getClassLoader().getParent().getParent()));</span><br><span class="line">    log.info(s(aClass.getClassLoader().getParent().getParent().getParent()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义加载器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">	<span class="comment">// 自定义类字节码获取</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData()&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;network load ...&quot;</span>);</span><br><span class="line">            <span class="comment">// 为了方便，使用本地代替了远程下载</span></span><br><span class="line">            <span class="keyword">return</span> Files.readAllBytes(Paths.get(<span class="string">&quot;lib/ClassLoaderDemo$RemoteClass.class&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String name)&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] loadClassData = loadClassData();</span><br><span class="line">        <span class="keyword">if</span> (loadClassData==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;class data is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用父类的方法进行加载</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, loadClassData, <span class="number">0</span>, loadClassData.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 远程的类代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">myName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I am remote class !&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">20:09:20:199|INFO |main|71|network load ...</span><br><span class="line">20:09:20:226|INFO |main|59|I am remote class !</span><br><span class="line">20:09:20:226|INFO |main|60|ClassLoaderDemo$NetworkClassLoader@402bba4f</span><br><span class="line">20:09:20:226|INFO |main|61|sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">20:09:20:227|INFO |main|62|sun.misc.Launcher$ExtClassLoader@1b40d5f0</span><br><span class="line">20:09:20:227|INFO |main|63|null</span><br></pre></td></tr></table></figure>

<h2 id="相关疑问"><a href="#相关疑问" class="headerlink" title="相关疑问"></a>相关疑问</h2><p>1.binary name是什么?<br>就是我们的类的全名如:com.lang.Integer<br>2.什么是破坏双亲委派机制？<br>通过TCCL(ThreadContextClassLoader)来实现上级加载器加载的类中通过非当前加载器加载子类时候破坏了双亲委派机制，如jdk的spi机制，典型的就是jdbc的Driver实现类的自动加载。Driver和DriverManager接口是BootStrap加载器加载的，但是实现类是通过DriverManager通过TCCL方式加载的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2017/01/04/Java%E4%B9%8BHashMap%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/01/04/Java%E4%B9%8BHashMap%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Java之HashMap分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-01-04 00:00:00" itemprop="dateCreated datePublished" datetime="2017-01-04T00:00:00+08:00">2017-01-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:27" itemprop="dateModified" datetime="2022-07-05T22:46:27+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">开发技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="hashmap分析前准备"><a href="#hashmap分析前准备" class="headerlink" title="hashmap分析前准备"></a>hashmap分析前准备</h2><blockquote>
<p>当前jdk版本：jdk1.8</p>
</blockquote>
<p>为了更好的研究hashmap的数据结构，我们写了个hashmap反射函数，可以打印出当前数据存放结构可视化和各项属性参数，这样可以帮助我们展示hashmap对象的具体情况和参数，下面是源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void hashMapRefectionStudy() throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始化map</span><br><span class="line">    Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 15; i++) &#123;</span><br><span class="line">        map.put((int) Math.pow(2, i), String.valueOf(i));</span><br><span class="line">    &#125;   </span><br><span class="line">    map.put(96,15+&quot;&quot;);</span><br><span class="line">    printMapStructure(map);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 打印map数据结构</span><br><span class="line">private void printMapStructure(HashMap map) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">    Class&lt;?&gt; nodeClass &#x3D; Class.forName(&quot;java.util.HashMap$Node&quot;);</span><br><span class="line">    Class&lt;?&gt; treeNodeClass &#x3D; Class.forName(&quot;java.util.HashMap$TreeNode&quot;);</span><br><span class="line">    Object size &#x3D; getFieldValue(&quot;size&quot;, map);</span><br><span class="line">    log.info(&quot;size:&quot; + size);</span><br><span class="line">    Object modCount &#x3D; getFieldValue(&quot;modCount&quot;, map);</span><br><span class="line">    log.info(&quot;modCount:&quot; + modCount);</span><br><span class="line">    Object threshold &#x3D; getFieldValue(&quot;threshold&quot;, map);</span><br><span class="line">    log.info(&quot;threshold:&quot; + threshold);</span><br><span class="line">    Object loadFactor &#x3D; getFieldValue(&quot;loadFactor&quot;, map);</span><br><span class="line">    log.info(&quot;loadFactor:&quot; + loadFactor);</span><br><span class="line">    &#x2F;&#x2F; 获取table大小和相关属性</span><br><span class="line">    Object[] table &#x3D; (Object[]) getFieldValue(&quot;table&quot;, map);</span><br><span class="line">    log.info(&quot;table:&quot; + table.length);</span><br><span class="line">    &#x2F;&#x2F; 格式化打印数据</span><br><span class="line">    for (int i &#x3D; 0; i &lt; table.length; i++) &#123;</span><br><span class="line">        Object o &#x3D; table[i];</span><br><span class="line">        System.out.print(&quot;[&quot; + i + &quot;\t] &quot;);</span><br><span class="line">        if (o !&#x3D; null) &#123;</span><br><span class="line">            if (o.getClass() &#x3D;&#x3D; nodeClass) &#123;&#x2F;&#x2F; 默认为链表</span><br><span class="line">                System.out.print(&quot;link &quot;);</span><br><span class="line">                while (o !&#x3D; null) &#123;</span><br><span class="line">                    System.out.print(o + &quot; &quot;);</span><br><span class="line">                    o &#x3D; getFieldValue(&quot;next&quot;, o);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125; else if (o.getClass() &#x3D;&#x3D; treeNodeClass) &#123;&#x2F;&#x2F; 如果是红黑树</span><br><span class="line">                System.out.println(&quot;tree &quot;);</span><br><span class="line">                &#x2F;&#x2F; 获取root</span><br><span class="line">                Object root &#x3D; o;</span><br><span class="line">                &#x2F;&#x2F; 通过队列上线广度搜索打印</span><br><span class="line">                LinkedList&lt;Object&gt; queue &#x3D; new LinkedList();</span><br><span class="line">                queue.add(root);</span><br><span class="line">                int treeCnt &#x3D; 1;</span><br><span class="line">                while (!queue.isEmpty()) &#123;</span><br><span class="line">                    Object firstNode &#x3D; queue.removeFirst();</span><br><span class="line">                    System.out.print(firstNode + &quot;\t\t&quot;);</span><br><span class="line">                    if (firstNode !&#x3D; null) &#123;</span><br><span class="line">                        Object leftNode &#x3D; getFieldValue(&quot;left&quot;, firstNode);</span><br><span class="line">                        queue.addLast(leftNode);</span><br><span class="line">                        Object rightNode &#x3D; getFieldValue(&quot;right&quot;, firstNode);</span><br><span class="line">                        queue.addLast(rightNode);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (isLayerLastTreeNode(treeCnt)) &#123;</span><br><span class="line">                        System.out.println();</span><br><span class="line">                    &#125;</span><br><span class="line">                    treeCnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;link &quot; + o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判断是否是一层树叶的最后一个</span><br><span class="line">&#x2F;&#x2F; 1 3 7 15 31 ...</span><br><span class="line">public boolean isLayerLastTreeNode(int num) &#123;</span><br><span class="line">    double n &#x3D; (Math.log(num + 1) &#x2F; Math.log(2));</span><br><span class="line">    return n &#x3D;&#x3D; (int) n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过反射获取对象的任意属性</span><br><span class="line">public Object getFieldValue(String field, Object obj) throws NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">    Class&lt;?&gt; aClass &#x3D; obj.getClass();</span><br><span class="line">    Field declaredField &#x3D; aClass.getDeclaredField(field);</span><br><span class="line">    if (declaredField &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    declaredField.setAccessible(true);</span><br><span class="line">    return declaredField.get(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面函数介绍：</p>
<ul>
<li>先初始化map，用来后序的分析。</li>
<li>准备hashmap中的链表节点<code>java.util.HashMap$Node</code>和树节点<code>java.util.HashMap$TreeNode</code>的class。</li>
<li>通过反射获取hashmap的桶（或者称为槽）<code>table</code>属性，通过可以看到是个数组，所以我们可以转为对象数组。</li>
<li>然后分别获取map的属性：<code>size、modCount、threshold、loadFactor</code>,下面我们会介绍每个属性。</li>
<li>循环table数组，我们获取每个元素，然后根据元素来判断是链表还是树。</li>
<li>如果是链表则根据链表方式打印，如果是树则根据树的广度优先搜索打印。<br>运行结果：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">11:21:02:444|DEBUG|main|28|pid&#x3D;34297@sanhang.local</span><br><span class="line">11:21:02:463|INFO |main|74|table:64</span><br><span class="line">11:21:02:476|INFO |main|76|size:16</span><br><span class="line">11:21:02:477|INFO |main|78|modCount:16</span><br><span class="line">11:21:02:477|INFO |main|80|threshold:48</span><br><span class="line">11:21:02:481|INFO |main|82|loadFactor:0.75</span><br><span class="line">[0	] tree </span><br><span class="line">512&#x3D;9		</span><br><span class="line">128&#x3D;7		2048&#x3D;11		</span><br><span class="line">64&#x3D;6		256&#x3D;8		1024&#x3D;10		8192&#x3D;13		</span><br><span class="line">null		null		null		null		null		null		4096&#x3D;12		16384&#x3D;14		</span><br><span class="line">                                                                        null		null		null		null		&#x2F;&#x2F; 树结构</span><br><span class="line">[1	] link 1&#x3D;0 </span><br><span class="line">[2	] link 2&#x3D;1 </span><br><span class="line">[3	] link null</span><br><span class="line">[4	] link 4&#x3D;2 </span><br><span class="line">[5	] link null</span><br><span class="line">[6	] link null</span><br><span class="line">[7	] link null</span><br><span class="line">[8	] link 8&#x3D;3 </span><br><span class="line">[9	] link null</span><br><span class="line">[10	] link null</span><br><span class="line">...</span><br><span class="line">[30	] link null</span><br><span class="line">[31	] link null</span><br><span class="line">[32	] link 32&#x3D;5 96&#x3D;15 &#x2F;&#x2F; 链表结构出现</span><br><span class="line">...</span><br><span class="line">[61	] link null</span><br><span class="line">[62	] link null</span><br><span class="line">[63	] link null</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="hashmap是个什么数据结构"><a href="#hashmap是个什么数据结构" class="headerlink" title="hashmap是个什么数据结构"></a>hashmap是个什么数据结构</h2><p>通过我们的对map得分析运行结果可以得出，hashmap是由数组+链表+红黑树数据结果构成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 数组</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br><span class="line">&#x2F;&#x2F; 链表</span><br><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        this.hash &#x3D; hash;</span><br><span class="line">        this.key &#x3D; key;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 红黑树</span><br><span class="line">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  &#x2F;&#x2F; red-black tree links</span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    &#x2F;&#x2F; needed to unlink next upon deletion</span><br><span class="line">    boolean red;</span><br><span class="line">    TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/mvilplss/note/raw/master/image/hashmap%E7%BB%93%E6%9E%84.png" alt="丑见谅!"></p>
<p>说完结构，我们看些hashmap的一些重要常量和成员变量：<br><em>六个常量</em>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * The default initial capacity - MUST be a power of two.</span><br><span class="line"> *&#x2F;</span><br><span class="line"> &#x2F;&#x2F; 初始化容量</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * The maximum capacity, used if a higher value is implicitly specified</span><br><span class="line"> * by either of the constructors with arguments.</span><br><span class="line"> * MUST be a power of two &lt;&#x3D; 1&lt;&lt;30.</span><br><span class="line"> *&#x2F;</span><br><span class="line"> &#x2F;&#x2F; 最大容量</span><br><span class="line">static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * The load factor used when none specified in constructor.</span><br><span class="line"> *&#x2F;</span><br><span class="line"> &#x2F;&#x2F; 负载因子</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * The bin count threshold for using a tree rather than list for a</span><br><span class="line"> * bin.  Bins are converted to trees when adding an element to a</span><br><span class="line"> * bin with at least this many nodes. The value must be greater</span><br><span class="line"> * than 2 and should be at least 8 to mesh with assumptions in</span><br><span class="line"> * tree removal about conversion back to plain bins upon</span><br><span class="line"> * shrinkage.</span><br><span class="line"> *&#x2F;</span><br><span class="line"> &#x2F;&#x2F; 链表转树的阈值</span><br><span class="line">static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * The bin count threshold for untreeifying a (split) bin during a</span><br><span class="line"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span><br><span class="line"> * most 6 to mesh with shrinkage detection under removal.</span><br><span class="line"> *&#x2F;</span><br><span class="line"> &#x2F;&#x2F; 树转链表的阈值</span><br><span class="line">static final int UNTREEIFY_THRESHOLD &#x3D; 6;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * The smallest table capacity for which bins may be treeified.</span><br><span class="line"> * (Otherwise the table is resized if too many nodes in a bin.)</span><br><span class="line"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span><br><span class="line"> * between resizing and treeification thresholds.</span><br><span class="line"> *&#x2F;</span><br><span class="line"> &#x2F;&#x2F; 最小树化的容量大小</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</span><br></pre></td></tr></table></figure>
<p>关于常量的几个疑问：<br>1.为什么容量必须是2的n次方？<br>  为了提高计算效率，hashmap把原来的<code>取模%</code>换成了<code>与&amp;</code>(两个数都为1则为1，否则为0)位运算，而hash%length==hash&amp;(length-1)的前提是length是2的n次方。<br>  hashmap的最小容量是2。<br>2.链表转树的阈值和最小树化的容量大小的关系？<br>  当hashmap的容量小于64(<code>MIN_TREEIFY_CAPACITY</code>)的时候（也就是2，4，8，16，32）如果某个桶上的链表长度大于8（<code>TREEIFY_THRESHOLD</code>），则hashmap首先做扩容而不是做树化。如果容量大于等于<code>MIN_TREEIFY_CAPACITY</code>的时候有链表大于等于<code>TREEIFY_THRESHOLD</code>则做树化。</p>
<p><em>六个变量</em>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * The table, initialized on first use, and resized as</span><br><span class="line"> * necessary. When allocated, length is always a power of two.</span><br><span class="line"> * (We also tolerate length zero in some operations to allow</span><br><span class="line"> * bootstrapping mechanics that are currently not needed.)</span><br><span class="line"> *&#x2F;</span><br><span class="line"> &#x2F;&#x2F; 桶数组</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Holds cached entrySet(). Note that AbstractMap fields are used</span><br><span class="line"> * for keySet() and values().</span><br><span class="line"> *&#x2F;</span><br><span class="line"> &#x2F;&#x2F; 调用hashmap.entrySet()的结果缓存。</span><br><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * The number of key-value mappings contained in this map.</span><br><span class="line"> *&#x2F;</span><br><span class="line"> &#x2F;&#x2F; 存放数据的个数</span><br><span class="line">transient int size;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * The number of times this HashMap has been structurally modified</span><br><span class="line"> * Structural modifications are those that change the number of mappings in</span><br><span class="line"> * the HashMap or otherwise modify its internal structure (e.g.,</span><br><span class="line"> * rehash).  This field is used to make iterators on Collection-views of</span><br><span class="line"> * the HashMap fail-fast.  (See ConcurrentModificationException).</span><br><span class="line"> *&#x2F;</span><br><span class="line"> &#x2F;&#x2F; 修改总数</span><br><span class="line">transient int modCount;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * The next size value at which to resize (capacity * load factor).</span><br><span class="line"> *</span><br><span class="line"> * @serial</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;&#x2F; (The javadoc description is true upon serialization.</span><br><span class="line">&#x2F;&#x2F; Additionally, if the table array has not been allocated, this</span><br><span class="line">&#x2F;&#x2F; field holds the initial array capacity, or zero signifying</span><br><span class="line">&#x2F;&#x2F; DEFAULT_INITIAL_CAPACITY.)</span><br><span class="line">&#x2F;&#x2F; 扩容的阈值</span><br><span class="line">int threshold;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * The load factor for the hash table.</span><br><span class="line"> *</span><br><span class="line"> * @serial</span><br><span class="line"> *&#x2F;</span><br><span class="line"> &#x2F;&#x2F; 加载因子</span><br><span class="line">final float loadFactor;</span><br></pre></td></tr></table></figure>
<p>关于变量的几个疑问：</p>
<ol>
<li><p>hashmap最大可以存多少个key-value？<br>以前我认为size为int变量，最多可以存储2的32次方个，否则size计数将会出现负数。然而我做了个实验发现确实出现负数了，但是还可以继续存储，所以hashmap理论可以存无限个（取决与你的内存）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void maxSize() throws Exception&#123;</span><br><span class="line">    Map map &#x3D; new HashMap();</span><br><span class="line">    &#x2F;&#x2F; 通过反射将size设置为Integer.MAX_VALUE</span><br><span class="line">    Class&lt;? extends Map&gt; mapClass &#x3D; map.getClass();</span><br><span class="line">    Field sizeField &#x3D; mapClass.getDeclaredField(&quot;size&quot;);</span><br><span class="line">    sizeField.setAccessible(true);</span><br><span class="line">    sizeField.set(map,Integer.MAX_VALUE);</span><br><span class="line">    &#x2F;&#x2F; 输出</span><br><span class="line">    log.info(s(map.size()));</span><br><span class="line">    map.put(&quot;last&quot;,&quot;&quot;);&#x2F;&#x2F; 添加一个</span><br><span class="line">    log.info(s(map.size()));</span><br><span class="line">    map.put(&quot;really_last&quot;,&quot;&quot;);&#x2F;&#x2F; 添加一个</span><br><span class="line">    log.info(s(map.size()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">13:34:54:136|INFO |main|307|2147483647</span><br><span class="line">13:34:54:137|INFO |main|309|-2147483648 &#x2F;&#x2F; 负数</span><br><span class="line">13:34:54:137|INFO |main|311|-2147483647 &#x2F;&#x2F; 负数增加1</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>modCount</code>记录每次修改+1，有什么作用？<br>如果你看过jdk的其他集合源码也会看到这个变量，这个变量通过记录修改次数来实现<code>fail-fast</code>的，fail-fast可以防止新同学在多线程中使用hashmap导致的潜在问题，早发现早解决。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; fail-fast</span><br><span class="line">@Test</span><br><span class="line">public void failFast() throws Exception&#123;</span><br><span class="line">    &#x2F;&#x2F; 初始化map</span><br><span class="line">    Map map &#x3D; new HashMap();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">        map.put(i,i);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 创建一个线程来循环map的元素</span><br><span class="line">    Thread thread &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">        Set set &#x3D; map.entrySet();</span><br><span class="line">        for (Object s : set) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            TestUtil.sleep(100);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    &#x2F;&#x2F; 操作map</span><br><span class="line">    map.put(&quot;100&quot;,&#39;1&#39;);</span><br><span class="line">    thread.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0&#x3D;0</span><br><span class="line">Exception in thread &quot;Thread-0&quot; java.util.ConcurrentModificationException</span><br><span class="line">	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1445)</span><br><span class="line">	at java.util.HashMap$EntryIterator.next(HashMap.java:1479)</span><br><span class="line">	at java.util.HashMap$EntryIterator.next(HashMap.java:1477)</span><br><span class="line">	at demo.HashMapDemo$1.run(HashMapDemo.java:326)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>
<p>循环源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">    public final int size()                 &#123; return size; &#125;</span><br><span class="line">    public final void clear()               &#123; HashMap.this.clear(); &#125;</span><br><span class="line">    </span><br><span class="line">    public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        if (action &#x3D;&#x3D; null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        if (size &gt; 0 &amp;&amp; (tab &#x3D; table) !&#x3D; null) &#123;</span><br><span class="line">            int mc &#x3D; modCount;&#x2F;&#x2F; 暂存mc &#x3D; modCount</span><br><span class="line">            for (int i &#x3D; 0; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                for (Node&lt;K,V&gt; e &#x3D; tab[i]; e !&#x3D; null; e &#x3D; e.next)</span><br><span class="line">                    action.accept(e);</span><br><span class="line">            &#125;</span><br><span class="line">            if (modCount !&#x3D; mc)&#x2F;&#x2F; 校验 mc 和 modCount 如果不等则抛出异常。</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><code>threshold</code>和<code>loadFactor</code>的关系？<br>我们先看下resize()函数的部分源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;   &#x2F;&#x2F; zero initial threshold signifies using defaults</span><br><span class="line">    newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line">if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">    newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">              (int)ft : Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line">threshold &#x3D; newThr;</span><br></pre></td></tr></table></figure>
<p>通过源码可以看出：<code>threshold = cap * loadFactor</code>,<code>threshold</code>最大为Integer.MAX_VALUE。<br>另外我们在创建HashMap的时候可以传入loadFactor来定制负载因子，负载因子可以为&gt;0的任意数，通过loadFactor我们可以控制hashmap的扩容阈值，假如我们要时间换空间，那么loadFactor可以设置大些，如果空间换时间可以设置小点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;(10,3);</span><br><span class="line">&#x2F;&#x2F; 存储结构，16个桶位可以容纳三十个元素</span><br><span class="line">[0	] link 0&#x3D;0 16&#x3D;4 64&#x3D;8 144&#x3D;12 256&#x3D;16 400&#x3D;20 576&#x3D;24 784&#x3D;28 </span><br><span class="line">[1	] link 1&#x3D;1 49&#x3D;7 81&#x3D;9 225&#x3D;15 289&#x3D;17 529&#x3D;23 625&#x3D;25 </span><br><span class="line">[2	] link null</span><br><span class="line">[3	] link null</span><br><span class="line">[4	] link 4&#x3D;2 36&#x3D;6 100&#x3D;10 196&#x3D;14 324&#x3D;18 484&#x3D;22 676&#x3D;26 </span><br><span class="line">[5	] link null</span><br><span class="line">[6	] link null</span><br><span class="line">[7	] link null</span><br><span class="line">[8	] link null</span><br><span class="line">[9	] link 9&#x3D;3 25&#x3D;5 121&#x3D;11 169&#x3D;13 361&#x3D;19 441&#x3D;21 729&#x3D;27 841&#x3D;29 </span><br><span class="line">[10	] link null</span><br><span class="line">[11	] link null</span><br><span class="line">[12	] link null</span><br><span class="line">[13	] link null</span><br><span class="line">[14	] link null</span><br><span class="line">[15	] link null</span><br></pre></td></tr></table></figure>
<h2 id="hashmap几个关键函数"><a href="#hashmap几个关键函数" class="headerlink" title="hashmap几个关键函数"></a>hashmap几个关键函数</h2><p>我们的hashmap结构和一些重要常量和变量了解完后，下面我们将进行分析一些关键的函数。</p>
</li>
</ol>
<h3 id="tableSizeFor"><a href="#tableSizeFor" class="headerlink" title="tableSizeFor()"></a>tableSizeFor()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; hashmap构造</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    this.loadFactor &#x3D; loadFactor;</span><br><span class="line">    &#x2F;&#x2F; 将容量大小暂存到threshold中，在resize的时候会用来做newCap来初始化容量。</span><br><span class="line">    this.threshold &#x3D; tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 主角</span><br><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    int n &#x3D; cap - 1;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 1;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 2;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 4;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 8;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 16;</span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; resize()部分</span><br><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line">        int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">        int oldThr &#x3D; threshold;</span><br><span class="line">        ...省略</span><br><span class="line">        newCap &#x3D; oldThr;</span><br><span class="line">        ...省略</span><br><span class="line">        Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];&#x2F;&#x2F; 初始化</span><br><span class="line">        ...省略</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过源码我们可以看到当我们构造一个指定容量大小的hashmap时候会调用<code>tableSizeFor</code>生成新的容量，然后赋值给threshold，通过初始化<code>resize</code>函数最终传递给newCap：<code>newCap = oldThr</code>，实现newTab初始化的的容量大小.<br>那么<code>tableSizeFor</code>函数具体在干嘛呢？这一堆<code>&gt;&gt;&gt;</code>计算什么？<br>还记得常量容量的注释上有这么一句话：MUST be a power of two.而我们定义的容量怎么转化为a power of two就是<code>tableSizeFor</code>要做的事情。<br>我们使用自定义容量cap=14来举例整个计算过程，14的二进制表示为：00000000 00000000 00000000  00001110。</p>
<blockquote>
<p>“|”或：从高位开始比较，两个数只要有一个为1则为1，否则就为0。”&gt;&gt;&gt;”向右无符号移动。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1、int n &#x3D; cap - 1;</span><br><span class="line">n &#x3D; 00000000 00000000 00000000  00001100</span><br><span class="line"></span><br><span class="line">2、n |&#x3D; n &gt;&gt;&gt; 1;</span><br><span class="line">[&gt;&gt;&gt;1]:</span><br><span class="line">n &#x3D; 00000000 00000000 00000000  00000110</span><br><span class="line">[n|&#x3D; ]:</span><br><span class="line">n &#x3D; 00000000 00000000 00000000  00001110</span><br><span class="line"></span><br><span class="line">3、n |&#x3D; n &gt;&gt;&gt; 2;</span><br><span class="line">[&gt;&gt;&gt;2]:</span><br><span class="line">n &#x3D; 00000000 00000000 00000000  00000001</span><br><span class="line">[n|&#x3D; ]:</span><br><span class="line">n &#x3D; 00000000 00000000 00000000  00001111</span><br><span class="line"></span><br><span class="line">4、n |&#x3D; n &gt;&gt;&gt; 4;</span><br><span class="line">[&gt;&gt;&gt;4]:</span><br><span class="line">n &#x3D; 00000000 00000000 00000000  00000000</span><br><span class="line">[n|&#x3D; ]:</span><br><span class="line">n &#x3D; 00000000 00000000 00000000  00001111</span><br><span class="line"></span><br><span class="line">5、n |&#x3D; n &gt;&gt;&gt; 8;</span><br><span class="line">[&gt;&gt;&gt;8]:</span><br><span class="line">n &#x3D; 00000000 00000000 00000000  00000000</span><br><span class="line">[n|&#x3D; ]:</span><br><span class="line">n &#x3D; 00000000 00000000 00000000  00001111</span><br><span class="line"></span><br><span class="line">6、n |&#x3D; n &gt;&gt;&gt; 16;</span><br><span class="line">[&gt;&gt;&gt;16]:</span><br><span class="line">n &#x3D; 00000000 00000000 00000000  00000000</span><br><span class="line">[n|&#x3D; ]:</span><br><span class="line">n &#x3D; 00000000 00000000 00000000  00001111</span><br><span class="line"></span><br><span class="line">7、return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">n &#x3D; 00000000 00000000 00000000  00010000</span><br><span class="line">最终转为十进制为：n&#x3D;16</span><br></pre></td></tr></table></figure>
<p>这个函数的最终目的就是把传入的cap-1然后把最高位1的后面所有0转为1，最后在加1得大于等于cap的最小2的n次方值。这里还有个小细节就是当你传入的cap=0的时候，在第6步计算出n为负数，第7步通过两个三元表达式保证n最小为2。</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash()"></a>hash()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个哈希函数最核心的地方就是：(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)，实现hashCode的高低位运算。</p>
<blockquote>
<p>“^”从高位开始比较，如果相同则为0，不相同则为1。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">比如key&#x3D;88888888：</span><br><span class="line">key二进制：00000101 01001100 01010110 00111000</span><br><span class="line">key&gt;&gt;&gt;16：00000000 00000000 00000101 01001100</span><br><span class="line">求出^结果：00000101 01001100 01010011 01110100</span><br></pre></td></tr></table></figure>
<p>通过高低位运算提高了hash攻击的难度，让hash更散。</p>
<h3 id="putVal"><a href="#putVal" class="headerlink" title="putVal()"></a>putVal()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        return putVal(hash(key), key, value, false, true);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        &#x2F;&#x2F; 判断是否初始化，否则调用resize进行初始化。</span><br><span class="line">        if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">            n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">        &#x2F;&#x2F; 进行桶位计算并判断当前桶是否为空，空则创建个node放进去。</span><br><span class="line">        if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">            tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">        else &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            &#x2F;&#x2F; 如果hash相等并且key相等则说明当前key已经存在，则把已经存在的p赋给e用于后续操作。</span><br><span class="line">            if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                e &#x3D; p;</span><br><span class="line">            &#x2F;&#x2F; 如果是树则按照树的方式存入或获取相同的key的节点赋值给e。</span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">                e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            &#x2F;&#x2F; 否则为链表</span><br><span class="line">            else &#123;</span><br><span class="line">                for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                    if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                        &#x2F;&#x2F; 通过binCount来判断更新后的链表是否大于等于（TREEIFY_THRESHOLD&#x3D;8）则进行树化。</span><br><span class="line">                        if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                        ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p &#x3D; e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 如果e不为null则说明key已经存在，默认是替换原来的value，除非onlyIfAbsent&#x3D;true</span><br><span class="line">            if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">                V oldValue &#x3D; e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                    e.value &#x3D; value;</span><br><span class="line">                afterNodeAccess(e);&#x2F;&#x2F; Callbacks to allow LinkedHashMap post-actions</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        if (++size &gt; threshold)&#x2F;&#x2F; 当元素大于threshold时候进行扩容</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);&#x2F;&#x2F; Callbacks to allow LinkedHashMap post-actions</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   &#x2F;**</span><br><span class="line">     * Replaces all linked nodes in bin at index for given hash unless</span><br><span class="line">     * table is too small, in which case resizes instead.</span><br><span class="line">     *&#x2F;</span><br><span class="line">     &#x2F;&#x2F; 判断是要转换为树</span><br><span class="line">    final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">        int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        &#x2F;&#x2F; 如果桶的长度小于64则进行扩容</span><br><span class="line">        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line">         &#x2F;&#x2F; 否则进行转为树。</span><br><span class="line">        else if ((e &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;</span><br><span class="line">            do &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; p &#x3D; replacementTreeNode(e, null);</span><br><span class="line">                if (tl &#x3D;&#x3D; null)</span><br><span class="line">                    hd &#x3D; p;</span><br><span class="line">                else &#123;</span><br><span class="line">                    p.prev &#x3D; tl;</span><br><span class="line">                    tl.next &#x3D; p;</span><br><span class="line">                &#125;</span><br><span class="line">                tl &#x3D; p;</span><br><span class="line">            &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">            if ((tab[index] &#x3D; hd) !&#x3D; null)</span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过源码分析，put操作主要有以下几个重要步骤：</p>
<ol>
<li>判断是否初始化，没有初始化则进行resize操作。</li>
<li>通过hash值和容量算出桶位，判断桶位上是否已经有元素，没有则创建个node对象直接放进去。</li>
<li>如果有值则判断当前值的key是否相等（p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))，若相等则缓存当前元素到e。</li>
<li>否则进行判断当前节点是否是树，如果是树，则按照树的方式加入元素。</li>
<li>如果不是树则按照链表方式加入元素，如果新增元素后链表长度大于8则进行调用treeifyBin，treeifyBin会根据树化阈值和树化最小容量来决定是否要扩容或者树化。</li>
<li>最后根据onlyIfAbsent来决定已经存在的key是否要替换位新的value，默认是false（替换）。</li>
<li>在最后的最后在判断当前元素个数size是否大于扩容阈值threshold，如果大于则进行调用resize()进行扩容。</li>
</ol>
<h3 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h3><p>当调用hashmap的put操作时候，如果有下面情况则发生扩容：</p>
<ol>
<li>当table变量为null，调用resize进行初始化。</li>
<li>当新加入一个元素时候发现链表长度&gt;=8但是当前容量小于64，则进行扩容。</li>
<li>当新加入一个元素后元素总数大于threshold</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Initializes or doubles table size.  If null, allocates in</span><br><span class="line"> * accord with initial capacity target held in field threshold.</span><br><span class="line"> * Otherwise, because we are using power-of-two expansion, the</span><br><span class="line"> * elements from each bin must either stay at same index, or move</span><br><span class="line"> * with a power of two offset in the new table.</span><br><span class="line"> *</span><br><span class="line"> * @return the table</span><br><span class="line"> *&#x2F;</span><br><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line">    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr &#x3D; threshold;</span><br><span class="line">    int newCap, newThr &#x3D; 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果容量达到最大还进行扩容，则将阈值设为最大。</span><br><span class="line">        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 否则新的容量进行*2</span><br><span class="line">        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold 扩容阈值也翻倍</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果使用带指定容量的构造器时候会将容量暂存到threshold上，然后在这里赋值给newCap.</span><br><span class="line">    else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold</span><br><span class="line">        newCap &#x3D; oldThr;</span><br><span class="line">    &#x2F;&#x2F; 默认构造器第一次初始化</span><br><span class="line">    else &#123;               &#x2F;&#x2F; zero initial threshold signifies using defaults</span><br><span class="line">        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;  如果使用带指定容量的构造器时候newThr需要根据newCap计算获取。</span><br><span class="line">    if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold &#x3D; newThr;&#x2F;&#x2F; 最终赋值给threshold。</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];&#x2F;&#x2F; 创建新数组</span><br><span class="line">    table &#x3D; newTab;</span><br><span class="line">    &#x2F;&#x2F; 如果老的table不为空则需要重新计算桶位和节点上的元素位置</span><br><span class="line">    if (oldTab !&#x3D; null) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class="line">                oldTab[j] &#x3D; null;&#x2F;&#x2F; 帮助垃圾回收</span><br><span class="line">                &#x2F;&#x2F; 如果只有一个节点那么直接通过hash计算出新的桶位。</span><br><span class="line">                if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line">                &#x2F;&#x2F; 如果节点是个树，那么按照树的方式分解</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; &#x2F;&#x2F; preserve order</span><br><span class="line">                    &#x2F;&#x2F; 否则是链表，这里链表通过生成两组高低位链表，并且保持链表原来的顺序</span><br><span class="line">                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next &#x3D; e.next;</span><br><span class="line">                        &#x2F;&#x2F; 如果hash&amp;oldCap为0则为低位，也就是原来位置，下面会介绍为什么这样。</span><br><span class="line">                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                loHead &#x3D; e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next &#x3D; e;</span><br><span class="line">                            loTail &#x3D; e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;&#x2F;&#x2F; 否则放到高位链表上</span><br><span class="line">                            if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                hiHead &#x3D; e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next &#x3D; e;</span><br><span class="line">                            hiTail &#x3D; e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                    &#x2F;&#x2F; 将低位的链表头放到原来的桶位</span><br><span class="line">                    if (loTail !&#x3D; null) &#123;</span><br><span class="line">                        loTail.next &#x3D; null;</span><br><span class="line">                        newTab[j] &#x3D; loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 将高位的链表头放到原来位置+原来容量的位置</span><br><span class="line">                    if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                        hiTail.next &#x3D; null;</span><br><span class="line">                        newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过源码分析，resize()可分为以下步骤：</p>
<ol>
<li>容量<code>newCap</code>、<code>threshold</code>阈值的计算和newTab的创建。</li>
<li>老的单节点直接向新的桶中拷贝。</li>
<li>老的树节点向新的桶中拷贝。</li>
<li>老的链节点向新的桶中拷贝，这里通过链表分组方式进行拷贝，同时还保留了原来的链表顺序。</li>
</ol>
<p>这里有个问题，为什么<code>(e.hash &amp; oldCap) == 0</code>位置不变，而需要变的位置为<code>j + oldCap</code>?</p>
<ul>
<li>oldCap一定是2的整数次幂, 这里假设是2^m</li>
<li>newCap是oldCap的两倍, 则会是2^(m+1)</li>
<li>hash对数组大小取模(n - 1) &amp; hash 其实就是取hash的低m位.</li>
</ul>
<p>比如当容量32的时候35值放在第3个桶位，当扩容到64容量时候放到第35桶位的需要移位情况计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">容量cap &#x3D; 32:</span><br><span class="line">index &#x3D; (cap-1)&amp;35:</span><br><span class="line">cap-1:00000000 00000000 00000000 00011111</span><br><span class="line">&amp;35  :00000000 00000000 00000000 00100011</span><br><span class="line">&#x3D;3   :00000000 00000000 00000000 00000011</span><br><span class="line"></span><br><span class="line">扩容后新容量nap &#x3D; 64:</span><br><span class="line">index &#x3D; (nap-1)&amp;35:</span><br><span class="line">nap-1:00000000 00000000 00000000 00111111</span><br><span class="line">&amp;35  :00000000 00000000 00000000 00100011</span><br><span class="line">&#x3D;35  :00000000 00000000 00000000 00100011</span><br><span class="line"></span><br><span class="line">当和老的容量cap&#x3D;32做&amp;运算来判断是否移位，其实就是算下：</span><br><span class="line">index &#x3D; cap&amp;35:</span><br><span class="line">cap  :00000000 00000000 00000000 00100000</span><br><span class="line">&amp;35  :00000000 00000000 00000000 00100011</span><br><span class="line">&#x3D;32  :00000000 00000000 00000000 00100000</span><br><span class="line">显然结果cap&amp;35&#x3D;32!&#x3D;0，需要移位（3+cap）&#x3D;35。</span><br></pre></td></tr></table></figure>

<p>比如当容量32的时候67值放在第3个桶位，当扩容到64容量时候还是放到第3个桶位：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">容量cap &#x3D; 32:</span><br><span class="line">index &#x3D; (cap-1)&amp;67:</span><br><span class="line">cap-1:00000000 00000000 00000000 00011111</span><br><span class="line">&amp;67  :00000000 00000000 00000000 01000011</span><br><span class="line">&#x3D;3   :00000000 00000000 00000000 00000011</span><br><span class="line"></span><br><span class="line">扩容后新容量nap &#x3D; 64:</span><br><span class="line">index &#x3D; (nap-1)&amp;67:</span><br><span class="line">nap-1:00000000 00000000 00000000 00111111</span><br><span class="line">&amp;67  :00000000 00000000 00000000 01000011</span><br><span class="line">&#x3D;3   :00000000 00000000 00000000 00000011</span><br><span class="line"></span><br><span class="line">当和老的容量cap&#x3D;32做&amp;运算来判断是否移位，其实就是算下：</span><br><span class="line">index &#x3D; cap&amp;67:</span><br><span class="line">cap  :00000000 00000000 00000000 00100000</span><br><span class="line">&amp;67  :00000000 00000000 00000000 01000011</span><br><span class="line">&#x3D;0   :00000000 00000000 00000000 00000000</span><br><span class="line">显然结果cap&amp;35&#x3D;0&#x3D;&#x3D;0，不需要移位。</span><br></pre></td></tr></table></figure>

<h2 id="hashmap每个阶段分析"><a href="#hashmap每个阶段分析" class="headerlink" title="hashmap每个阶段分析"></a>hashmap每个阶段分析</h2><p>到这里的同学应该已经大致了解hashmap的基本原理和关键的函数了，下面我们将通过想hashmap不断的增加数据和减少数据总结每个阶段：</p>
<ol>
<li>创建对象阶段<br>当我们使用new HashMap()创建一个对象的时候，只是初始化<code>loadFactor=DEFAULT_LOAD_FACTOR</code>值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">14:02:264|INFO |main|33|size:0</span><br><span class="line">14:02:265|INFO |main|35|modCount:0</span><br><span class="line">14:02:265|INFO |main|37|threshold:0</span><br><span class="line">14:02:274|INFO |main|39|loadFactor:0.75</span><br></pre></td></tr></table></figure></li>
<li>初始化容量阶段<br>当添加第一个元素的时候，hashmap进行真正的初始化，主要是创建table容量，默认长度为16。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">16:32:850|INFO |main|33|size:1</span><br><span class="line">16:32:850|INFO |main|35|modCount:1</span><br><span class="line">16:32:851|INFO |main|37|threshold:12</span><br><span class="line">16:32:854|INFO |main|39|loadFactor:0.75</span><br><span class="line">16:32:854|INFO |main|42|table:16</span><br></pre></td></tr></table></figure></li>
<li>扩容量阶段<br>扩容的时候执行resize()，threshold和table容量加倍.</li>
</ol>
<ul>
<li>当元素个数size大于threshold=12时候进行扩容。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">25:36:262|INFO |main|33|size:13</span><br><span class="line">25:36:263|INFO |main|35|modCount:13</span><br><span class="line">25:36:263|INFO |main|37|threshold:24</span><br><span class="line">25:36:272|INFO |main|39|loadFactor:0.75</span><br><span class="line">25:36:275|INFO |main|42|table:32</span><br><span class="line">[0	] link 0&#x3D;0 64&#x3D;8 </span><br><span class="line">[1	] link 1&#x3D;1 </span><br><span class="line">[2	] link null</span><br><span class="line">[3	] link null</span><br><span class="line">[4	] link 4&#x3D;2 36&#x3D;6 100&#x3D;10 </span><br><span class="line">[5	] link null...</span><br><span class="line">[8	] link null</span><br><span class="line">[9	] link 9&#x3D;3 </span><br><span class="line">[10	] link null...</span><br><span class="line">[15	] link null</span><br><span class="line">[16	] link 16&#x3D;4 144&#x3D;12 </span><br><span class="line">[17	] link 49&#x3D;7 81&#x3D;9 </span><br><span class="line">[18	] link null...</span><br><span class="line">[25	] link 25&#x3D;5 121&#x3D;11 </span><br><span class="line">[30	] link null</span><br><span class="line">[31	] link null</span><br></pre></td></tr></table></figure></li>
<li>当容量小于64时，某个桶的长度大于8的时候无论size是否大于threshold都进行扩容。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">29:34:140|INFO |main|34|size:12</span><br><span class="line">29:34:141|INFO |main|36|modCount:12</span><br><span class="line">29:34:142|INFO |main|38|threshold:24</span><br><span class="line">29:34:145|INFO |main|40|loadFactor:0.75</span><br><span class="line">29:34:146|INFO |main|43|table:32</span><br><span class="line">[0	] link 32&#x3D;5 64&#x3D;6 128&#x3D;7 256&#x3D;8 512&#x3D;9 1024&#x3D;10 2048&#x3D;11 4096&#x3D;13 </span><br><span class="line">[1	] link null</span><br><span class="line">[2	] link 2&#x3D;1 </span><br><span class="line">[3	] link null</span><br><span class="line">[4	] link 4&#x3D;2 </span><br><span class="line">[5	] link null..</span><br><span class="line">[7	] link null</span><br><span class="line">[8	] link 8&#x3D;3 </span><br><span class="line">[9	] link null...</span><br><span class="line">[15	] link null</span><br><span class="line">[16	] link 16&#x3D;4 </span><br><span class="line">[17	] link null...</span><br><span class="line">[31	] link null</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="5">
<li>树化阶段<br>当容量大于等于64时候，某个桶的长度大于8，则进行树化操作。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">32:03:049|INFO |main|33|size:15</span><br><span class="line">32:03:050|INFO |main|35|modCount:15</span><br><span class="line">32:03:050|INFO |main|37|threshold:48</span><br><span class="line">32:03:080|INFO |main|39|loadFactor:0.75</span><br><span class="line">32:03:081|INFO |main|42|table:64</span><br><span class="line">[0	] tree </span><br><span class="line">512&#x3D;9		</span><br><span class="line">128&#x3D;7		2048&#x3D;11		</span><br><span class="line">64&#x3D;6		256&#x3D;8		1024&#x3D;10		8192&#x3D;13		</span><br><span class="line">null		null		null		null		null		null		4096&#x3D;12		16384&#x3D;14		</span><br><span class="line">                                                                        null		null		null		null		</span><br><span class="line">[1	] link 1&#x3D;0 </span><br><span class="line">[2	] link 2&#x3D;1 </span><br><span class="line">[3	] link null</span><br><span class="line">[4	] link 4&#x3D;2 </span><br><span class="line">[5	] link null...</span><br><span class="line">[7	] link null</span><br><span class="line">[8	] link 8&#x3D;3 </span><br><span class="line">[9	] link null...</span><br><span class="line">[15	] link null</span><br><span class="line">[16	] link 16&#x3D;4 </span><br><span class="line">[17	] link null...</span><br><span class="line">[31	] link null</span><br><span class="line">[32	] link 32&#x3D;5 </span><br><span class="line">[33	] link null...</span><br><span class="line">[63	] link null</span><br></pre></td></tr></table></figure></li>
<li>树退化阶段<br>树的退化并不是我们像链表转为树那样，树的节点小于6就退化为链表，而是分为两种情况：</li>
<li>当扩容的时候，如果树的节点小于等于<code>UNTREEIFY_THRESHOLD=6</code>则转换为链表。</li>
<li>如果是操作remove删除节点的时候，树要转化为链表的的节点个数是小于等于2。</li>
</ol>
<h2 id="hashmap多线程下的问题"><a href="#hashmap多线程下的问题" class="headerlink" title="hashmap多线程下的问题"></a>hashmap多线程下的问题</h2><ul>
<li>在jdk1.7下，当并发插入元素时，由于链表操作会产生环链，当后续有操作环链上的数据时就会进入死循环，在jdk1.8及更高版本后，链表操作进行了分组拷贝，并保持了原来的链表顺序，所以就避免了死循环。</li>
<li>在jdk1.8下，当并发插入元素时候可能会获取不到，原因是当一个线程计算好桶位的时候，而另一个线程出发了map的扩容，这样第一个线程计算的桶位放到了新的扩容后的桶中，当再次查这个key的时候就会使用新的桶长度进行取模，这样就获取不到这个元素了。<br>丢失的元素复现demo源码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">    @Test</span><br><span class="line">    public void concurrentOpretor() throws Exception&#123;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            CountDownLatch countDownLatch &#x3D; new CountDownLatch(2);</span><br><span class="line">            HashMap map &#x3D; new HashMap(0);&#x2F;&#x2F; 容量设置为0，增加扩容次数</span><br><span class="line">            &#x2F;&#x2F; 两个线程同时插入元素</span><br><span class="line">            Thread t1 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">                    map.put(i*2, String.valueOf(i));</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">            Thread t2 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">                    map.put(i*3, String.valueOf(i));</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            &#x2F;&#x2F; 再次获取每个元素，空则抛出异常</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">                Object o &#x3D; map.get(i*2);</span><br><span class="line">                if (o&#x3D;&#x3D;null)&#123;</span><br><span class="line">                    printMapStructure(map);</span><br><span class="line">                    log.error(&quot;key:&#123;&#125;&quot;,s(i*2));</span><br><span class="line">                    throw new RuntimeException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">                Object o &#x3D;  map.get(i*3);</span><br><span class="line">                if (o&#x3D;&#x3D;null)&#123;</span><br><span class="line">                    printMapStructure(map);</span><br><span class="line">                    log.error(&quot;key:&#123;&#125;&quot;,s(i*3));</span><br><span class="line">                    throw new RuntimeException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            TestUtil.sleep(300);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 运行结果：</span><br><span class="line">32:54:631|INFO |main|45|size:1582</span><br><span class="line">32:54:631|INFO |main|47|modCount:1580</span><br><span class="line">32:54:631|INFO |main|49|threshold:3072</span><br><span class="line">32:54:634|INFO |main|51|loadFactor:0.75</span><br><span class="line">32:54:635|INFO |main|54|table:4096</span><br><span class="line">[0	] link 0&#x3D;0 </span><br><span class="line">[1	] link null...</span><br><span class="line">[22	] link 22&#x3D;11 </span><br><span class="line">[23	] link null</span><br><span class="line">[24	] link 24&#x3D;8 152&#x3D;76 </span><br><span class="line">[25	] link null</span><br><span class="line">[26	] link 26&#x3D;13 </span><br><span class="line">[27	] link 27&#x3D;9...</span><br><span class="line">[4094	] link null</span><br><span class="line">[4095	] link null</span><br><span class="line">32:54:736|ERROR|main|354|index:152</span><br><span class="line">32:54:736|DEBUG|main|33|take up time:1728 ms</span><br><span class="line">Disconnected from the target VM, address: &#39;127.0.0.1:60922&#39;, transport: &#39;socket&#39;</span><br><span class="line"></span><br><span class="line">java.lang.RuntimeException</span><br><span class="line">	at demo.HashMapDemo.concurrentOpretor(HashMapDemo.java:355)</span><br></pre></td></tr></table></figure>
通过运行结果可以看出当前容量为4096，但是有个元素152=76 放到了桶位为24的位置，显然是错误的。我们经过hash桶位计算得出key=152的元素只有当容量为64的时候桶位为24。如果容量为4096则key=152的桶位应为152。<br>另外我们也看出map的size属性和modCount也是错误的，都是因为并发时候++size和++modCount也不是原子性的。</li>
</ul>
<h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><p>因为这里要消化的东西不算少，所以关于红黑树的知识就单独抽出来介绍了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhimingxin/p/8609545.html">https://www.cnblogs.com/zhimingxin/p/8609545.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yesiamhere/p/6675067.html">https://www.cnblogs.com/yesiamhere/p/6675067.html</a></li>
</ul>
<blockquote>
<p>相关源码：<a target="_blank" rel="noopener" href="https://github.com/mvilplss/note">https://github.com/mvilplss/note</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://mvilplss.github.io/2017/01/02/Hello%20Bolg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="三行">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三行">
      <meta itemprop="description" content="一行知,二行理,三行本">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三行">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/01/02/Hello%20Bolg/" class="post-title-link" itemprop="url">Hello Bolg</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-01-02 00:00:00" itemprop="dateCreated datePublished" datetime="2017-01-02T00:00:00+08:00">2017-01-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:46:27" itemprop="dateModified" datetime="2022-07-05T22:46:27+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/" itemprop="url" rel="index"><span itemprop="name">开发日常</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="hexo-install"><a href="#hexo-install" class="headerlink" title="hexo install"></a>hexo install</h2><h3 id="安装brew"><a href="#安装brew" class="headerlink" title="安装brew"></a>安装brew</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;</span><br></pre></td></tr></table></figure>
<h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure>
<h3 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h3 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init hexo</span><br></pre></td></tr></table></figure>
<h3 id="开启hexo服务器"><a href="#开启hexo服务器" class="headerlink" title="开启hexo服务器"></a>开启hexo服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>进入主页：<a target="_blank" rel="noopener" href="http://localhost:4000/">http://localhost:4000/</a> </p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/deployment.html">Deployment</a></p>
<h2 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h2><p>ERROR Deployer not found: git<br>执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>extends includes/layout.pug block content include includes/recent-posts.pug include includes/partial<br>执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</span><br></pre></td></tr></table></figure>
<h2 id="增加标题数字"><a href="#增加标题数字" class="headerlink" title="增加标题数字"></a>增加标题数字</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">heading_index:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">index_styles:</span> <span class="string">&quot;&#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125;&quot;</span></span><br><span class="line">  <span class="attr">connector:</span> <span class="string">&quot;.&quot;</span></span><br><span class="line">  <span class="attr">global_prefix:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">global_suffix:</span> <span class="string">&quot;. &quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="卸载hexo"><a href="#卸载hexo" class="headerlink" title="卸载hexo"></a>卸载hexo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-cli -g</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">三行</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
